<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The Tangle Improvement Proposal (TIP) Book</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="introduction.html">Introduction</a></li><li class="chapter-item expanded "><a href="tips/TIP-0001/tip-0001.html">TIP-1 TIP Process</a></li><li class="chapter-item expanded "><a href="tips/TIP-0002/tip-0002.html">TIP-2 White Flag Ordering</a></li><li class="chapter-item expanded "><a href="tips/TIP-0003/tip-0003.html">TIP-3 Uniform Random Tip Selection</a></li><li class="chapter-item expanded "><a href="tips/TIP-0004/tip-0004.html">TIP-4 Milestone Merkle Validation</a></li><li class="chapter-item expanded "><a href="tips/TIP-0005/tip-0005.html">TIP-5 Binary To Ternary Encoding</a></li><li class="chapter-item expanded "><a href="tips/TIP-0006/tip-0006.html">TIP-6 Tangle Message</a></li><li class="chapter-item expanded "><a href="tips/TIP-0007/tip-0007.html">TIP-7 Transaction Payload</a></li><li class="chapter-item expanded "><a href="tips/TIP-0008/tip-0008.html">TIP-8 Milestone Payload</a></li><li class="chapter-item expanded "><a href="tips/TIP-0009/tip-0009.html">TIP-9 Local Snapshot File Format</a></li><li class="chapter-item expanded "><a href="tips/TIP-0010/tip-0010.html">TIP-10 Mnemonic Ternary Seed</a></li><li class="chapter-item expanded "><a href="tips/TIP-0011/tip-0011.html">TIP-11 Bech32 Address Format</a></li><li class="chapter-item expanded "><a href="tips/TIP-0012/tip-0012.html">TIP-12 Message PoW</a></li><li class="chapter-item expanded "><a href="tips/TIP-0013/tip-0013.html">TIP-13 REST API</a></li><li class="chapter-item expanded "><a href="tips/TIP-0014/tip-0014.html">TIP-14 Ed25519 Validation</a></li><li class="chapter-item expanded "><a href="tips/TIP-0015/tip-0015.html">TIP-15 Dust Protection</a></li><li class="chapter-item expanded "><a href="tips/TIP-0016/tip-0016.html">TIP-16 Event API</a></li><li class="chapter-item expanded "><a href="tips/TIP-0017/tip-0017.html">TIP-17 Wotsicide</a></li><li class="chapter-item expanded "><a href="tips/TIP-0018/tip-0018.html">TIP-18 Multi-Asset Ledger and ISC Support</a></li><li class="chapter-item expanded "><a href="tips/TIP-0019/tip-0019.html">TIP-19 Dust Protection Based on Byte Costs (Storage Deposit)</a></li><li class="chapter-item expanded "><a href="tips/TIP-0020/tip-0020.html">TIP-20 Transaction Payload with TIP-18 Output Types</a></li><li class="chapter-item expanded "><a href="tips/TIP-0021/tip-0021.html">TIP-21 Serialization Primitives</a></li><li class="chapter-item expanded "><a href="tips/TIP-0022/tip-0022.html">TIP-22 IOTA Protocol Parameters</a></li><li class="chapter-item expanded "><a href="tips/TIP-0023/tip-0023.html">TIP-23 Tagged Data Payload</a></li><li class="chapter-item expanded "><a href="tips/TIP-0024/tip-0024.html">TIP-24 Tangle Block</a></li><li class="chapter-item expanded "><a href="tips/TIP-0025/tip-0025.html">TIP-25 Core REST API</a></li><li class="chapter-item expanded "><a href="tips/TIP-0026/tip-0026.html">TIP-26 UTXO Indexer API</a></li><li class="chapter-item expanded "><a href="tips/TIP-0027/tip-0027.html">TIP-27 IOTA NFT Standard IRC27</a></li><li class="chapter-item expanded "><a href="tips/TIP-0028/tip-0028.html">TIP-28 Event API</a></li><li class="chapter-item expanded "><a href="tips/TIP-0029/tip-0029.html">TIP-29 Milestone Payload</a></li><li class="chapter-item expanded "><a href="tips/TIP-0030/tip-0030.html">TIP-30 Native Token Metadata JSON Schema</a></li><li class="chapter-item expanded "><a href="tips/TIP-0031/tip-0031.html">TIP-31 Bech32 Address Format</a></li><li class="chapter-item expanded "><a href="tips/TIP-0032/tip-0032.html">TIP-32 Shimmer Protocol Parameters</a></li><li class="chapter-item expanded "><a href="tips/TIP-0034/tip-0034.html">TIP-34 Wotsicide (Stardust)</a></li><li class="chapter-item expanded "><a href="tips/TIP-0035/tip-0035.html">TIP-35 Local Snapshot File Format</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Tangle Improvement Proposal (TIP) Book</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="tangle-improvement-proposal-tip-repository"><a class="header" href="#tangle-improvement-proposal-tip-repository">Tangle Improvement Proposal (TIP) Repository</a></h1>
<p>TIPs are improvement proposals for bettering the IOTA technology stack.</p>
<p>Building the IOTA ecosystem is a community effort, therefore we welcome anyone to propose, discuss and debate ideas that will later become formalized TIPs.</p>
<h2 id="propose-new-ideas"><a class="header" href="#propose-new-ideas">Propose new ideas</a></h2>
<p>Do you have an idea how to improve the IOTA technology stack?</p>
<ul>
<li>Head over to the <a href="https://github.com/iotaledger/tips/discussions">discussions</a> page to browse already submitted ideas or share yours!</li>
<li>Once your idea is discussed, you can submit a draft TIP (<a href="https://github.com/iotaledger/tips/blob/main/tip-template.md">template here</a> as a PR to the repository.</li>
<li>You will receive feedback from the TIP Editors and review from core devs.</li>
<li>Once accepted, your TIP is merged as Draft.</li>
<li>It is your responsibility to drive its implementation and to present a clear plan on how the new feature will be adopted by the network.</li>
<li>Once implementation is ready and testing yields satisfactory result, the TIP becomes Proposed.</li>
<li>Proposed TIPs that are supported by majority of the network become Active.</li>
</ul>
<p>You may find more information about the TIP Process in <a href="./tips/TIP-0001/tip-0001.html">TIP-1</a>.</p>
<h2 id="stardust-tips"><a class="header" href="#stardust-tips">Stardust TIPs</a></h2>
<p>Stardust is the next upgrade of the IOTA protocol that adds tokenization and smart contract chain support besides many
more improvements. Browse the <a href="introduction.html#list-of-tips">list of TIPs</a> below with the <em>Stardust</em> tag to learn more about what changes.</p>
<h2 id="list-of-tips"><a class="header" href="#list-of-tips">List of TIPs</a></h2>
<ul>
<li>Last updated: 2023-10-19</li>
<li>The <em>Status</em> of a TIP reflects its current state with respect to its progression to being supported on the IOTA mainnet.
<ul>
<li><code>Draft</code> TIPs are work in progress. They may or may not have a working implementation on a testnet.</li>
<li><code>Proposed</code> TIPs are demonstrated to have a working implementation. These TIPs are supported on Shimmer, the staging network of IOTA.</li>
<li><code>Active</code> TIPs are supported on the IOTA mainnet.</li>
<li><code>Replaced</code> TIPs have been replaced by a newer TIP.</li>
<li><code>Obsolete</code> TIPs are no longer in use.</li>
</ul>
</li>
</ul>
<p><img src="tips/TIP-0001/process.svg" alt="image" /></p>
<div class="table-wrapper"><table><thead><tr><th>#</th><th>Title</th><th>Description</th><th>Type</th><th>Layer</th><th>Status</th><th>Initial Target</th></tr></thead><tbody>
<tr><td>1</td><td><a href="tips/TIP-0001/tip-0001.html">TIP Process</a></td><td>Purpose and guidelines of the contribution framework</td><td>Process</td><td>-</td><td>Active</td><td>-</td></tr>
<tr><td>2</td><td><a href="tips/TIP-0002/tip-0002.html">White Flag Ordering</a></td><td>Mitigate conflict spamming by ignoring conflicts</td><td>Standards</td><td>Core</td><td>Active</td><td>Chrysalis</td></tr>
<tr><td>3</td><td><a href="tips/TIP-0003/tip-0003.html">Uniform Random Tip Selection</a></td><td>Perform fast tip-selection to increase message throughput</td><td>Standards</td><td>Core</td><td>Active</td><td>Chrysalis</td></tr>
<tr><td>4</td><td><a href="tips/TIP-0004/tip-0004.html">Milestone Merkle Validation</a></td><td>Add Merkle tree hash to milestone for local ledger state verification</td><td>Standards</td><td>Core</td><td>Active</td><td>Chrysalis</td></tr>
<tr><td>5</td><td><a href="tips/TIP-0005/tip-0005.html">Binary To Ternary Encoding</a></td><td>Define the conversion between binary and ternary data</td><td>Standards</td><td>Core</td><td>Active</td><td>Chrysalis</td></tr>
<tr><td>6</td><td><a href="tips/TIP-0006/tip-0006.html">Tangle Message</a></td><td>Generalization of the Tangle transaction concept</td><td>Standards</td><td>Core</td><td>Replaced by TIP-24</td><td>Chrysalis</td></tr>
<tr><td>7</td><td><a href="tips/TIP-0007/tip-0007.html">Transaction Payload</a></td><td>UTXO-based transaction structure</td><td>Standards</td><td>Core</td><td>Replaced by TIP-20</td><td>Chrysalis</td></tr>
<tr><td>8</td><td><a href="tips/TIP-0008/tip-0008.html">Milestone Payload</a></td><td>Coordinator issued milestone structure with Ed25519 authentication</td><td>Standards</td><td>Core</td><td>Replaced by TIP-29</td><td>Chrysalis</td></tr>
<tr><td>9</td><td><a href="tips/TIP-0009/tip-0009.html">Local Snapshot File Format</a></td><td>File format to export/import ledger state</td><td>Standards</td><td>Interface</td><td>Replaced by TIP-35</td><td>Chrysalis</td></tr>
<tr><td>10</td><td><a href="tips/TIP-0010/tip-0010.html">Mnemonic Ternary Seed</a></td><td>Represent ternary seed as a mnemonic sentence</td><td>Standards</td><td>IRC</td><td>Obsolete</td><td>Legacy IOTA</td></tr>
<tr><td>11</td><td><a href="tips/TIP-0011/tip-0011.html">Bech32 Address Format</a></td><td>Extendable address format supporting various signature schemes and address types</td><td>Standards</td><td>Interface</td><td>Replaced by TIP-31</td><td>Chrysalis</td></tr>
<tr><td>12</td><td><a href="tips/TIP-0012/tip-0012.html">Message PoW</a></td><td>Define message proof-of-work as a means to rate-limit the network</td><td>Standards</td><td>Core</td><td>Active</td><td>Chrysalis</td></tr>
<tr><td>13</td><td><a href="tips/TIP-0013/tip-0013.html">REST API</a></td><td>Node REST API routes and objects in OpenAPI Specification</td><td>Standards</td><td>Interface</td><td>Replaced by TIP-25</td><td>Chrysalis</td></tr>
<tr><td>14</td><td><a href="tips/TIP-0014/tip-0014.html">Ed25519 Validation</a></td><td>Adopt <a href="https://zips.z.cash/zip-0215">ZIP-215</a> to explicitly define Ed25519 validation criteria</td><td>Standards</td><td>Core</td><td>Active</td><td>Chrysalis</td></tr>
<tr><td>15</td><td><a href="tips/TIP-0015/tip-0015.html">Dust Protection</a></td><td>Prevent bloating the ledger size with to dust outputs</td><td>Standards</td><td>Core</td><td>Replaced by TIP-19</td><td>Chrysalis</td></tr>
<tr><td>16</td><td><a href="tips/TIP-0016/tip-0016.html">Event API</a></td><td>Node event API definitions in AsyncAPI Specification</td><td>Standards</td><td>Interface</td><td>Replaced by TIP-28</td><td>Chrysalis</td></tr>
<tr><td>17</td><td><a href="tips/TIP-0017/tip-0017.html">Wotsicide</a></td><td>Define migration from legacy WOTS addresses to post-Chrysalis Phase 2 network</td><td>Standards</td><td>Core</td><td>Obsolete</td><td>Chrysalis</td></tr>
<tr><td>18</td><td><a href="tips/TIP-0018/tip-0018.html">Multi-Asset Ledger and ISC Support</a></td><td>Transform IOTA into a multi-asset ledger that supports running IOTA Smart Contracts</td><td>Standards</td><td>Core</td><td>Active</td><td><strong>Stardust</strong></td></tr>
<tr><td>19</td><td><a href="tips/TIP-0019/tip-0019.html">Dust Protection Based on Byte Costs</a></td><td>Prevent bloating the ledger size with dust outputs</td><td>Standards</td><td>Core</td><td>Active</td><td><strong>Stardust</strong></td></tr>
<tr><td>20</td><td><a href="tips/TIP-0020/tip-0020.html">Transaction Payload with New Output Types</a></td><td>UTXO-based transaction structure with TIP-18</td><td>Standards</td><td>Core</td><td>Active</td><td><strong>Stardust</strong></td></tr>
<tr><td>21</td><td><a href="tips/TIP-0021/tip-0021.html">Serialization Primitives</a></td><td>Introduce primitives to describe the binary serialization of objects</td><td>Standards</td><td>Core</td><td>Active</td><td><strong>Stardust</strong></td></tr>
<tr><td>22</td><td><a href="tips/TIP-0022/tip-0022.html">IOTA Protocol Parameters</a></td><td>Describes the global protocol parameters for the IOTA protocol</td><td>Standards</td><td>Core</td><td>Active</td><td><strong>Stardust</strong></td></tr>
<tr><td>23</td><td><a href="tips/TIP-0023/tip-0023.html">Tagged Data Payload</a></td><td>Payload for arbitrary data</td><td>Standards</td><td>Core</td><td>Active</td><td><strong>Stardust</strong></td></tr>
<tr><td>24</td><td><a href="tips/TIP-0024/tip-0024.html">Tangle Block</a></td><td>A new version of TIP-6 that renames messages to blocks and removes the Indexation Payload in favor of the Tagged Data Payload. Replaces TIP-6.</td><td>Standards</td><td>Core</td><td>Active</td><td><strong>Stardust</strong></td></tr>
<tr><td>25</td><td><a href="tips/TIP-0025/tip-0025.html">Core REST API</a></td><td>Node Core REST API routes and objects in OpenAPI Specification. Replaces TIP-13.</td><td>Standards</td><td>Interface</td><td>Active</td><td><strong>Stardust</strong></td></tr>
<tr><td>26</td><td><a href="tips/TIP-0026/tip-0026.html">UTXO Indexer REST API</a></td><td>UTXO Indexer REST API routes and objects in OpenAPI Specification.</td><td>Standards</td><td>Interface</td><td>Active</td><td><strong>Stardust</strong></td></tr>
<tr><td>27</td><td><a href="tips/TIP-0027/tip-0027.html">IOTA NFT standards</a></td><td>Define NFT metadata standard, collection system and creator royalties</td><td>Standards</td><td>IRC</td><td>Active</td><td><strong>Stardust</strong></td></tr>
<tr><td>28</td><td><a href="tips/TIP-0028/tip-0028.html">Node Event API</a></td><td>Node event API definitions in AsyncAPI Specification. Replaces TIP-16.</td><td>Standards</td><td>Interface</td><td>Active</td><td><strong>Stardust</strong></td></tr>
<tr><td>29</td><td><a href="tips/TIP-0029/tip-0029.html">Milestone Payload</a></td><td>Milestone Payload with keys removed from essence. Replaces TIP-8.</td><td>Standards</td><td>Core</td><td>Active</td><td><strong>Stardust</strong></td></tr>
<tr><td>30</td><td><a href="tips/TIP-0030/tip-0030.html">Native Token Metadata Standard</a></td><td>A JSON schema that describes token metadata format for native token foundries</td><td>Standards</td><td>IRC</td><td>Active</td><td><strong>Stardust</strong></td></tr>
<tr><td>31</td><td><a href="tips/TIP-0031/tip-0031.html">Bech32 Address Format for IOTA and Shimmer</a></td><td>Extendable address format supporting various signature schemes and address types. Replaces TIP-11.</td><td>Standards</td><td>Interface</td><td>Active</td><td><strong>Stardust</strong></td></tr>
<tr><td>32</td><td><a href="tips/TIP-0032/tip-0032.html">Shimmer Protocol Parameters</a></td><td>Describes the global protocol parameters for the Shimmer network</td><td>Standards</td><td>Core</td><td>Active</td><td><strong>Stardust</strong></td></tr>
<tr><td>33</td><td><a href="https://github.com/iotaledger/tips/pull/72">Public Token Registry</a></td><td>Defines an open public registry for NFT collection ID and native tokens metadata</td><td>Standards</td><td>IRC</td><td>Draft</td><td><strong>Stardust</strong></td></tr>
<tr><td>34</td><td><a href="tips/TIP-0034/tip-0034.html">Wotsicide (Stardust update)</a></td><td>Define migration from legacy W-OTS addresses to post-Chrysalis networks. Replaces TIP-17.</td><td>Standards</td><td>Core</td><td>Obsolete</td><td><strong>Stardust</strong></td></tr>
<tr><td>35</td><td><a href="tips/TIP-0035/tip-0035.html">Local Snapshot File Format (Stardust Update)</a></td><td>File format to export/import ledger state. Replaces TIP-9.</td><td>Standards</td><td>Interface</td><td>Active</td><td><strong>Stardust</strong></td></tr>
<tr><td>37</td><td><a href="https://github.com/iotaledger/tips/pull/81">Dynamic Proof-of-Work</a></td><td>Dynamically adapt the PoW difficulty</td><td>Standards</td><td>Core</td><td>Withdrawn</td><td><strong>Stardust</strong></td></tr>
</tbody></table>
</div>
<h2 id="need-help"><a class="header" href="#need-help">Need help?</a></h2>
<p>If you want to get involved in the community, need help getting started, have any issues related to the repository or just want to discuss blockchain, distributed ledgers, and IoT with other people, feel free to join our <a href="https://discord.iota.org/">Discord</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><pre>
tip: 1
title: TIP Process
description:  Purpose and guidelines of the contribution framework
author: Levente Pap (@lzpap) <levente.pap@iota.org>
discussions-to: https://github.com/iotaledger/tips/discussions
status: Active
type: Process
created: 2021-12-15
</pre>
<h2 id="abstract"><a class="header" href="#abstract">Abstract</a></h2>
<p>A Tangle Improvement Proposal (TIP) is a design document providing information to the IOTA community, or describing a new feature for IOTA or its processes or environment. The TIP should provide a concise technical specification of the feature and a rationale for the feature.</p>
<p>TIPs are the primary mechanism for proposing new features and standards to the IOTA protocol and related applications, furthermore for collecting input from the wider community and documenting the design decisions that go into the IOTA technology.</p>
<p>TIPs are maintained as text files inside the repository, therefore the history and evolution of protocol features are transparent and well documented.</p>
<p>This TIP defines the TIP Process itself to establish a common way of working.</p>
<h2 id="motivation"><a class="header" href="#motivation">Motivation</a></h2>
<p>The motivation of this TIP is to create a public platform to discuss improvement ideas related to the IOTA technology and define an easy-to-follow process of contributing to their development and implementation.</p>
<h2 id="specification"><a class="header" href="#specification">Specification</a></h2>
<h3 id="tip-types"><a class="header" href="#tip-types">TIP Types</a></h3>
<p>There are 3 types of TIPs:</p>
<ul>
<li>A <strong>Standards Track TIP</strong> describes any change that affects most or all IOTA node implementations, such as a change to the network protocol, a change in transaction validity rules, or any change or addition that affects the interoperability of applications using IOTA. Standards Track TIPs consist of two parts, a design document and a reference implementation. Standards Track TIPs can be broken down into layers:
<ul>
<li><strong>Core</strong>: includes improvements requiring a consensus fork (e.g. new transaction validation rules, change in protocol message layouts), as well as any change that concerns the protocol specification.</li>
<li><strong>Networking</strong>: includes improvements around the networking layer of the network, e.g. gossip protocol or autopeering.</li>
<li><strong>Interface</strong>: includes improvements around the client APIs of base layer nodes as well as around the interface definitions of IOTA Smart Contracts (ISC), such as contract schemas or ISC node APIs.</li>
<li><strong>IRC</strong>: includes improvements around application-level standards and conventions such as contract standards, token standards or metadata format standards.</li>
</ul>
</li>
<li>An <strong>Informational TIP</strong> describes an IOTA design issue, or provides general guidelines or information to the IOTA community, but does not propose a new feature. Informational TIPs do not necessarily represent an IOTA community consensus or recommendation, so users and implementors are free to ignore Informational TIPs or follow their advice.</li>
<li>A <strong>Process TIP</strong> describes a process surrounding IOTA, or proposes a change to (or an event in) a process. Process TIPs are like Standards Track TIPs but apply to areas other than the IOTA protocol itself. They may propose an implementation, but not to IOTA's codebase; they often require community consensus; unlike Informational TIPs, they are more than recommendations, and users are typically not free to ignore them. Examples include procedures, guidelines, changes to the decision-making process, and changes to the tools or environment used in IOTA development.</li>
</ul>
<p>It is highly recommended that a TIP outlines a single key proposal, idea or feature; the narrower the scope of the TIP is, the easier it becomes to reach consensus on the proposed feature and incorporate it into the protocol. Several TIPs can form a bundle of changes when linked to each other.</p>
<h3 id="tip-format-and-structure"><a class="header" href="#tip-format-and-structure">TIP Format and Structure</a></h3>
<p>TIPs must adhere to the format and structure requirements that are outlined in this document. A TIP is written in <a href="https://docs.github.com/en/github/writing-on-github/getting-started-with-writing-and-formatting-on-github/basic-writing-and-formatting-syntax">Markdown</a> format and should have the following parts (optional parts are marked with a *):</p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Description</th></tr></thead><tbody>
<tr><td>Preamble</td><td><a href="https://www.ietf.org/rfc/rfc822.txt">RFC 822</a> style headers containing metadata about the TIP, including the TIP number, a short descriptive title (limited to a maximum of 44 characters), a description (limited to a maximum of 140 characters), and the author details. Irrespective of the category, the title and description should not include TIP number. <a href="tips/TIP-0001/tip-0001.html#tip-header-preamble">See below</a> for details.</td></tr>
<tr><td>Abstract</td><td>A short summary of the technical issue being addressed by the TIP.</td></tr>
<tr><td>Motivation</td><td>A motivation section is critical for TIPs that want to change the IOTA protocol. It should clearly explain why the existing protocol specification is inadequate to address the problem that the TIP solves. TIP submissions without sufficient motivation may be rejected outright.</td></tr>
<tr><td>Specification</td><td>The technical specification should describe the syntax and semantics of any new feature. The specification should be detailed enough to allow competing, interoperable implementations for any of the current IOTA platforms.</td></tr>
<tr><td>Rationale</td><td>The rationale fleshes out the specification by describing what motivated the design and why particular design decisions were made. It should describe alternate designs that were considered and related work, e.g. how the feature is supported in other languages. The rationale may also provide evidence of consensus within the community, and should discuss important objections or concerns raised during discussion.</td></tr>
<tr><td>Backwards Compatibility*</td><td>All TIPs that introduce backwards incompatibilities must include a section describing these incompatibilities and their severity. The TIP must explain how the author proposes to deal with these incompatibilities. TIP submissions without a sufficient backwards compatibility treatise may be rejected outright.</td></tr>
<tr><td>Test Cases*</td><td>Test cases for an implementation are mandatory for TIPs that are affecting consensus changes. Tests should either be inlined in the TIP as data or placed in the TIP folder.</td></tr>
<tr><td>Reference Implementation*</td><td>An optional section that contains a reference/example implementation that people can use to assist in understanding or implementing this specification.</td></tr>
<tr><td>Copyright</td><td>All TIPs must be in the public domain. See the bottom of this TIP for an example copyright waiver.</td></tr>
</tbody></table>
</div>
<h3 id="tip-template"><a class="header" href="#tip-template">TIP Template</a></h3>
<p>The template to follow for new TIPs is located in the <a href="https://github.com/iotaledger/tips/blob/main/tip-template.md">repository</a>.</p>
<h3 id="tip-process"><a class="header" href="#tip-process">TIP Process</a></h3>
<p>Parties involved in the process are:</p>
<ul>
<li><em>TIP author</em>: you, the champion who proposes a new TIP. It is the responsibility of the <em>TIP author</em> to drive the progression of the TIP to <code>Active</code> status. This includes initiating public discussion and implementing the proposal as well.</li>
<li><em>TIP editor</em>: they deal with administering the TIP process and ensure process requirements are fulfilled.</li>
<li><em>Technical Committee</em>: technical experts of IOTA who evaluate new TIPs, provide feedback and ensure that only sound and secure features are added to the protocol.</li>
</ul>
<h4 id="tip-statuses"><a class="header" href="#tip-statuses">TIP Statuses</a></h4>
<p>The status of the TIP describes its current stage in the TIP process.</p>
<div class="table-wrapper"><table><thead><tr><th>Status</th><th>Description</th></tr></thead><tbody>
<tr><td>Idea</td><td>An idea for an improvement to the IOTA technology. Not yet tracked as an official TIP.</td></tr>
<tr><td>Draft</td><td>The idea has been formally accepted in the repository, and is being worked on by its authors.</td></tr>
<tr><td>Proposed</td><td>The TIP has a working implementation and has clear plans on how to progress to <code>Active</code> status.</td></tr>
<tr><td>Active</td><td>The TIP is deployed to the main network or some TIP specific adoption criteria has been met.</td></tr>
<tr><td>Deferred</td><td>The <em>TIP author(s)</em> are not working on the TIP currently, but plan to continue in the future. TIP is on hold.</td></tr>
<tr><td>Rejected</td><td>The TIP is rejected.</td></tr>
<tr><td>Withdrawn</td><td>The TIP has been withdrawn by the <em>TIP author(s)</em>.</td></tr>
<tr><td>Replaced</td><td>The TIP is replaced by a newer TIP. Must point to the new TIP in the header.</td></tr>
<tr><td>Obsolete</td><td>The TIP is rendered obsolete by some future change.</td></tr>
</tbody></table>
</div>
<h4 id="tip-workflow"><a class="header" href="#tip-workflow">TIP Workflow</a></h4>
<p><em>How are new proposal get added to the protocol?</em></p>
<ol>
<li>
<p>All TIPs begin life as an <code>Idea</code> proposed in the public <a href="https://github.com/iotaledger/tips/discussions">IOTA discussion forum, that is the GitHub Discussion page of the TIP repository</a>. A public, open discussion should predate any formal TIP submission. If you want to propel your proposal to acceptance, you should make sure to build consensus and support in the community around your proposed changes already in the idea stage.</p>
</li>
<li>
<p>Once the idea has been vetted, your next task is to submit a <code>Draft</code> TIP to the TIP repository as a pull request. Do not assign a TIP number yet to the draft, but make sure that the proposal is technically sound and follows the format and style guides of the TIP Process. Create a sub-folder under <code>tips</code> folder with the title of the draft (<code>tips/title_of_draft/</code>) and put all assets in this folder.</p>
</li>
<li>
<p>A <em>TIP editor</em> reviews your PR and assigns a TIP number to the draft.</p>
</li>
<li>
<p>The <em>Technical Committee</em> as well as the broader public evaluate the draft proposal and might ask for modifications or clarifications. The proposal can only be merged into the repository as a draft if it represents a net improvement and does not complicate the protocol unduly.</p>
</li>
<li>
<p>The TIP is merged into the repo with <code>Draft</code> status by <em>TIP editor/author</em>.</p>
</li>
<li>
<p>When a working implementation is presented and there are clear plans on how to progress the TIP to  completion, the <em>TIP author</em> submits a subsequent PR that links its implementation to the TIP and progresses it to <code>Proposed</code> stage. The TIP is ready to be deployed on testnet.</p>
</li>
<li>
<p>When a <code>Proposed</code> TIP is deemed to have met all appropriate criteria and its implementation has been demonstrated to work reliably in testnet environment, it is ready to be moved to the main network. Upon deployment, the TIP status must change to <code>Active</code>.</p>
</li>
</ol>
<p><em>How can a TIP transition from one status to another?</em></p>
<p><img src="tips/TIP-0001/./process.svg" alt="image" /></p>
<p>A <code>Draft</code> TIP might be moved to <code>Deferred</code> status by the <em>TIP author(s)</em> when they are no longer working on the proposal, but plan to continue it in the future.</p>
<p>A <code>Draft</code> TIP might be moved to <code>Withdrawn</code> status by the <em>TIP author(s)</em>.</p>
<p>A <code>Draft</code> TIP might be moved to <code>Rejected</code> status by <em>TIP editor(s)</em> or <em>Technical Committee</em> if it does not meet the appropriate TIP criteria, or no relevant progress has been demonstrated on the TIP for at least 3 years.</p>
<p>A <code>Draft</code> TIP might be moved to <code>Proposed</code> status by TIP author(s) if it is considered complete, has a working implementation and clear plans on how to progress it to <code>Active</code> status.</p>
<p>A <code>Proposed</code> TIP might be moved to <code>Active</code> status if a TIP specific adoption criteria has been met. For Core TIPs this means deployment on the main network.</p>
<p>A <code>Proposed</code> TIP might be moved to <code>Rejected</code> status by <em>TIP editor(s)</em> or <em>Technical Committee</em> if its implementation puts unduly burden and complexity on the protocol, or other significant problems are discovered during testing.</p>
<p>An <code>Active</code> TIP might be moved to <code>Replaced</code> status by a newer TIP. The replaced TIP must point to the TIP that replaces it.</p>
<p>An <code>Active</code> TIP might be moved to <code>Obsolete</code> status when the feature is deprecated.</p>
<p><em>How to champion the TIP Process as a TIP author?</em></p>
<ul>
<li>Browse the <a href="https://github.com/iotaledger/tips/discussions">idea discussion forum</a> before posting a new TIP idea. Someone else might already have proposed your idea, or a similar one. Take inspiration from previous ideas and discussions.</li>
<li>It is your responsibility as a <em>TIP author</em> to build community consensus around your idea. Involve as many people in the discussion as you can. Use social media platforms, Discord or Reddit to raise awareness of your idea.</li>
<li>Submit a draft TIP as a PR to the TIP repository. Put extra care into following TIP guidelines and formats. TIPs must contain a link to previous discussions on the topic, otherwise your submissions might be rejected. TIPs that do not present convincing motivation, demonstrate lack of understanding of the design's impact, or are disingenuous about the drawbacks or alternatives tend to be poorly-received.</li>
<li>Your draft TIP gets a TIP number assigned by a <em>TIP editor</em> and receives review and feedback from the larger community as well as from the <em>Technical Committee</em>. Be prepared to revise your draft based on this input.</li>
<li>TIPs that have broad support are much more likely to make progress than those that don't receive any comments. Feel free to reach out to the <em>TIP editors</em> in particular to get help to identify stakeholders and obstacles.</li>
<li>Submitted draft TIPs rarely go through the process unchanged, especially as alternatives and drawbacks are shown. You can make edits, big and small, to the draft TIP to clarify or change the design, but make changes as new commits to the pull request, and leave a comment on the pull request explaining your changes. Specifically, do not squash or rebase commits after they are visible on the pull request.</li>
<li>When your draft TIP PR gets enough approvals from <em>TIP editors</em> and <em>Technical Committee</em> members, it can be merged into the repository, however, your job is far from complete! To move the draft into the next status (proposed), you have to demonstrate a working implementation of your TIP. For Core TIPs, seek help from protocol developers and/or client teams to coordinate the feature implementation. For IRCs for example you need to provide their implementation yourself.</li>
<li>You also need to present a clear plan on how the TIP will be moved to the <code>Active</code> status, by for example agreeing on a TIP deployment strategy with the <em>Technical Committee</em> or core developers.</li>
<li>To move your <code>Draft</code> TIP to the <code>Proposed</code> phase, submit a subsequent PR that links its implementation and devises its route to become <code>Active</code>. The latter might be an additional document in the TIP's folder, a link to a public discussion or a short description or comment on the PR itself.</li>
<li>To move your <code>Proposed</code> TIP to <code>Active</code> status you need to demonstrate that it has met its specific adoption criteria. For Core TIPs, this means that majority of network nodes support it. For other TIPs, especially for IRCs, adoption might mean that the standard is publicly available, well documented and there are applications building on it.</li>
</ul>
<h3 id="tip-header-preamble"><a class="header" href="#tip-header-preamble">TIP Header Preamble</a></h3>
<p>Each TIPs must have an RFC 822 style header preamble preceded and followed by three hyphens (---). The headers must appear in the following order. Headers marked with &quot;*&quot; are optional and are described below. All other headers are required.</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody>
<tr><td><code>tip</code></td><td>TIP number, or &quot;?&quot; before being assigned (assigned by <em>TIP editor</em>)</td></tr>
<tr><td><code>title</code></td><td>Few words describing the TIP, maximum 44 characters</td></tr>
<tr><td><code>description*</code></td><td>One full short sentence</td></tr>
<tr><td><code>author</code></td><td>A comma separated list of the author's or authors' name + GitHub username (in parenthesis), or name and email (in angle brackets). Example, FirstName LastName (@GitHubUsername), FirstName LastName <a href="mailto:tips/TIP-0001/foo@bar.com">foo@bar.com</a>, FirstName (@GitHubUsername) and GitHubUsername (@GitHubUsername)</td></tr>
<tr><td><code>discussions-to*</code></td><td>The url pointing to the official discussion thread</td></tr>
<tr><td><code>status</code></td><td>Current status of the TIP. One of: <code>Draft</code>, <code>Proposed</code>, <code>Active</code>, <code>Deferred</code>, <code>Rejected</code>, <code>Withdrawn</code>, <code>Obsolete</code> or <code>Replaced</code></td></tr>
<tr><td><code>type</code></td><td>TIP type, one of: <code>Standards Track</code>, <code>Process</code> or <code>Informational</code></td></tr>
<tr><td><code>layer*</code></td><td>Only for Standards Track, defines layer: <code>Core</code>, <code>Networking</code>, <code>Interface</code> or <code>IRC</code></td></tr>
<tr><td><code>created</code></td><td>Date created on, in ISO 8601 (yyyy-mm-dd) format</td></tr>
<tr><td><code>requires*</code></td><td>Link dependent TIPs by number</td></tr>
<tr><td><code>replaces*</code></td><td>Older TIP being replaced by this TIP</td></tr>
<tr><td><code>superseded-by*</code></td><td>Newer TIP replaces this TIP</td></tr>
<tr><td><code>withdrawal-reason*</code></td><td>A sentence explaining why the TIP was withdrawn. (Optional field, only needed when status is <code>Withdrawn</code>)</td></tr>
<tr><td><code>rejection-reason*</code></td><td>A sentence explaining why the TIP was rejected. (Optional field, only needed when status is <code>Rejected</code>)</td></tr>
</tbody></table>
</div>
<h3 id="linking-tips"><a class="header" href="#linking-tips">Linking TIPs</a></h3>
<p>References to other TIPs should follow the format TIP-N where N is the TIP number you are referring to. Each TIP that is referenced in an TIP MUST be accompanied by a relative Markdown link the first time it is referenced, and MAY be accompanied by a link on subsequent references. The link MUST always be done via relative paths so that the links work in this GitHub repository or forks of this repository. For example, you would link to this TIP with <code>[TIP-1](../TIP-0001/tip-0001.md)</code>.</p>
<h3 id="auxiliary-files"><a class="header" href="#auxiliary-files">Auxiliary Files</a></h3>
<p>Images, diagrams and auxiliary files should be included in the subdirectory of the TIP.  When linking to an image in the TIP, use relative links such as <code>[TIP Process Diagram](../TIP-0001/process.png)</code>.</p>
<h3 id="transferring-tip-ownership"><a class="header" href="#transferring-tip-ownership">Transferring TIP Ownership</a></h3>
<p>It occasionally becomes necessary to transfer ownership of TIPs to a new champion. In general, we'd like to retain the original author as a co-author of the transferred TIP, but that's really up to the original author. A good reason to transfer ownership is because the original author no longer has the time or interest in updating it or following through with the TIP process, or has fallen off the face of the 'net (i.e. is unreachable or isn't responding to email). A bad reason to transfer ownership is because you don't agree with the direction of the TIP. We try to build consensus around a TIP, but if that's not possible, you can always submit a competing TIP.</p>
<p>If you are interested in assuming ownership of a TIP, send a message asking to take over, addressed to both the original author and the <em>TIP editors</em>. If the original author doesn't respond to the email in a timely manner, the <em>TIP editors</em> will make a unilateral decision (it's not like such decisions can't be reversed :)).</p>
<h3 id="tip-editors"><a class="header" href="#tip-editors">TIP Editors</a></h3>
<p>The current TIP editors are:</p>
<ul>
<li>Kumar Anirudha (@anistark, kumar.anirudha@iota.org)</li>
<li>Levente Pap (@lzpap, levente.pap@iota.org)</li>
</ul>
<h3 id="tip-editor-responsibilities"><a class="header" href="#tip-editor-responsibilities">TIP Editor Responsibilities</a></h3>
<p>TIP editors' essential role is to assist and guard the process of contributing to the IOTA ecosystem, provide help and directions to community members as well as to external contributors. If you have a question regarding the TIP process, reach out to them, they will point you to the right direction.</p>
<p>They ensure that only quality contributions are added as TIPs, provide support for TIP authors, furthermore monitor that the TIP process is fair, objective and well documented.</p>
<p>For each new TIP that comes in, an editor does the following:</p>
<ul>
<li>Read the TIP to check if it is ready: sound and complete. The ideas must make technical sense, even if they don't seem likely to get to <code>Active</code> status.</li>
<li>The title should accurately describe the content.</li>
<li>Check the TIP for language (spelling, grammar, sentence structure, etc.), markup (GitHub flavored Markdown), code style.</li>
</ul>
<p>If the TIP isn't ready, the editor will send it back to the author for revision, with specific instructions.</p>
<p>Once the TIP is ready to be merged as a draft, the editor will:</p>
<ul>
<li>Assign a TIP number that does not conflict with other TIP numbers. It might be the PR number, but might also be selected as the next unused TIP number in line.</li>
<li>Merge the corresponding pull request.</li>
<li>Send a message back to the TIP author with the next step.</li>
</ul>
<p>The editors don't pass judgment on TIPs. We merely do the administrative &amp; editorial part.</p>
<h3 id="technical-committee"><a class="header" href="#technical-committee">Technical Committee</a></h3>
<p>The <em>Technical Committee</em> consists of several core contributors of the IOTA ecosystem and core developers. Their job is to evaluate technical details of TIPs, judge their technical feasibility and safeguard the evolution of the protocol. Core improvement ideas must be carefully thought through and their benefits must outweigh their drawbacks.</p>
<p>In order for a draft TIP to be accepted into the repo, it must be signed-off by the <em>Technical Committee</em>. It is also the committee that gives the green light for drafts to become proposed or active.</p>
<h2 id="rationale"><a class="header" href="#rationale">Rationale</a></h2>
<p>The TIP process is intended to replace the formerly adopted RFC process to achieve:</p>
<ul>
<li>Simpler workflow and less rigid process structure,</li>
<li>Broader platform for ideation and early phase improvement discussions,</li>
<li>A layered protocol specification approach that can describe not only core components, but also higher layer protocols and application-level conventions.</li>
</ul>
<p>In order not to reinvent the wheel, the TIP Process draws heavily on the <a href="https://github.com/bitcoin/bips/blob/master/bip-0002.mediawiki">BIP</a> and <a href="https://github.com/ethereum/EIPs/blob/master/EIPS/eip-1.md">EIP</a> processes.</p>
<h2 id="backwards-compatibility"><a class="header" href="#backwards-compatibility">Backwards Compatibility</a></h2>
<ul>
<li>The current <code>iotaledger/protocol-rfcs</code> repository will be renamed to <code>iotaledger/tips</code>.</li>
<li>Merged RFCs will receive a TIP number and header with <code>Active</code> status.</li>
<li>PRs in the repo will be mapped as <code>Draft</code> TIPs, either modifications to existing TIPs or new ones.</li>
<li>The GitHub Discussion page of the repository will be restructured to accommodate TIP idea discussions.</li>
</ul>
<h2 id="references"><a class="header" href="#references">References</a></h2>
<ul>
<li><a href="https://github.com/bitcoin/bips/blob/master/bip-0001.mediawiki">BIP-1</a> and<a href="https://github.com/bitcoin/bips/blob/master/bip-0002.mediawiki"> BIP-2</a>, Bitcoin Improvement Proposal Purpose and Guidelines</li>
<li><a href="https://github.com/ethereum/EIPs/blob/master/EIPS/eip-1.md">EIP-1</a>, Ethereum Improvement Proposal Purpose and Guidelines</li>
<li><a href="https://github.com/cardano-foundation/CIPs/tree/master/CIP-0001">CIP-1</a>, Cardano Improvement Proposal Process</li>
</ul>
<h2 id="copyright"><a class="header" href="#copyright">Copyright</a></h2>
<p>Copyright and related rights waived via <a href="https://creativecommons.org/publicdomain/zero/1.0/">CC0</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><pre>
tip: 2
title: White Flag Ordering
description: Mitigate conflict spamming by ignoring conflicts
author: Thibault Martinez (@thibault-martinez) <thibault@iota.org>
discussions-to: https://github.com/iotaledger/tips/pull/5, https://github.com/iotaledger/tips/pull/30
status: Active
type: Standards
layer: Core
created: 2020-03-06
</pre>
<h1 id="summary"><a class="header" href="#summary">Summary</a></h1>
<p>This RFC is part of a set of protocol changes, <a href="https://roadmap.iota.org/chrysalis">Chrysalis</a>, aiming at improving the
network before <a href="https://coordicide.iota.org/">Coordicide</a> is complete.</p>
<p>The feature presented in this RFC, White Flag, allows milestones to confirm conflicting messages by enforcing
deterministic ordering of the Tangle and applying only the first message(s) that will not violate the ledger state.</p>
<p>The content of this RFC is based on <a href="https://iota.cafe/t/conflict-white-flag-mitigate-conflict-spamming-by-ignoring-conflicts/233">Conflict white flag: Mitigate conflict spamming by ignoring conflicts</a>.</p>
<h1 id="motivation-1"><a class="header" href="#motivation-1">Motivation</a></h1>
<ul>
<li>Eliminates the <a href="https://iota.cafe/t/conflict-spamming-attack/232">Conflict spamming attack</a>;</li>
<li>As conflicts are ignored in the balance computation, they do not need to be considered during tip selection of the
nodes allowing much easier tip selection algorithms leading to increased TPS;</li>
<li>By using this approach in combination with an appropriate TSA, during regular use, no honest message will ever
require re-attaching leading to increased CTPS;</li>
<li>Does not come with added computation complexity by integrating nicely into already existing algorithms;</li>
</ul>
<h1 id="detailed-design"><a class="header" href="#detailed-design">Detailed design</a></h1>
<p>First, let us define what it means for a message A to be:</p>
<ul>
<li>referenced (indirectly or directly) by message B: A is contained in the past cone of B;</li>
<li>confirmed: A is referenced by a milestone;</li>
<li>applied: A is confirmed and applied to the ledger state;</li>
<li>ignored: A is confirmed but not applied because it is semantically invalid;</li>
<li>conflicting: A would lead to an invalid ledger state if applied;</li>
</ul>
<p>In case of conflicting messages with White Flag, a node applies only one message to the ledger state and ignores
all the others. For this to work, all the nodes need to be sure they are all applying the same message; hence, the
need for a deterministic ordering of the Tangle.</p>
<p>First, this RFC proposes a deterministic ordering of the Tangle, then it explains which message is selected in case
of conflicts.</p>
<p><strong>Note: The past-cone of milestone can only contain syntactically valid messages. If an invalid message is encountered,
operations must be stopped immediately.</strong></p>
<h2 id="deterministically-ordering-the-tangle"><a class="header" href="#deterministically-ordering-the-tangle">Deterministically ordering the Tangle</a></h2>
<p>When a new milestone is broadcasted to the network, nodes will need to order the set of messages it confirms.</p>
<p>A subset of the Tangle can be ordered depending on many of its properties (e.g. alphanumeric sort of the message
hashes); however, to compute the ledger state, a graph traversal has to be done so it can be used to order the messages
in a deterministic order with no extra overhead.</p>
<p>This ordering is then defined as a <a href="https://en.wikipedia.org/wiki/Topological_sorting">topological ordering</a> because
it respects the dependency of messages, ensuring that parents of a message are applied before it.
Since there are multiple valid topological orders for the same graph and, to avoid conflicting ledger states, it
is required that all nodes apply messages in the exact same order.</p>
<p>For this reason, this RFC proposes an order that has to be rigorously followed by all node implementations.
This order is the topological ordering generated by a post-order <a href="https://en.wikipedia.org/wiki/Depth-first_search">Depth-First Search (DFS)</a>
starting from a milestone message, going through its parents (in the order they appear in the message) and finally
analysing the current message. Since only a subset of messages is considered, the stopping condition of this DFS is
reaching messages that are already confirmed by another milestone.</p>
<h2 id="applying-first-messages-that-does-not-violate-the-ledger-state"><a class="header" href="#applying-first-messages-that-does-not-violate-the-ledger-state">Applying first message(s) that does not violate the ledger state</a></h2>
<p>If a conflict is occurring in the set of messages confirmed by a milestone, nodes have to apply the first - with regards
to the order previously proposed - of the conflicting messages to the ledger and ignore all the others.</p>
<p>Once a message is marked as ignored, this is final and cannot be changed by a later milestone.</p>
<p>Since the ledger state is maintained from one milestone to another, a message conflicting with a message already
confirmed by a previous milestone would also be ignored.</p>
<h2 id="pseudo-code"><a class="header" href="#pseudo-code">Pseudo-code</a></h2>
<p>The following algorithm describes the process of updating the ledger state which is usually triggered by the arrival of
a new milestone confirming many new messages.</p>
<p>Pseudo-code means that implementation details such as types, parameters, ..., are not important but that the logic has
to be followed with care when implementing a node to avoid differences in the ledger state.</p>
<pre><code>update_ledger_state(ledger, milestone, solid_entry_points) {
    s = new Stack()
    visited = new Set()

    s.push(milestone)

    while (!s.is_empty()) {
        curr = s.peek()
        next = null

        // Look for the first eligible parent that was not already visited
        for parent in curr.parents {
          if (!solid_entry_points.contains(parent) &amp;&amp; !parent.confirmed &amp;&amp; !visited.contains(parent)) {
            next = parent
            break
          }
        }

        // All parents have been visited, apply and visit the current message
        if next == null {
          ledger.apply(curr)
          visited.add(curr)
          s.pop()
        }
        // Otherwise, go to the parent
        else {
          s.push(next)
        }
    }
}
</code></pre>
<p><strong>Notes</strong>:</p>
<ul>
<li><code>solid_entry_points</code> is a set of hashes that are considered solid even though we do not have them or their past in
a database. They often come from a snapshot file and allow a node to solidify without needing the full tangle history.
The hash of the genesis message is also a solid entry point.</li>
<li><code>confirmation_index</code> is the index of the milestone that confirmed the message.</li>
</ul>
<h3 id="example"><a class="header" href="#example">Example</a></h3>
<p>In this example, there are 26 messages labeled from <code>A</code> to <code>Z</code>.
The set of red messages <code>{A, B, C, E, F, H}</code> is confirmed by milestone <code>H</code>.
The set of purple messages <code>{D, G, J, L, M, N, K, I, O, S, R, V}</code> is confirmed by milestone <code>V</code>.
The set of blue messages <code>{Q, U, X, Y, Z, W, T, P}</code> is confirmed by another milestone.</p>
<p><img src="tips/TIP-0002/tangle.svg" alt="" /></p>
<p>Applying the previously shown algorithm on the purple set produces the topological order
<code>{D, G, J, L, M, R, I, K, N O, S, V}</code>.</p>
<p><img src="tips/TIP-0002/tangle-conflict.svg" alt="" /></p>
<p>Here, message <code>G</code> and message <code>O</code>, both confirmed by milestone <code>V</code>, are conflicting. Since in the topological order just
produced, <code>G</code> appears before <code>O</code>, <code>G</code> is applied to the ledger and <code>O</code> is ignored.</p>
<h1 id="drawbacks"><a class="header" href="#drawbacks">Drawbacks</a></h1>
<ul>
<li>The ledger state is now only well-defined at milestones, meaning that we have to wait until each milestone is
issued in order to confirm a spend;</li>
<li>Everything that is seen is now part of the Tangle, including double-spend attempts, meaning that malicious data will
now be saved as part of the consensus set of the Tangle;</li>
<li>To prove that a specific (non-milestone) message is valid, it is no longer sufficient to just provide the &quot;path&quot;
to its confirming milestone, but instead all messages in its past cone.</li>
</ul>
<h1 id="rationale-and-alternatives"><a class="header" href="#rationale-and-alternatives">Rationale and alternatives</a></h1>
<p>The main alternative to White Flag is what has been done so far i.e. not allowing conflicting messages confirmation.
As explained in this RFC, this comes with added complexity when performing a Tip Selection Algorithm because a node has
to constantly check for ledger inconsistencies.</p>
<p>As part of Chrysalis and coupled with an adequate Tip Selection Algorithm, White Flag is an improvement of the network
by allowing a potential increase of TPS/CTPS.</p>
<h1 id="unresolved-questions"><a class="header" href="#unresolved-questions">Unresolved questions</a></h1>
<p>A node consumes and produces snapshot files and bases the computation of its ledger state on them. In the current
network, if one of these files was tampered with and fed to a node, it would eventually lead to an invalid ledger state
where a message confirmed by a milestone would actually be a double spend. This situation would be detected by the node
and it would stop its activities as a security measure. However, with White Flag, such messages would be confirmed by
milestones but ignored by the node, the fake snapshot then going unnoticed. The ledger state would then become more and
more corrupted and the view of the balances completely wrong, errors just accumulating over time. The need for a
snapshot verification mechanism is then amplified by the implementation of White Flag. This mechanism being out of the
scope of this RFC, it will be described in another RFC.</p>
<h1 id="copyright-1"><a class="header" href="#copyright-1">Copyright</a></h1>
<p>Copyright and related rights waived via <a href="https://creativecommons.org/publicdomain/zero/1.0/">CC0</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><pre>
tip: 3
title: Uniform Random Tip Selection
description: Perform fast tip-selection to increase message throughput
author: Luca Moser (@luca-moser) <luca.moser@iota.org>
discussions-to: https://github.com/iotaledger/tips/pull/8
status: Active
type: Standards
layer: Core
created: 2020-03-09
</pre>
<h1 id="summary-1"><a class="header" href="#summary-1">Summary</a></h1>
<p>Weighted Uniform Random Tip Selection on a subset enables a node to perform fast tip-selection to increase message throughput.
The algorithm selects tips which are non-lazy to maximize confirmation rate.</p>
<h1 id="motivation-2"><a class="header" href="#motivation-2">Motivation</a></h1>
<p>Because of the <code>white-flag</code> confirmation algorithm, it is no longer necessary to perform complex
tip-selection which evaluates ledger mutations while walking. Therefore, a more simple, better 
performing algorithm can be used to select tips, which in turn increases overall message throughput.</p>
<p>To maximize confirmation rate however, the algorithm needs to return tips which are <code>non-lazy</code>.
Non-lazy in this context means that a tip does not attach to a cone of messages which is too far
in the past. Such a cone is likely to be already confirmed and does not contribute to the
rate of newly confirmed messages when a milestone is issued.</p>
<h1 id="detailed-design-1"><a class="header" href="#detailed-design-1">Detailed design</a></h1>
<p>Definitions:</p>
<ul>
<li><code>Direct Approvers</code> - The set of messages which directly approve a given message.</li>
<li><code>Approvee</code> - The directly approved message of a given message.</li>
<li><code>Solid Message</code> - A message that its past cone is known to the node.</li>
<li><code>Valid Message</code>- A message which is syntactically valid.</li>
<li><code>Tip</code> - A valid solid message that doesn't have approvers. Its past cone contains only valid messages.</li>
<li><code>Score</code> - An integer assigned to a <code>tip</code>. The tip selection algorithm uses it to determine how to select tips.</li>
<li><code>Confirmed Root Message</code> - The set of first seen messages which are confirmed by a previous milestone 
when we walk the past cone of a given message. The walk stops on a confirmed message.<br />
Note that the red marked milestone is also a <code>Confirmed Root Message</code>.
<img src="tips/TIP-0003/cnf_tx_roots.PNG" alt="sdf" /></li>
<li><code>Message Snapshot Index (MSI)</code> defines the index of the milestone which confirmed a given message.</li>
<li><code>Oldest Message Root Snapshot Index (OMRSI)</code> defines the lowest milestone index of a set of
<code>Confirmed Root Messages</code> of a given messages.</li>
<li><code>Youngest Message Root Snapshot Index (YMRSI)</code> defines the highest milestone index of a set of
<code>Confirmed Root Messages</code> of a given message.</li>
<li><code>Latest Solid Milestone Index (LSMI)</code> the index of the latest solid milestone.</li>
<li><code>Below Max Depth (BMD)</code> defines a threshold value up on which it is decided on whether a message is not
relevant in relation to the recent parts of the Tangle. The current <code>BMD</code> for mainnet nodes is 15 milestones, 
which means that messages of which their <code>OMRSI</code> in relation to the <code>LSMI</code> is more than 15, are &quot;below max depth&quot;.</li>
</ul>
<h3 id="omrsi--ymrsi-example"><a class="header" href="#omrsi--ymrsi-example">OMRSI / YMRSI example</a></h3>
<p>Given the blue PoV message, the <code>OMRSI</code> of it is milestone 1 and <code>YMRSI</code> milestone 2.
Note that, here again, the milestones are also <code>Confirmed Root Messages</code>.
<img src="tips/TIP-0003/otrsi_ytrsi.PNG" alt="sdf" /></p>
<h3 id="milestone-based-tip-scoring"><a class="header" href="#milestone-based-tip-scoring">Milestone based tip scoring</a></h3>
<p>The milestone based scoring defines a tip's score by investigating the tip's relation to
the cone it approves and previous issued  milestones.</p>
<p>A tip can have one of 3 score states:</p>
<ul>
<li><code>0</code>: The tip is lazy and should not be selected.</li>
<li><code>1</code>: The tip is somewhat lazy.</li>
<li><code>2</code>: The tip is a non-lazy tip.</li>
</ul>
<p>Definitions:</p>
<ul>
<li><code>C1</code>: Max allowed delta value for the <code>YMRSI</code> of a given message in relation to the current <code>LSMI</code>.</li>
<li><code>C2</code>: Max allowed delta value between <code>OMRSI</code> of a given message in relation to the current <code>LSMI</code>. </li>
<li><code>M</code>: Max allowed delta value between <code>OMRSI</code> of the given message in relation to the current <code>LSMI</code>.
<code>M</code> is the <code>below max depth (BMD)</code> parameter.</li>
</ul>
<p>Recommended defaults:</p>
<ul>
<li><code>C1</code> = 8 milestones</li>
<li><code>C2</code> = 13 milestones</li>
<li><code>M</code> = 15 milestones</li>
</ul>
<p>Scoring Algorithm (pseudo code):</p>
<pre><code>
enum Score (
    LAZY = 0
    SEMI_LAZY = 1
    NON_LAZY = 2
)

const (
    C1 = 8
    C2 = 13
    M = 15
)

func score(tip Tip) Score {
    
    // if the LSMI to YMRSI delta is over C1, then the tip is lazy
    if (LSMI - YMRSI(tip) &gt; C1) {
        return Score.LAZY
    }
    
    // if the OMRSI to LSMI delta is over M/below-max-depth, then the tip is lazy
    if (LSMI - OMRSI(tip) &gt; M) {
        return Score.LAZY
    }
    
    if (LSMI - OMRSI(tip) &gt; C2) {
        return Score.SEMI_LAZY
    }

    return Score.NON_LAZY
}
</code></pre>
<h3 id="random-tip-selection"><a class="header" href="#random-tip-selection">Random Tip-Selection</a></h3>
<p>A node should keep a set of non-lazy tips (score 2).
Every time a node is asked to select tips to be approved, it will pick randomly from the set. 
A node must not execute tip-selection if it is not synchronized.</p>
<p>A tip should not be removed from the tips set immediately after it was selected in <code>select()</code>,  to make it possible for it to be re-selected, which in turn makes the Tangle wider
and improves synchronization speed. A tip is removed from the tips set if <code>X</code> amount of direct
approvers are reached or if a certain amount of time <code>T</code> passed. 
It is recommended to use <code>X</code> = 2 and <code>T</code> = 3  but the threshold should be configurable.</p>
<h3 id="purpose-of-semi-lazy-tips"><a class="header" href="#purpose-of-semi-lazy-tips">Purpose Of Semi-Lazy Tips</a></h3>
<p>Semi-Lazy tips are not eligible for tip-selection, but the coordinator node may implement a tip selection algorithm
that confirms semi-lazy tips. Semi-lazy tips will usually be left behind, but parties interested in having them confirmed
are incentivized to run spammers that will actively reduce the amount of semi-lazy tips eligible for coordinator's tip selection. 
Given a coordinator that chooses semi-lazy tips, running such spammers may get those messages confirmed before
they become lazy.</p>
<h1 id="drawbacks-1"><a class="header" href="#drawbacks-1">Drawbacks</a></h1>
<p>Depending on when and how often <code>YMRSI</code>/<code>OMRSI</code> values are computed, this tip-selection could still
have a slow runtime, as one would need to constantly walk down the Tangle to compute those
values. However, smart caching might resolve this issue. </p>
<h1 id="rationale-and-alternatives-1"><a class="header" href="#rationale-and-alternatives-1">Rationale and alternatives</a></h1>
<p>The previous tip-selection was written in accordance to the original IOTA whitepaper, as it also
functioned as part of the consensus mechanism.
However, relatively soon it became apparent that the cumulative weight computation was too heavy
for an actual high throughput scenario and, as such, the CW calculation is currently not used within
node implementations at all.</p>
<p>Because confirmations with the <a href="tips/TIP-0003/../TIP-0002/tip-0002.html">white-flag</a> approach no longer approve cones only with state mutations,
which are consistent with a previous ledger state, it makes sense to alter the tip-selection to provide 
a fast way to get tips to approve with one's own message.
The only important thing is to disincentive lazy behaviour to be able to maximize confirmation rate.</p>
<h1 id="unresolved-questions-1"><a class="header" href="#unresolved-questions-1">Unresolved questions</a></h1>
<h4 id="when-to-compute-the-score-and-ymrsiomrsi-of-a-transaction"><a class="header" href="#when-to-compute-the-score-and-ymrsiomrsi-of-a-transaction">When to compute the score and <code>YMRSI</code>/<code>OMRSI</code> of a transaction?</a></h4>
<p>It is not yet clear when or how often the <code>YMRSI</code>/<code>OMRSI</code> values of a transaction should be updated.
If the values are only computed once after a transaction became solid, the <code>YMRSI</code>/<code>OMRSI</code> might not
resemble the true values, as subsequent milestones might confirm transactions within the same cone the
given transaction approved.</p>
<p>Currently, we suggest recomputing the values every time a new milestone solidifies. 
Since different tips indirectly reference the same transactions, this computation can be optimized.</p>
<h1 id="copyright-2"><a class="header" href="#copyright-2">Copyright</a></h1>
<p>Copyright and related rights waived via <a href="https://creativecommons.org/publicdomain/zero/1.0/">CC0</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><pre>
tip: 4
title: Milestone Merkle Validation
description: Add Merkle tree hash to milestone for local ledger state verification
author: Wolfgang Welz (@Wollac) <wolfgang.welz@iota.org>
discussions-to: https://github.com/iotaledger/tips/pull/12, https://github.com/iotaledger/tips/pull/31
status: Active
type: Standards
layer: Core
created: 2020-05-04
</pre>
<h1 id="summary-2"><a class="header" href="#summary-2">Summary</a></h1>
<p>In the IOTA protocol, nodes use the milestones issued by the Coordinator to reach a consensus on which transactions are confirmed. This RFC adds extra information to each milestone in the form of a Merkle tree hash, which allows nodes to explicitly validate their local view of the ledger state against the Coordinator's. This mechanism further enables a simple cryptographic proof of inclusion for transactions confirmed by the particular milestone.</p>
<h1 id="motivation-3"><a class="header" href="#motivation-3">Motivation</a></h1>
<p>With the changes proposed in the IOTA protocol <a href="tips/TIP-0004/../TIP-0002/tip-0002.html">TIP-2</a>, milestones are allowed to reference conflicting transactions. These conflicts are then resolved by traversing the newly confirmed transactions in a global, deterministic order and applying the corresponding ledger state changes in that order. Conflicts or invalid transactions are ignored, but stay in the Tangle.
This approach has considerable advantages in terms of network security (e.g. protection against <a href="https://iota.cafe/t/conflict-spamming-attack/232">conflict spamming attacks</a>) and network performance. However, a milestone no longer represents the inclusion state of all its referenced transactions, but only marks the order in which transactions are checked against the ledger state and then, if not violating, applied. This has two significant drawbacks:</p>
<ul>
<li>Milestone validation: In the IOTA protocol, each node always compares the milestones issued by the Coordinator against its current ledger state. Discrepancies are reported and force an immediate halt of the node software. However, in the white flag proposal this detection is no longer possible as any milestone can lead to a valid ledger state by ignoring the corresponding violating ledger changes.</li>
<li>Proof of inclusion: In the pre-white-flag protocol, the inclusion of transaction t in the Tangle, and thus, the ledger, can be shown by providing an audit path of referencing transactions from t to its confirming milestone. In the white flag proposal this is no longer possible, as such an audit path does not provide any information on whether the transaction has been included or ignored.</li>
</ul>
<p>Note that the white flag proposal only changes the behavior of conflicting transactions. Messages without a transaction payload can never conflict and are thus always included in Tangle when they are first referenced by a milestone. As such, these messages do not need to be considered by the RFC and their processing and inclusion proof remain unchanged.</p>
<p>Where previously the structure of the Tangle alone was sufficient to address those issues, this RFC proposes to add the Merkle tree hash of all the valid (i.e. not ignored) newly confirmed transactions to the signed part of a milestone. This way, each IOTA node can check that the hash matches its local ledger state changes or provide a Merkle audit path for that milestone to prove the inclusion of a particular transaction.</p>
<h1 id="detailed-design-2"><a class="header" href="#detailed-design-2">Detailed design</a></h1>
<h2 id="creating-a-milestone"><a class="header" href="#creating-a-milestone">Creating a Milestone</a></h2>
<ul>
<li>Perform tip selection to choose the parents referenced by the milestone.</li>
<li>Determine the topological order according to <a href="tips/TIP-0004/../TIP-0002/tip-0002.html">TIP-2</a> of the referenced messages that are not yet confirmed by a previous milestone.</li>
<li>Construct the list D consisting of the message IDs of all the not-ignored state-mutating transaction payloads in that particular order. A UTXO transaction is considered state-mutating, if it creates a new output.</li>
<li>Compute the 32-byte Merkle tree hash H = MTH(D).</li>
<li>Prepare the milestone payload as described in <a href="tips/TIP-0004/../TIP-0008/tip-0008.html">TIP-8</a>, where the field <code>Inclusion Merkle Root</code> is set to H.</li>
</ul>
<h2 id="milestone-validation"><a class="header" href="#milestone-validation">Milestone validation</a></h2>
<ul>
<li>Verify the signature of the milestone m.</li>
<li>Construct the ordered list D of the message IDs  of all the not-ignored state-mutating transaction payloads m confirms.</li>
<li>Compute H = MTH(D).</li>
<li>Verify that the field <code>Inclusion Merkle Root</code> in m matches H.</li>
</ul>
<h2 id="proof-of-inclusion"><a class="header" href="#proof-of-inclusion">Proof of inclusion</a></h2>
<ul>
<li>Identify the confirming milestone m of the input transaction t.</li>
<li>Determine the ordered list of the not-ignored messages m confirms.</li>
<li>Compute the Merkle audit path of t with respect to the Merkle tree for this ordered list.</li>
<li>Provide the audit path as well as m as proof of inclusion for t.</li>
</ul>
<h2 id="cryptographic-components"><a class="header" href="#cryptographic-components">Cryptographic components</a></h2>
<h3 id="merkle-hash-trees"><a class="header" href="#merkle-hash-trees">Merkle hash trees</a></h3>
<p>This RFC uses a binary Merkle hash tree for efficient auditing. In general, any cryptographic hashing algorithm can be used for this. However, we propose to use <a href="https://tools.ietf.org/html/rfc7693">BLAKE2b-256</a>, as it provides a faster and more secure alternative to the widely used SHA-256. 
In the following we define the Merkle tree hash (MTH) function that returns the hash of the root node of a Merkle tree:</p>
<ul>
<li>The input is a list of binary data entries; these entries will be hashed to form the leaves of the tree.</li>
<li>The output is a single 32-byte hash.</li>
</ul>
<p>Given an ordered list of n input strings D<sub>n</sub> = {d<sub>1</sub>, d<sub>2</sub>, ..., d<sub>n</sub>}, the Merkle tree hash of D is defined as follows:</p>
<ul>
<li>If D is an empty list, MTH(D) is the hash of an empty string:<br/>
MTH({}) = BLAKE2().</li>
<li>If D has the length 1, the hash (also known as a leaf hash) is:<br/>
MTH({d<sub>1</sub>}) = BLAKE2( 0x00 || d<sub>1</sub> ).</li>
<li>Otherwise, for D<sub>n</sub> with n &gt; 1:
<ul>
<li>Let k be the largest power of two less than n, i.e. k &lt; n ≤ 2k.</li>
<li>The Merkle tree hash can be defined recursively:<br/>
MTH(D<sub>n</sub>) = BLAKE2( 0x01 || MTH({d<sub>1</sub>, ..., d<sub>k</sub>}) || MTH({d<sub>k+1</sub>, ..., d<sub>n</sub>}) ).</li>
</ul>
</li>
</ul>
<p>Note that the hash calculations for leaves and nodes differ. This is required to provide second preimage resistance: Without such a prefix, for a given input D an attacker could replace  two (or more) leaves with their corresponding aggregated node hash without changing the final value of MTH(D). This violates the fundamental assumption that, given MTH(D), it should be practically impossible to find a different input D' leading to the same value. Adding a simple prefix mitigates this issue, since now leaf and node hashes are computed differently and can no longer be interchanged.</p>
<p>Note that we do not require the length of the input to be a power of two. However, its shape is still uniquely determined by the number of leaves.</p>
<h3 id="merkle-audit-paths"><a class="header" href="#merkle-audit-paths">Merkle audit paths</a></h3>
<p>A Merkle audit path for a leaf in a Merkle hash tree is the shortest list of additional nodes in a Merkle tree required to compute the Merkle tree hash for that tree. At each step towards the root, a node from the audit path is combined with a node computed so far. If the root computed from the audit path matches the Merkle tree hash, then the audit path is proof that the leaf exists in the tree.</p>
<h2 id="example-1"><a class="header" href="#example-1">Example</a></h2>
<p>Merkle tree with 7 leaves:</p>
<ul>
<li>input D:
<ol>
<li>52fdfc072182654f163f5f0f9a621d729566c74d10037c4d7bbb0407d1e2c649</li>
<li>81855ad8681d0d86d1e91e00167939cb6694d2c422acd208a0072939487f6999</li>
<li>eb9d18a44784045d87f3c67cf22746e995af5a25367951baa2ff6cd471c483f1</li>
<li>5fb90badb37c5821b6d95526a41a9504680b4e7c8b763a1b1d49d4955c848621</li>
<li>6325253fec738dd7a9e28bf921119c160f0702448615bbda08313f6a8eb668d2</li>
<li>0bf5059875921e668a5bdf2c7fc4844592d2572bcd0668d2d6c52f5054e2d083</li>
<li>6bf84c7174cb7476364cc3dbd968b0f7172ed85794bb358b0c3b525da1786f9f</li>
</ol>
</li>
<li>Merkle tree hash H = MTH(D) (32-byte): bf67ce7ba23e8c0951b5abaec4f5524360d2c26d971ff226d3359fa70cdb0beb</li>
</ul>
<pre><code>root: bf67ce7ba23e8c0951b5abaec4f5524360d2c26d971ff226d3359fa70cdb0beb
 ├─ node: 03bcbb3cf4314eab2f5ae68c767ff0a5fec4573c865728231f71d596fd867b56
 │  ├─ node: ae4505f4cfae93586e23958ca88d35d2f34d43def49786b6d0d4224b819f4cda
 │  │  │  ┌ msg id: 52fdfc072182654f163f5f0f9a621d729566c74d10037c4d7bbb0407d1e2c649
 │  │  ├──┴ leaf: 3d1399c64ff0ae6a074afa4cd2ce4eab8d5c499c1da6afdd1d84b7447cc00544
 │  │  │  ┌ msg id: 81855ad8681d0d86d1e91e00167939cb6694d2c422acd208a0072939487f6999
 │  │  └──┴ leaf: 83b0b255014e9a3656f0004a3f17943a20b715ef9c3e7cb85a6b2abac15e00d0
 │  └─ node: 54d51291aca22ce5b04cd3e6584fa3026ebe86ef86f0a6dfb47ab843801d4b38
 │     │  ┌ msg id: eb9d18a44784045d87f3c67cf22746e995af5a25367951baa2ff6cd471c483f1
 │     ├──┴ leaf: ad4bc0a34b27f37810f2ff3a8177ecc98402f8f59a06270f9d285fdf764e45fe
 │     │  ┌ msg id: 5fb90badb37c5821b6d95526a41a9504680b4e7c8b763a1b1d49d4955c848621
 │     └──┴ leaf: ffb3a7c6bea8f9fdcfb26f4701ad6e912a6076e1a40663607dbe110ebfc9a571
 └─ node: ce22d5bc728023e7ab6a9eb8f58baf62b9565fc8baeef4b377daa6709dbe598c
    ├─ node: e14c8af1258005cd0dbed88f0c5885c6988f319bb8f24272a7495592b873c169
    │  │  ┌ msg id: 6325253fec738dd7a9e28bf921119c160f0702448615bbda08313f6a8eb668d2
    │  ├──┴ leaf: 1c062628a7a147cc6a4defa655ce6c4ae5b838b4b4cd81b12e8924b5b4b5cca6
    │  │  ┌ msg id: 0bf5059875921e668a5bdf2c7fc4844592d2572bcd0668d2d6c52f5054e2d083
    │  └──┴ leaf: 2ef4e2ad06b8c8ae1fd4b28b5ed166829533fbfff1f6c14218358537da277fa3
    │  ┌ msg id: 6bf84c7174cb7476364cc3dbd968b0f7172ed85794bb358b0c3b525da1786f9f
    └──┴ leaf: 7ec774ebc33ed4ca298e8a1cf1f569e36c6784467d63b055efd7612abe2858a4
</code></pre>
<h1 id="drawbacks-2"><a class="header" href="#drawbacks-2">Drawbacks</a></h1>
<ul>
<li>The computation of the Merkle tree hash of D<sub>n</sub> requires 2n-1 evaluations of the underlying hashing algorithm. This makes the milestone creation and validation computationally slightly more expensive.</li>
</ul>
<h1 id="rationale-and-alternatives-2"><a class="header" href="#rationale-and-alternatives-2">Rationale and alternatives</a></h1>
<p>It is a crucial security feature of the IOTA network that nodes are able to validate the issued milestones. As a result, if the Coordinator were to ever send an invalid milestone, such as one that references counterfeit transactions, the rest of the nodes would not accept it. In a pure implementation of <a href="tips/TIP-0004/../TIP-0002/tip-0002.html">TIP-2</a> this feature is lost and must be provided by external mechanisms.
A Merkle tree hash provides an efficient, secure and well-established method to compress the information about the confirmed transactions in such a way, that they fit in the milestone transaction.</p>
<p>In this context, it could also be possible to use an unsecured checksum (such as CRCs) of the message IDs instead of a Merkle tree hash. However, the small benefit of faster computation times does no justify the potential security risks and attack vectors.</p>
<h1 id="reference-implementation"><a class="header" href="#reference-implementation">Reference implementation</a></h1>
<p>Example Go implementation in <a href="https://github.com/Wollac/iota-crypto-demo">wollac/iota-crypto-demo</a>:</p>
<ul>
<li>Merkle tree computation of message IDs: <a href="https://github.com/Wollac/iota-crypto-demo/blob/master/pkg/merkle/merkle.go">pkg/merkle/merkle.go</a></li>
<li>Example: <a href="https://github.com/Wollac/iota-crypto-demo/tree/master/examples/merkle/pt2">examples/merkle/pt2</a></li>
</ul>
<h1 id="copyright-3"><a class="header" href="#copyright-3">Copyright</a></h1>
<p>Copyright and related rights waived via <a href="https://creativecommons.org/publicdomain/zero/1.0/">CC0</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><pre>
tip: 5
title: Binary To Ternary Encoding
description: Define the conversion between binary and ternary data
author: Wolfgang Welz (@Wollac) <wolfgang.welz@iota.org>
discussions-to: https://github.com/iotaledger/tips/pull/15
status: Active
type: Standards
layer: Core
created: 2020-06-08
</pre>
<h1 id="summary-3"><a class="header" href="#summary-3">Summary</a></h1>
<p>In the IOTA protocol, a transaction is represented as ternary data. However, sometimes it is necessary to store binary data (e.g. the digest of a binary hash function) inside of a transaction. This requires the conversion of binary into ternary strings.
The IOTA client libraries support the opposite conversion that encodes 5 trits as 1 byte (sometimes also referred to as <code>t5b1</code> encoding), which is used for network communication and in storage layers. This RFC describes the corresponding counterpart to encode 1 byte as 6 trits.</p>
<h1 id="motivation-4"><a class="header" href="#motivation-4">Motivation</a></h1>
<p>A byte is composed of 8 bits that can represent 2<sup>8</sup> = 256 different values. On the other hand, 6 trits can hold 3<sup>6</sup> = 729 values while 5 trits can hold 3<sup>5</sup> = 243 values. Therefore, the most memory-efficient way to encode one byte requires the use of 6 trits. Although there exist many potential encoding schemes to convert binary data into ternary, the proposed version has been designed to directly match the widely used <code>t5b1</code> encoding.</p>
<p>It is important to note that the <code>b1t6</code> encoding presented in this RFC does not replace the current <code>t5b1</code> encoding (or its corresponding decoding): <code>t5b1</code> is for example used to store trytes in a binary database, while <code>b1t6</code> will be used to attach binary data to an IOTA transaction.</p>
<h1 id="detailed-design-3"><a class="header" href="#detailed-design-3">Detailed design</a></h1>
<h3 id="bytes-to-trits"><a class="header" href="#bytes-to-trits">Bytes to trits</a></h3>
<p>In order to encode a binary string S into ternary, each byte of S is interpreted as a signed (two's complement) 8-bit integer value v. Then, v is encoded as a little-endian 6-trit string in balanced ternary representation. Finally, the resulting groups of trits are concatenated.</p>
<p>This algorithm can also be described using the following pseudocode:</p>
<pre><code>T ← []
foreach byte b in S:
  v ← int8(b)
  g ← IntToTrits(v, 6)
  T ← T || g
</code></pre>
<p>Here, the function <code>IntToTrits</code> converts a signed integer value into its corresponding balanced ternary representation in little-endian order of the given length. The functionality of <code>IntToTrits</code> exactly matches the one used to e.g. encode the transaction values as trits in the current IOTA protocol.</p>
<h3 id="trits-to-bytes"><a class="header" href="#trits-to-bytes">Trits to bytes</a></h3>
<p>Given a trit string T as the result of the previous encoding, T is converted back to its original byte string S by simply reversing the conversion:</p>
<pre><code>S ← []
foreach 6-trit group g in T:
  v ← TritsToInt(g)
  b ← byte(v)
  S ← S || b
</code></pre>
<h2 id="examples"><a class="header" href="#examples">Examples</a></h2>
<ul>
<li>I
<ul>
<li>binary (hex): <code>00</code></li>
<li>ternary (trytes): <code>99</code></li>
</ul>
</li>
<li>II
<ul>
<li>binary (hex): <code>0001027e7f8081fdfeff</code></li>
<li>ternary (trytes):
<code>99A9B9RESEGVHVX9Y9Z9</code></li>
</ul>
</li>
<li>III
<ul>
<li>binary (hex): <code>9ba06c78552776a596dfe360cc2b5bf644c0f9d343a10e2e71debecd30730d03</code></li>
<li>ternary (trytes): <code>GWLW9DLDDCLAJDQXBWUZYZODBYPBJCQ9NCQYT9IYMBMWNASBEDTZOYCYUBGDM9C9</code></li>
</ul>
</li>
</ul>
<h1 id="drawbacks-3"><a class="header" href="#drawbacks-3">Drawbacks</a></h1>
<ul>
<li>Conceptually, one byte can be encoded using log<sub>3</sub>(256) ≈ 5.0474 trits. Thus, encoding 1 byte as 6 trits consumes considerably more memory than the mathematical minimum.</li>
<li>Depending on the actual implementation the conversion might be malleable: E.g. since <code>byte(-1) = 0xff</code> and <code>byte(255) = 0xff</code>, both <code>Z9</code> (-1) and <code>LI</code>(255) could be decoded as <code>ff</code>. However, <code>LI</code> can never be the result of a valid <code>b1t6</code> encoding. As such, the implementation must reject such invalid inputs.</li>
</ul>
<h1 id="rationale-and-alternatives-3"><a class="header" href="#rationale-and-alternatives-3">Rationale and alternatives</a></h1>
<p>There are several ways to convert binary data into ternary, e.g.</p>
<ul>
<li>the conversion used as part of the <a href="https://github.com/iotaledger/kerl/blob/master/IOTA-Kerl-spec.md">Kerl</a> hash function encoding chunks of 48 bytes as 242 trits,</li>
<li>or by encoding each bit as one trit with the corresponding value.</li>
</ul>
<p>The current client libraries do not provide any functionality to convert an arbitrary amount of bytes into trits. The closest available functionality is the ASCII to trit conversion, which is used for human-readable messages in transactions:</p>
<pre><code>T ← []
foreach char c in S:
  first ← uint8(c) mod 27
  second ← (uint8(c)-first) / 27
  T ← T || IntToTrits(first, 3) || IntToTrits(second, 3)
</code></pre>
<p>This function can be adapted to encode any general byte string. However, the conversion seems rather arbitrary and the algorithm is computationally more intense than the proposed solution.
On the other hand, using the algorithm from this RFC also for the conversion of ASCII messages would break backward compatibility, which is also undesirable.</p>
<p>Each conversion method has different advantages and disadvantages. However, since the <code>t5b1</code> encoding is well-defined and has been used in <a href="https://github.com/iotaledger/iri">IRI</a> for both network communications and storage layers for a long time, choosing the direct counterpart for the opposite conversion represents the most logical solution providing a nice balance between performance and memory-efficiency.</p>
<h1 id="reference-implementation-1"><a class="header" href="#reference-implementation-1">Reference implementation</a></h1>
<p>Example Go implementation in <a href="https://github.com/Wollac/iota-crypto-demo">wollac/iota-crypto-demo</a>:</p>
<ul>
<li>Binary-to-Ternary Encoding: <a href="https://github.com/Wollac/iota-crypto-demo/blob/master/pkg/encoding/ternary/ternary.go">pkg/encoding/ternary/ternary.go</a></li>
</ul>
<h1 id="copyright-4"><a class="header" href="#copyright-4">Copyright</a></h1>
<p>Copyright and related rights waived via <a href="https://creativecommons.org/publicdomain/zero/1.0/">CC0</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><pre>
tip: 6
title: Tangle Message
description: Generalization of the Tangle transaction concept
author: Gal Rogozinski (@GalRogozinski) <gal.rogozinski@iota.org>
discussions-to: https://github.com/iotaledger/tips/pull/17
status: Replaced
type: Standards
layer: Core
created: 2020-07-28
superseded-by: TIP-24
</pre>
<ul>
<li>Changelog:
<ul>
<li>(<a href="https://github.com/iotaledger/tips/pull/0037">iotaledger/tips#0037</a>) Fixed internal links</li>
</ul>
</li>
</ul>
<h1 id="summary-4"><a class="header" href="#summary-4">Summary</a></h1>
<p>The Tangle is the graph data structure behind IOTA. In the current IOTA protocol, the vertices of the Tangle are represented by transactions. This document proposes an abstraction of this idea where the vertices are generalized <em>messages</em>, which then contain the transactions or other structures that are processed by the IOTA protocol. Just as before, each message directly approves other messages, which are known as <em>parents</em>.</p>
<p>The messages can contain payloads. These are core payloads that will be processed by all nodes as part of the IOTA protocol. Some payloads may have other nested payloads embedded inside. Hence, parsing is done layer by layer.</p>
<h1 id="motivation-5"><a class="header" href="#motivation-5">Motivation</a></h1>
<p>To better understand this layered design, consider the Internet Protocol (IP), for example: There is an Ethernet frame that contains an IP payload. This in turn contains a TCP packet that encapsulates an HTTP payload. Each layer has a certain responsibility and once this responsibility is completed, we move on to the next layer.</p>
<p>The same is true with how messages are parsed. The outer layer of the message enables the mapping of the message to a vertex in the Tangle and allow us to perform some basic validation. The next layer may be a transaction that mutates the ledger state, and one layer further may provide some extra functionality on the transactions to be used by applications.</p>
<p>By making it possible to add and exchange payloads, an architecture is being created that can easily be extended to accommodate future needs.</p>
<h1 id="detailed-design-4"><a class="header" href="#detailed-design-4">Detailed design</a></h1>
<h2 id="structure"><a class="header" href="#structure">Structure</a></h2>
<h3 id="message-id"><a class="header" href="#message-id">Message ID</a></h3>
<p>The <em>Message ID</em> is the <a href="https://tools.ietf.org/html/rfc7693">BLAKE2b-256</a> hash of the entire serialized message.</p>
<h3 id="serialized-layout"><a class="header" href="#serialized-layout">Serialized layout</a></h3>
<p>The following table describes the serialization of a <em>Message</em> following the notation from <a href="https://iotaledger.github.io/protocol-rfcs/0041-serialization-primitives/0041-serialization-primitives.html">RFC-0041</a>:</p>
<table>
  <tr>
    <th>Name</th>
    <th>Type</th>
    <th>Description</th>
  </tr>
  <tr>
    <td>Network ID</td>
    <td>uint64</td>
    <td>Network identifier. This field denotes whether the message was meant for mainnet, testnet, or a private net. It also marks what protocol rules apply to the message. Usually, it will be set to the first 8 bytes of the BLAKE2b-256 hash of the concatenation of the network type and the protocol version string.</td>
  </tr>
  <tr>
    <td>Parents Count</td>
    <td>uint8</td>
    <td>The number of messages that are directly approved.</td>
  </tr>
  <tr>
    <td valign="top">Parents <code>anyOf</code></td>
    <td colspan="2">
      <details>
        <summary>Parent</summary>
        <blockquote>
          References another directly approved message.
        </blockquote>
        <table>
          <tr>
            <th>Name</th>
            <th>Type</th>
            <th>Description</th>
          </tr>
          <tr>
            <td>Message ID</td>
            <td>ByteArray[32]</td>
            <td>The Message ID of the parent.</td>
          </tr>
        </table>
      </details>
    </td>
  </tr>
  <tr>
    <td>Payload Length</td>
    <td>uint32</td>
    <td>The length of the following payload in bytes. A length of 0 means no payload will be attached.</td>
  </tr>
  <tr>
    <td valign="top">Payload <code>oneOf</code></td>
    <td colspan="2">
      <details open="true">
        <summary>Generic Payload</summary>
        <blockquote>
          An outline of a generic payload
        </blockquote>
        <table>
          <tr>
            <th>Name</th>
            <th>Type</th>
            <th>Description</th>
          </tr>
          <tr>
            <td>Payload Type</td>
            <td>uint32</td>
            <td>
              The type of the payload. It will instruct the node how to parse the fields that follow.
            </td>
          </tr>
          <tr>
            <td>Data Fields</td>
            <td>ANY</td>
            <td>A sequence of fields, where the structure depends on <code>Payload Type</code>.</td>
          </tr>
        </table>
      </details>
    </td>
  </tr>
  <tr>
    <td>Nonce</td>
    <td>uint64</td>
    <td>The nonce which lets this message fulfill the PoW requirement.</td>
  </tr>
</table>
<h2 id="message-validation"><a class="header" href="#message-validation">Message validation</a></h2>
<p>The following criteria defines whether the message passes the syntactical validation:</p>
<ul>
<li>The total message size must not exceed 32 KiB (32 * 1024 bytes).</li>
<li>Parents:
<ul>
<li><code>Parents Count</code> must be at least 1 and not larger than 8.</li>
<li><code>Parents</code> must be sorted in lexicographical order.</li>
<li>Each <code>Message ID</code> must be unique.</li>
</ul>
</li>
<li>Payload (if present):
<ul>
<li><code>Payload Type</code> must match one of the values described under <a href="tips/TIP-0006/tip-0006.html#payloads">Payloads</a>.</li>
<li><code>Data fields</code> must be correctly parsable in the context of the <code>Payload Type</code>.</li>
<li>The payload itself must pass syntactic validation.</li>
</ul>
</li>
<li><code>Nonce</code> must be a valid solution of the message PoW as described in <a href="tips/TIP-0006/../TIP-0012/tip-0012.html">TIP-12</a>.</li>
<li>There must be no trailing bytes after all message fields have been parsed.</li>
</ul>
<h2 id="payloads"><a class="header" href="#payloads">Payloads</a></h2>
<p>While messages without a payload, i.e. <code>Payload Length</code> set to zero, are valid, such messages do not contain any information. As such, messages usually contain a payload. The detailed specification of each payload type is out of scope of this RFC. The following table lists all currently specified payloads that can be part of a message and links to their specification. The <em>indexation payload</em> will be specified here as an example:</p>
<div class="table-wrapper"><table><thead><tr><th>Payload Name</th><th>Type Value</th><th>TIP</th></tr></thead><tbody>
<tr><td>Transaction</td><td>0</td><td><a href="tips/TIP-0006/../TIP-0007/tip-0007.html">TIP-7</a></td></tr>
<tr><td>Milestone</td><td>1</td><td><a href="tips/TIP-0006/../TIP-0008/tip-0008.html">TIP-8</a></td></tr>
<tr><td>Indexation</td><td>2</td><td><a href="tips/TIP-0006/tip-0006.html#indexation-payload">TIP-6</a></td></tr>
</tbody></table>
</div>
<h3 id="indexation-payload"><a class="header" href="#indexation-payload">Indexation payload</a></h3>
<p>This payload allows the addition of an index to the encapsulating message, as well as some arbitrary data. Nodes will expose an API that allows to query messages by index.</p>
<p>The structure of the indexation payload is as follows:</p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td>Payload Type</td><td>uint32</td><td>Set to <b>value 2</b> to denote an <i>Indexation Payload</i>.</td></tr>
<tr><td>Index Length</td><td>uint16</td><td>The length of the following index field in bytes.</td></tr>
<tr><td>Index</td><td>ByteArray[Index Length]</td><td>The index key of the message</td></tr>
<tr><td>Data</td><td>ByteArray</td><td>Binary data.</td></tr>
</tbody></table>
</div>
<p>Note that <code>Index</code> field must be at least 1 byte and not longer than 64 bytes for the payload to be valid. The <code>Data</code> may have a length of 0.</p>
<h2 id="example-2"><a class="header" href="#example-2">Example</a></h2>
<p>Below is the full serialization of a valid message with an indexation payload. The index is the &quot;IOTA&quot; ASCII string and the data is the &quot;hello world&quot; ASCII string. Bytes are expressed as hexadecimal numbers.</p>
<ul>
<li>Network ID (8-byte): <code>0000000000000000</code> (0)</li>
<li>Parents Count (1-byte): <code>02</code> (2)</li>
<li>Parents (64-byte):
<ul>
<li><code>210fc7bb818639ac48a4c6afa2f1581a8b9525e20fda68927f2b2ff836f73578</code></li>
<li><code>db0fa54c29f7fd928d92ca43f193dee47f591549f597a811c8fa67ab031ebd9c</code></li>
</ul>
</li>
<li>Payload Length (4-byte): <code>19000000</code> (25)</li>
<li>Payload (25-byte):
<ul>
<li>Payload Type (4-byte): <code>02000000</code> (2)</li>
<li>Index Length (2-byte): <code>0400</code> (4)</li>
<li>Index (4-byte): <code>494f5441</code> (&quot;IOTA&quot;)</li>
<li>Data (15-byte):
<ul>
<li>Length (4-byte): <code>0b000000</code> (11)</li>
<li>Data (11-byte): <code>68656c6c6f20776f726c64</code> (&quot;hello world&quot;)</li>
</ul>
</li>
</ul>
</li>
<li>Nonce (8-byte): <code>ce6d000000000000</code> (28110)</li>
</ul>
<h1 id="rationale-and-alternatives-4"><a class="header" href="#rationale-and-alternatives-4">Rationale and alternatives</a></h1>
<p>Instead of creating a layered approach, we could have simply created a flat transaction message that is tailored to mutate the ledger state, and try to fit all the use cases there. For example, with the indexed data use case, we could have filled some section of the transaction with that particular data. Then, this transaction would not correspond to a ledger mutation but instead only carry data.</p>
<p>This approach seems less extensible. It might have made sense if we had wanted to build a protocol that is just for ledger mutating transactions, but we want to be able to extend the protocol to do more than that.</p>
<h1 id="copyright-5"><a class="header" href="#copyright-5">Copyright</a></h1>
<p>Copyright and related rights waived via <a href="https://creativecommons.org/publicdomain/zero/1.0/">CC0</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><pre>
tip: 7
title: Transaction Payload
description: UTXO-based transaction structure
author: Luca Moser (@luca-moser) <luca.moser@iota.org>
discussions-to: https://github.com/iotaledger/tips/pull/18
status: Replaced
type: Standards
layer: Core
created: 2020-07-10
superseded-by: TIP-20
</pre>
<h1 id="summary-5"><a class="header" href="#summary-5">Summary</a></h1>
<p>In the current IOTA protocol, transactions are grouped into so-called bundles to assure that they can only be confirmed as one unit. This TIP proposes a new UTXO-based transaction structure containing all the inputs and outputs of a transfer. Specifically, this TIP defines a transaction payload for the <em>messages</em> described in the IOTA protocol <a href="tips/TIP-0007/../TIP-0006/tip-0006.html">TIP-6</a>.</p>
<h1 id="motivation-6"><a class="header" href="#motivation-6">Motivation</a></h1>
<p>Currently, the vertices of the Tangle are represented by transactions, where each transaction defines either an input or output. A grouping of those input/output transaction vertices makes up a bundle which transfers the given values as an atomic unit (the entire bundle is applied or none of it). An applied bundle consumes the input transactions' funds and creates the corresponding deposits into the output transactions' target addresses. Furthermore, additional meta transactions can be part of the bundle to carry parts of the signature which do not fit into a single input transaction.</p>
<p>The bundle concept has proven to be very challenging in practice because of the following issues:</p>
<ul>
<li>Since the data making up the bundle is split across multiple vertices, it complicates the validation of the entire transfer. Instead of being able to immediately tell whether a bundle is valid or not, a node implementation must first collect all parts of the bundle before any actual validation can happen. This increases the complexity of the node implementation.</li>
<li>Reattaching the tail transaction of a bundle causes the entire transfer to be reapplied.</li>
<li>Due to the split across multiple transaction vertices and having to do PoW for each of them, a bundle might already be lazy in terms of where it attaches, reducing its chances to be confirmed.</li>
</ul>
<p>To fix the problems mentioned above and to create a more flexible transaction structure, the goal is to achieve a self-contained transaction structure defining the data of the entire transfer as a payload to be embedded into a message.</p>
<p>The new transaction structure should fulfil the following criteria:</p>
<ul>
<li>Support for Ed25519 (and thus reusable addresses).</li>
<li>Support for adding new types of signature schemes, addresses, inputs, and outputs as part of protocol upgrades.</li>
<li>Self-contained, as in being able to validate the transaction immediately after receiving it.</li>
<li>Enable unspent transaction outputs (UTXO) as inputs instead of an account based model.</li>
</ul>
<h1 id="detailed-design-5"><a class="header" href="#detailed-design-5">Detailed design</a></h1>
<h2 id="utxo"><a class="header" href="#utxo">UTXO</a></h2>
<p>The <em>unspent transaction output</em> (UTXO) model defines a ledger state where balances are not directly associated to addresses but to the outputs of transactions. In this model, transactions reference outputs of previous transactions as inputs, which are consumed (removed) to create new outputs. A transaction must consume all the funds of the referenced inputs.</p>
<p>Using a UTXO based model provides several benefits:</p>
<ul>
<li>Parallel validation of transactions.</li>
<li>Easier double-spend detection, since conflicting transactions would reference the same UTXO.</li>
<li>Replay-protection which is important when having reusable addresses. Replaying the same transaction would manifest itself as already being applied or existent and thus not have any impact.</li>
<li>Technically seen, balances are no longer associated to addresses which raises the level of abstraction and thus enables other types of outputs with particular unlock criteria.</li>
</ul>
<p>Within a transaction using UTXOs, inputs and outputs make up the to-be-signed data of the transaction. The section unlocking the inputs is called the <em>unlock block</em>. An unlock block may contain a signature proving ownership of a given input's address and/or other unlock criteria.</p>
<p>The following image depicts the flow of funds using UTXO:</p>
<p><img src="tips/TIP-0007/utxo.png" alt="UTXO flow" /></p>
<h2 id="structure-1"><a class="header" href="#structure-1">Structure</a></h2>
<h3 id="serialized-layout-1"><a class="header" href="#serialized-layout-1">Serialized layout</a></h3>
<p>A <em>Transaction Payload</em> is made up of two parts:</p>
<ol>
<li>The <em>Transaction Essence</em> part which contains the inputs, outputs and an optional embedded payload.</li>
<li>The <em>Unlock Blocks</em> which unlock the inputs of the <em>Transaction Essence</em>. When an unlock block contains a signature, it signs the entire <em>Transaction Essence</em> part.</li>
</ol>
<p>All values are serialized in little-endian encoding. The serialized form of the transaction is deterministic, meaning the same logical transaction always results in the same serialized byte sequence.</p>
<p>The <em>Transaction ID</em> is the <a href="https://tools.ietf.org/html/rfc7693">BLAKE2b-256</a> hash of the entire serialized payload data including signatures.</p>
<p>The following table describes the entirety of a <em>Transaction Payload</em> in its serialized form following the notation from <a href="tips/TIP-0007/../TIP-0021/tip-0021.html">TIP-21</a>.</p>
<table>
  <tr>
    <th>Name</th>
    <th>Type</th>
    <th>Description</th>
  </tr>
  <tr>
    <td>Payload Type</td>
    <td>uint32</td>
    <td>
      Set to <strong>value 0</strong> to denote a <i>Transaction Payload</i>.
    </td>
  </tr>
  <tr>
    <td valign="top">Essence <code>oneOf</code></td>
    <td colspan="2">
      <details open="true">
        <summary>Transaction Essence</summary>
        <blockquote>
          Describes the essence data making up a transaction by defining its inputs, outputs and an optional payload.
        </blockquote>
        <table>
          <tr>
            <td><b>Name</b></td>
            <td><b>Type</b></td>
            <td><b>Description</b></td>
          </tr>
          <tr>
            <td>Transaction Type</td>
            <td>uint8</td>
            <td>
              Set to <strong>value 0</strong> to denote a <i>Transaction Essence</i>.
            </td>
          </tr>
          <tr>
            <td>Inputs Count</td>
            <td>uint16</td>
            <td>The number of input entries.</td>
          </tr>
          <tr>
            <td valign="top">Inputs <code>anyOf</code></td>
            <td colspan="2">
              <details>
                <summary>UTXO Input</summary>
                <blockquote>
                  Describes an input which references an unspent transaction output to consume.
                </blockquote>
                <table>
                  <tr>
                    <td><b>Name</b></td>
                    <td><b>Type</b></td>
                    <td><b>Description</b></td>
                  </tr>
                  <tr>
                    <td>Input Type</td>
                    <td>uint8</td>
                    <td>
                      Set to <strong>value 0</strong> to denote an <i>UTXO Input</i>.
                    </td>
                  </tr>
                  <tr>
                    <td>Transaction ID</td>
                    <td>ByteArray[32]</td>
                    <td>The BLAKE2b-256 hash of the transaction payload containing the referenced output.</td>
                  </tr>
                  <tr>
                    <td>Transaction Output Index</td>
                    <td>uint16</td>
                    <td>The output index of the referenced output.</td>
                  </tr>
                </table>
              </details>
            </td>
          </tr>
          <tr>
            <td>Outputs Count</td>
            <td>uint16</td>
            <td>The number of output entries.</td>
          </tr>
          <tr>
            <td valign="top">Outputs <code>anyOf</code></td>
            <td colspan="2">
              <details>
                <summary>SigLockedSingleOutput</summary>
                <blockquote>
                  Describes a deposit to a single address which is unlocked via a signature.
                </blockquote>
                <table>
                  <tr>
                    <td><b>Name</b></td>
                    <td><b>Type</b></td>
                    <td><b>Description</b></td>
                  </tr>
                  <tr>
                    <td>Output Type</td>
                    <td>uint8</td>
                    <td>
                      Set to <strong>value 0</strong> to denote a <i>SigLockedSingleOutput</i>.
                    </td>
                  </tr>
                  <tr>
                    <td valign="top">Address <code>oneOf</code></td>
                    <td colspan="2">
                      <details>
                        <summary>Ed25519 Address</summary>
                        <table>
                          <tr>
                            <td><b>Name</b></td>
                            <td><b>Type</b></td>
                            <td><b>Description</b></td>
                          </tr>
                          <tr>
                            <td>Address Type</td>
                            <td>uint8</td>
                            <td>
                              Set to <strong>value 0</strong> to denote an <i>Ed25519 Address</i>.
                            </td>
                          </tr>
                          <tr>
                            <td>Address</td>
                            <td>ByteArray[32]</td>
                            <td>The raw bytes of the Ed25519 address which is the BLAKE2b-256 hash of the public key.</td>
                          </tr>
                        </table>
                      </details>
                    </td>
                  </tr>
                  <tr>
                    <td>Amount</td>
                    <td>uint64</td>
                    <td>The amount of tokens to deposit.</td>
                  </tr>
                </table>
              </details>
              <details>
                <summary>SigLockedDustAllowanceOutput</summary>
                <blockquote>
                  Describes a deposit which as a special property also alters the dust allowance of the target address.
                </blockquote>
                <table>
                  <tr>
                    <td><b>Name</b></td>
                    <td><b>Type</b></td>
                    <td><b>Description</b></td>
                  </tr>
                  <tr>
                    <td>Output Type</td>
                    <td>uint8</td>
                    <td>
                      Set to <strong>value 1</strong> to denote a <i>SigLockedDustAllowanceOutput</i>.
                    </td>
                  </tr>
                  <tr>
                    <td valign="top">Address <code>oneOf</code></td>
                    <td colspan="2">
                      <details>
                        <summary>Ed25519 Address</summary>
                        <table>
                          <tr>
                            <td><b>Name</b></td>
                            <td><b>Type</b></td>
                            <td><b>Description</b></td>
                          </tr>
                          <tr>
                            <td>Address Type</td>
                            <td>uint8</td>
                            <td>
                              Set to <strong>value 0</strong> to denote an <i>Ed25519 Address</i>.
                            </td>
                          </tr>
                          <tr>
                            <td>Address</td>
                            <td>ByteArray[32]</td>
                            <td>The raw bytes of the Ed25519 address which is the BLAKE2b-256 hash of the public key.</td>
                          </tr>
                        </table>
                      </details>
                    </td>
                  </tr>
                  <tr>
                    <td>Amount</td>
                    <td>uint64</td>
                    <td>The amount of tokens to deposit.</td>
                  </tr>
                </table>
              </details>
            </td>
          </tr>
          <tr>
            <td>Payload Length</td>
            <td>uint32</td>
            <td>The length in bytes of the optional payload.</td>
          </tr>
          <tr>
            <td valign="top">Payload <code>optOneOf</code></td>
            <td colspan="2">
              <details>
                <summary>Generic Payload</summary>
                <blockquote>
                  An outline of a generic payload.
                </blockquote>
                <table>
                  <tr>
                    <th>Name</th>
                    <th>Type</th>
                    <th>Description</th>
                  </tr>
                  <tr>
                    <td>Payload Type</td>
                    <td>uint32</td>
                    <td>
                      The type of the payload. It will instruct the node how to parse the fields that follow.
                    </td>
                  </tr>
                  <tr>
                    <td>Data Fields</td>
                    <td>ANY</td>
                    <td>A sequence of fields, where the structure depends on <code>Payload Type</code>.</td>
                  </tr>
                </table>
              </details>
            </td>
          </tr>
        </table>
      </details>
    </td>
  </tr>
  <tr>
    <td>Unlock Blocks Count</td>
    <td>uint16</td>
     <td>The number of unlock block entries. It must match the field <code>Inputs Count</code>.</td>
  </tr>
  <tr>
    <td valign="top">Unlock Blocks <code>anyOf</code></td>
    <td colspan="2">
      <details open="true">
        <summary>Signature Unlock Block</summary>
        <blockquote>
          Defines an unlock block containing a signature.
        </blockquote>
        <table>
          <tr>
            <th>Name</th>
            <th>Type</th>
            <th>Description</th>
          </tr>
          <tr>
            <td>Unlock Type</td>
            <td>uint8</td>
            <td>
              Set to <strong>value 0</strong> to denote a <i>Signature Unlock Block</i>.
            </td>
          </tr>
          <tr>
            <td valign="top">Signature <code>oneOf</code></td>
            <td colspan="2">
              <details>
                <summary>Ed25519 Signature</summary>
                <table>
                  <tr>
                    <th>Name</th>
                    <th>Type</th>
                    <th>Description</th>
                  </tr>
                  <tr>
                    <td>Signature Type</td>
                    <td>uint8</td>
                    <td>
                      Set to <strong>value 0</strong> to denote an <i>Ed25519 Signature</i>.
                    </td>
                  </tr>
                  <tr>
                    <td>Public key</td>
                    <td>ByteArray[32]</td>
                    <td>The Ed25519 public key of the signature.</td>
                  </tr>
                  <tr>
                    <td>Signature</td>
                    <td>ByteArray[64]</td>
                    <td>The Ed25519 signature signing the Blake2b-256 hash of the serialized <i>Transaction Essence</i>.</td>
                  </tr>
                </table>
              </details>
            </td>
          </tr>
        </table>
      </details>
      <details open="true">
        <summary>Reference Unlock Block</summary>
        <blockquote>
          References a previous unlock block, where the same unlock block can be used for multiple inputs.
        </blockquote>
        <table>
          <tr>
            <th>Name</th>
            <th>Type</th>
            <th>Description</th>
          </tr>
          <tr>
            <td>Unlock Type</td>
            <td>uint8</td>
            <td>
              Set to <strong>value 1</strong> to denote a <i>Reference Unlock Block</i>.
            </td>
          </tr>
          <tr>
            <td>Reference</td>
            <td>uint16</td>
            <td>Represents the index of a previous unlock block.</td>
          </tr>
        </table>
      </details>
    </td>
  </tr>
</table>
<h3 id="transaction-parts"><a class="header" href="#transaction-parts">Transaction parts</a></h3>
<p>In general, all parts of a <i>Transaction Payload</i> begin with a byte describing the type of the given part. This improves the flexibility to introduce new types/versions of the given part in the future.</p>
<h4 id="transaction-essence-data"><a class="header" href="#transaction-essence-data">Transaction Essence data</a></h4>
<p>The <i>Transaction Essence</i> of a <i>Transaction Payload</i> carries the inputs, outputs, and an optional payload. The <i>Transaction Essence</i> is an explicit type and therefore starts with its own <i>Transaction Essence Type</i> byte which is of value 0.</p>
<h5 id="inputs"><a class="header" href="#inputs">Inputs</a></h5>
<p>The <i>Inputs</i> part holds the inputs to consume in order to fund the outputs of the <i>Transaction Payload</i>. Currently, there is only one type of input, the <i>UTXO Input</i>. In the future, more types of inputs may be specified as part of protocol upgrades.</p>
<p>Each input must be accompanied by a corresponding <i>Unlock Block</i> at the same index in the <i>Unlock Blocks</i> part of the <i>Transaction Payload</i>.</p>
<h6 id="utxo-input"><a class="header" href="#utxo-input">UTXO Input</a></h6>
<p>A <i>UTXO Input</i> is an input which references an unspent output of a previous transaction. This UTXO is uniquely defined by the <em>Transaction ID</em> of that transaction together with corresponding output index. Each <i>UTXO Input</i> must be accompanied by an <i>Unlock Block</i> that is allowed to unlock the output the <i>UTXO Input</i> is referencing.</p>
<p>Example:
If the input references an output to an Ed25519 address, then the corresponding unlock block must be of type <i>Signature Unlock Block</i> holding an Ed25519 signature.</p>
<h5 id="outputs"><a class="header" href="#outputs">Outputs</a></h5>
<p>The <i>Outputs</i> part holds the outputs that are created by this <i>Transaction Payload</i>. The following output types are supported:</p>
<h6 id="siglockedsingleoutput"><a class="header" href="#siglockedsingleoutput">SigLockedSingleOutput</a></h6>
<p>The <i>SigLockedSingleOutput</i> defines an output (with a certain amount) to a single target address which is unlocked via a signature proving ownership over the given address. This output supports addresses of different types.</p>
<h6 id="siglockeddustallowanceoutput"><a class="header" href="#siglockeddustallowanceoutput">SigLockedDustAllowanceOutput</a></h6>
<p>The <i>SigLockedDustAllowanceOutput</i> works in the same way as a <i>SigLockedSingleOutput</i> but additionally controls the dust allowance on the target address. See <a href="tips/TIP-0007/../TIP-0014/tip-0014.html">TIP-14</a> for further information.</p>
<h5 id="payload"><a class="header" href="#payload">Payload</a></h5>
<p>The  <em>Transaction Essence</em> itself can contain another payload as described in general in  <a href="tips/TIP-0007/../TIP-0006/tip-0006.html">TIP-6</a>. The <a href="tips/TIP-0007/tip-0007.html#semantic-validation">semantic validity</a> of the encapsulating <em>Transaction Payload</em> does not have any impact on the payload.</p>
<p>The following table lists all the payload types that can be nested inside a <em>Transaction Essence</em> as well as links to the corresponding specification:</p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type Value</th><th>TIP</th></tr></thead><tbody>
<tr><td>Indexation</td><td>2</td><td><a href="tips/TIP-0007/../TIP-0006/tip-0006.html#indexation-payload">TIP-6</a></td></tr>
</tbody></table>
</div>
<h4 id="unlock-blocks"><a class="header" href="#unlock-blocks">Unlock Blocks</a></h4>
<p>The <i>Unlock Blocks</i> part holds the unlock blocks unlocking inputs within a <i>Transaction Essence</i>. The following types of unlock blocks are supported:</p>
<h5 id="signature-unlock-block"><a class="header" href="#signature-unlock-block">Signature Unlock Block</a></h5>
<p>A <i>Signature Unlock Block</i> defines an <i>Unlock Block</i> which holds a signature signing the BLAKE2b-256 hash of the <i>Transaction Essence</i> (including the optional payload).</p>
<h5 id="reference-unlock-block"><a class="header" href="#reference-unlock-block">Reference Unlock block</a></h5>
<p>A <i>Reference Unlock Block</i> defines an <i>Unlock Block</i> which references a previous <i>Unlock Block</i> (which must not be another <i>Reference Unlock Block</i>). It <strong>must</strong> be used if multiple inputs can be unlocked via the same <i>Unlock Block</i>.</p>
<p>Example:
Consider a <i>Transaction Essence</i> containing the <i>UTXO Inputs</i> 0, 1 and 2, where 0 and 2 are both spending outputs belonging to the same Ed25519 address A and 1 is spending from a different address B. This results in the following structure of the <i>Unlock Blocks</i> part:</p>
<div class="table-wrapper"><table><thead><tr><th>Index</th><th>Unlock Block</th></tr></thead><tbody>
<tr><td>0</td><td>A <em>Signature Unlock Block</em> holding the Ed25519 signature for address A.</td></tr>
<tr><td>1</td><td>A <em>Signature Unlock Block</em> holding the Ed25519 signature for address B.</td></tr>
<tr><td>2</td><td>A <em>Reference Unlock Block</em> which references 0, as both require the same signature for A.</td></tr>
</tbody></table>
</div>
<h2 id="validation"><a class="header" href="#validation">Validation</a></h2>
<p>A <i>Transaction Payload</i> has different validation stages, since some validation steps can only be executed when certain information has (or has not) been received. We therefore distinguish between syntactic and semantic validation:</p>
<h3 id="syntactic-validation"><a class="header" href="#syntactic-validation">Syntactic validation</a></h3>
<p>Syntactic validation is checked as soon as the transaction data has been received in its entirety. It validates the structure but not the signatures of the transaction. If the transaction does not pass this stage, it must not be broadcasted further and can be discarded right away.</p>
<p>The following criteria defines whether a payload passes the syntactical validation:</p>
<ul>
<li>Essence:
<ul>
<li><code>Transaction Type</code> value must denote a <em>Transaction Essence</em>.</li>
<li>Inputs:
<ul>
<li><code>Inputs Count</code> must be 0 &lt; x ≤ 127.</li>
<li>For each input the following must be true:
<ul>
<li><code>Input Type</code> must denote a <em>UTXO Input</em>.</li>
<li><code>Transaction Output Index</code> must be 0 ≤ x &lt; 127.</li>
</ul>
</li>
<li><code>Inputs</code> must be sorted in lexicographical order of their serialized form.<sup>1</sup></li>
<li>Each pair of <code>Transaction ID</code> and <code>Transaction Output Index</code> must be unique in the inputs set.</li>
</ul>
</li>
<li>Outputs:
<ul>
<li><code>Outputs Count</code> must be 0 &lt; x ≤ 127.</li>
<li>For each input the following must be true:
<ul>
<li><code>Output Type</code> must denote a <em>SigLockedSingleOutput</em> or a <em>SigLockedDustAllowanceOutput</em>.</li>
<li><code>Address Type</code> must denote an <em>Ed25519 Address</em>.</li>
<li><code>Amount</code> must be larger than zero.</li>
</ul>
</li>
<li><code>Outputs</code> must be sorted in lexicographical order of their serialized form.<sup>1</sup></li>
<li>Each <code>Address</code> must be unique per output type. For example, a <em>SigLockedSingleOutput</em> and a <em>SigLockedDustAllowanceOutput</em> can have the same address, but not two <em>SigLockedSingleOutputs</em>.</li>
<li>The sum of all <code>Amount</code> fields must not exceed the total IOTA supply of 2,779,530,283,277,761.</li>
</ul>
</li>
<li>Payload (if present):
<ul>
<li><code>Payload Type</code> must match one of the values described under <a href="tips/TIP-0007/tip-0007.html#payload">Payload</a>.</li>
<li><code>Data fields</code> must be correctly parsable in the context of the <code>Payload Type</code>.</li>
<li>The payload itself must pass syntactic validation.</li>
</ul>
</li>
</ul>
</li>
<li>Unlock Blocks:
<ul>
<li><code>Unlock Blocks Count</code> must match <code>Inputs Count</code> of the <em>Transaction Essence</em>.</li>
<li>Each <code>Unlock Type</code> must denote a <em>Signature Unlock Block</em> or a <em>Reference Unlock Block</em>.</li>
<li>Each <em>Signature Unlock Block</em> must contain an <em>Ed25519 Signature</em>.</li>
<li>Each <em>Signature Unlock Block</em> must be unique.</li>
<li>A <em>Reference Unlock Block</em> at index i must have <code>Reference</code> &lt; i and the unlock block at index <code>Reference</code> must be a <em>Signature Unlock Block</em>.</li>
</ul>
</li>
<li>Given the type and length information, the <em>Transaction Payload</em> must consume the entire byte array of the <code>Payload</code> field of the encapsulating object.</li>
</ul>
<p><sup>1</sup> ensures that serialization of the transaction becomes deterministic, meaning that libraries always produce the same bytes given the logical transaction.</p>
<h3 id="semantic-validation"><a class="header" href="#semantic-validation">Semantic validation</a></h3>
<p>The Semantic validation of a <em>Transaction Payload</em> is performed when its encapsulating message is confirmed by a milestone. The semantic validity of transactions depends on the order in which they are processed. Thus, it is necessary that all the nodes in the network perform the checks in the same order, no matter the order in which the transactions are received. This is assured by using the White-Flag ordering as described in  <a href="tips/TIP-0007/../TIP-0002/tip-0002.html#deterministically-ordering-the-tangle">TIP-2</a>.</p>
<p>Processing transactions according to the White-Flag ordering enables users to spend UTXOs which are created in the same milestone confirmation cone, as long as the spending transaction comes after the funding transaction in the aforementioned White-Flag order. In this case, it is recommended that users include the <em>Message ID</em> of the funding transaction as a parent of the message containing the spending transaction.</p>
<p>The following criteria defines whether a payload passes the semantic validation:</p>
<ul>
<li>Each input must reference a valid UTXO, i.e. the output referenced by the input's <code>Transaction ID</code> and <code>Transaction Output Index</code> is known (booked) and unspent.</li>
<li>The transaction must spend the entire balance, i.e. the sum of the <code>Amount</code> fields of all the UTXOs referenced by inputs must match the sum of the <code>Amount</code> fields of all outputs.</li>
<li>Each unlock block must be valid with respect to the UTXO referenced by the input of the same index:
<ul>
<li>If it is a <em>Signature Unlock Block</em>:
<ul>
<li>The <code>Signature Type</code> must match the <code>Address Type</code> of the UTXO, </li>
<li>the BLAKE2b-256 hash of <code>Public Key</code> must match the <code>Address</code> of the UTXO and</li>
<li>the <code>Signature</code> field must contain a valid signature for <code>Public Key</code>.</li>
</ul>
</li>
<li>If it is a <em>Reference Unlock Block</em>, the referenced <em>Signature Unlock Block</em> must be valid with respect to the UTXO.</li>
</ul>
</li>
</ul>
<p>If a <em>Transaction Payload</em> passes the semantic validation, its referenced UTXOs must be marked as spent and its new outputs must be created/booked in the ledger. The <em>Message ID</em> of the message encapsulating the processed payload then also becomes part of the input for the White-Flag Merkle tree hash of the confirming milestone (<a href="tips/TIP-0007/../TIP-0004/tip-0004.html">TIP-4</a>).</p>
<p>Transactions that do not pass semantic validation are ignored. Their UTXOs are not marked as spent and their outputs are not booked in the ledger.</p>
<h2 id="miscellaneous"><a class="header" href="#miscellaneous">Miscellaneous</a></h2>
<h3 id="transaction-timestamps"><a class="header" href="#transaction-timestamps">Transaction timestamps</a></h3>
<p>Since transaction timestamps – whether they are signed or not – do not provide any guarantee of correctness, they have been left out of the <em>Transaction Payload</em>. Applications relying on some notion of time for transactions can use the local solidification time or the global timestamp of the confirming milestone (<a href="tips/TIP-0007/../TIP-0008/tip-0008.html">TIP-6</a>).</p>
<h3 id="address-reuse"><a class="header" href="#address-reuse">Address reuse</a></h3>
<p>While, in contrast to Winternitz one-time signatures (W-OTS), producing multiple Ed25519 signatures for the same private key and address does not decrease its security, it still drastically reduces the privacy of users. It is thus considered best practice that applications and services create a new address per deposit to circumvent these privacy issues.</p>
<p>In essence, Ed25519 support allows for smaller transaction sizes and to safely spend funds which were sent to an already used deposit address. Ed25519 addresses are not meant to be used like email addresses. See this <a href="https://en.bitcoin.it/wiki/Address_reuse">Bitcoin wiki article</a> for further information.</p>
<h1 id="drawbacks-4"><a class="header" href="#drawbacks-4">Drawbacks</a></h1>
<ul>
<li>The new transaction format is the core data type within the IOTA ecosystem. Changing it means that all projects need to accommodate it, including wallets, web services, client libraries and applications using IOTA in general. It is not possible to keep these changes backwards compatible, meaning that all nodes must upgrade to further participate in the network.</li>
<li>Additionally, local snapshots can no longer be represented by a list of addresses and their balances, since the ledger is now made up of the UTXOs on which the actual funds reside. Therefore, local snapshot file schemes have to be adjusted to incorporate the transaction hashes, output indices, and then the destination addresses including the balances.</li>
</ul>
<h1 id="rationale-and-alternatives-5"><a class="header" href="#rationale-and-alternatives-5">Rationale and alternatives</a></h1>
<ul>
<li>Introducing this new transaction structure allows for extensions in the future, to accommodate new requirements. With the support for Ed25519 addresses/signatures, transaction size is drastically reduced and allows for safe re-signing in case of address reuse. Due to the switch to a complete binary transaction, the transaction size is reduced even further, saving network bandwidth and processing time.</li>
<li>Other transaction structures have been considered but they would have misused existing transaction fields to accommodate for new features, instead of putting them into a proper descriptive structure. Additionally, those ideas would not have been safe against replay attacks, which deems reusing the old transaction structure, for example for Ed25519 addresses/signatures, as infeasible.</li>
<li>Not switching to the new transaction structure described in this RFC would have led to more people losing funds because of W-OTS address reuse and it would prevent extending the IOTA protocol further down the line.</li>
</ul>
<h1 id="copyright-6"><a class="header" href="#copyright-6">Copyright</a></h1>
<p>Copyright and related rights waived via <a href="https://creativecommons.org/publicdomain/zero/1.0/">CC0</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><pre>
tip: 8
title: Milestone Payload
description: Coordinator issued milestone structure with Ed25519 authentication
author: Angelo Capossele (@capossele) <angelo.capossele@iota.org>, Wolfgang Welz (@Wollac) <wolfgang.welz@iota.org>
discussions-to: https://github.com/iotaledger/tips/pull/19
status: Replaced
type: Standards
layer: Core
created: 2020-07-28
superseded-by: TIP-29
</pre>
<h1 id="summary-6"><a class="header" href="#summary-6">Summary</a></h1>
<p>In IOTA, nodes use the milestones issued by the Coordinator to reach a consensus on which transactions are confirmed. This RFC proposes a milestone payload for the messages described in the IOTA protocol <a href="tips/TIP-0008/../TIP-0006/tip-0006.html">TIP-6</a>. It uses Edwards-curve Digital Signature Algorithm (EdDSA) to authenticate the milestones.</p>
<h1 id="motivation-7"><a class="header" href="#motivation-7">Motivation</a></h1>
<p>In the current IOTA protocol, milestones are authenticated using a ternary Merkle signature scheme. In the Chrysalis update, ternary transactions are replaced with binary messages containing different payload types. In order to address these new requirements, this RFC proposes the use of a dedicated payload type for milestones. It contains the same essential data fields that were previously included in the milestone bundle. Additionally, this document also describes how Ed25519 signatures are used to assure authenticity of the issued milestones. In order to make the management and security of the used private keys easier, simple multisignature features with support for key rotation have been added.</p>
<h1 id="detailed-design-6"><a class="header" href="#detailed-design-6">Detailed design</a></h1>
<p>The <a href="https://tools.ietf.org/html/rfc7693">BLAKE2b-256</a> hash of the <em>Milestone Essence</em>, consisting of the actual milestone information (like its index number or position in the tangle), is signed using the Ed25519 signature scheme as described in the IRTF <a href="https://tools.ietf.org/html/rfc8032">RFC 8032</a>. It uses keys of 32 bytes, while the generated signatures are 64 bytes.</p>
<p>To increase the security of the design, a milestone can (optionally) be independently signed by multiple keys at once. These keys should be operated by detached signature provider services running on independent infrastructure elements. This assist in mitigating the risk of an attacker having access to all the key material necessary for forging milestones. While the Coordinator takes responsibility for forming Milestone Payload Messages, it delegates signing in to these providers through an ad-hoc RPC connector. Mutual authentication should be enforced between the Coordinator and the signature providers: a <a href="https://en.wikipedia.org/wiki/Transport_Layer_Security#Client-authenticated_TLS_handshake">client-authenticated TLS handshake</a> scheme is advisable. To increase the flexibility of the mechanism, nodes can be configured to require a quorum of valid signatures to consider a milestone as genuine.</p>
<p>In addition, a key rotation policy can also be enforced by limiting key validity to certain milestone intervals. Accordingly, nodes need to know which public keys are applicable for which milestone index. This can be provided by configuring a list of entries consisting of the following fields:</p>
<ul>
<li><em>Index Range</em> providing the interval of milestone indices for which this entry is valid. The interval must not overlap with any other entry.</li>
<li><em>Applicable Public Keys</em> defining the set of valid public keys.</li>
<li><em>Signature Threshold</em> specifying the minimum number of valid signatures. Must be at least one and not greater than the number of <em>Applicable Public Keys</em>.</li>
</ul>
<h2 id="structure-2"><a class="header" href="#structure-2">Structure</a></h2>
<p>The following table describes the entirety of a <em>Milestone Payload</em> in its serialized form following the notation from <a href="tips/TIP-0008/../TIP-0021/tip-0021.html">TIP-21</a>:</p>
<table>
  <tr>
    <th>Name</th>
    <th>Type</th>
    <th>Description</th>
  </tr>
  <tr>
    <td>Payload Type</td>
    <td>uint32</td>
    <td>Set to <strong>value 1</strong> to denote a <i>Milestone Payload</i>.</td>
  </tr>
  <tr>
    <td valign="top">Essence <code>oneOf</code></td>
    <td colspan="2">
      <details open="true">
        <summary>Milestone Essence</summary>
        <blockquote>Describes the signed part of a <i>Milestone Payload</i>.</blockquote>
        <table>
          <tr>
            <th>Name</th>
            <th>Type</th>
            <th>Description</th>
          </tr>
          <tr>
            <td>Index Number</td>
            <td>uint32</td>
            <td>The index number of the milestone.</td>
          </tr>
          <tr>
            <td>Timestamp</td>
            <td>uint64</td>
            <td>The Unix time (seconds since Unix epoch) at which the milestone was issued.</td>
          </tr>
          <tr>
            <td>Parents Count</td>
            <td>uint8</td>
            <td>The number of messages that are directly approved.</td>
          </tr>
          <tr>
            <td valign="top">Parents <code>anyOf</code></td>
            <td colspan="2">
              <details>
                <summary>Parent</summary>
                <blockquote>
                  References another directly approved message.
                </blockquote>
                <table>
                  <tr>
                    <th>Name</th>
                    <th>Type</th>
                    <th>Description</th>
                  </tr>
                  <tr>
                    <td>Message ID</td>
                    <td>ByteArray[32]</td>
                    <td>The Message ID of the parent.</td>
                  </tr>
                </table>
              </details>
            </td>
          </tr>
          <tr>
            <td>Inclusion Merkle Root</td>
            <td>ByteArray[32]</td>
            <td>The Merkle tree hash (BLAKE2b-256) of the message IDs of all the not-ignored state-mutating transaction payloads referenced by the milestone (<a href="https://iotaledger.github.io/protocol-rfcs/0012-milestone-merkle-validation/0012-milestone-merkle-validation.html">RFC-0012</a>).</td>
          </tr>
          <tr>
            <td>Next PoW Score</td>
            <td>uint32</td>
            <td>The new PoW score all messages should adhere to. If 0 then the PoW score should not change.</td>
          </tr>
          <tr>
            <td>Next PoW Score Milestone Index</td>
            <td>uint32</td>
            <td>The index of the first milestone that will require a new minimal pow score for applying transactions. This field comes into effect only if the <code>Next PoW Score</code> field is not 0.</td>
          </tr>
          <tr>
            <td>Keys Count</td>
            <td>uint8</td>
            <td>Number of public keys entries.</td>
          </tr>
          <tr>
            <td valign="top">Keys <code>anyOf</code></td>
            <td colspan="2">
              <details>
                <summary>Ed25519 Public Key</summary>
                <table>
                  <tr>
                    <th>Name</th>
                    <th>Type</th>
                    <th>Description</th>
                  </tr>
                  <tr>
                    <td>Public Key</td>
                    <td>ByteArray[32]</td>
                    <td>The public key of the Ed25519 keypair which is used to verify the correspondig signature.</td>
                  </tr>
                </table>
              </details>
            </td>
          </tr>
          <tr>
            <td>Payload Length</td>
            <td>uint32</td>
            <td>The length in bytes of the optional payload.</td>
          </tr>
          <tr>
            <td valign="top">Payload <code>optOneOf</code></td>
            <td colspan="2">
              <details>
                <summary>Generic Payload</summary>
                <blockquote>
                  An outline of a generic payload
                </blockquote>
                <table>
                  <tr>
                    <th>Name</th>
                    <th>Type</th>
                    <th>Description</th>
                  </tr>
                  <tr>
                    <td>Payload Type</td>
                    <td>uint32</td>
                    <td>
                      The type of the payload. It will instruct the node how to parse the fields that follow.
                    </td>
                  </tr>
                  <tr>
                    <td>Data Fields</td>
                    <td>ANY</td>
                    <td>A sequence of fields, where the structure depends on <code>Payload Type</code>.</td>
                  </tr>
                </table>
              </details>
            </td>
          </tr>
        </table>
      </details>
    </td>
  </tr>
  <tr>
    <td>Signatures Count</td>
    <td>uint8</td>
    <td>Number of signature entries. The number must match the field <code>Keys Count</code>.</td>
  </tr>
  <tr>
    <td valign="top">Signatures <code>anyOf</code></td>
    <td colspan="2">
      <details open="true">
        <summary>Raw Ed25519 Signature</summary>
        <table>
          <tr>
            <th>Name</th>
            <th>Type</th>
            <th>Description</th>
          </tr>
          <tr>
            <td>Signature</td>
            <td>ByteArray[64]</td>
            <td>The Ed25519 signature signing the BLAKE2b-256 hash of the serialized <i>Milestone Essence</i>. The signatures must be in the same order as the specified public keys.</td>
          </tr>
        </table>
      </details>
    </td>
  </tr>
</table>
<h2 id="generation"><a class="header" href="#generation">Generation</a></h2>
<ul>
<li>Generate a new <em>Milestone Essence</em> corresponding to the Coordinator milestone.</li>
<li>Transmit the serialized <em>Milestone Essence</em> to the corresponding number of signature service providers.
<ul>
<li>The signature provider service will sign the received serialized bytes as-is.</li>
<li>The signature provider will serialize the signature bytes and return them to the Coordinator.</li>
</ul>
</li>
<li>Fill the <code>Signatures</code> field of the milestone payload with the received signature bytes.</li>
<li>Generate a <em>Message</em> as defined in <a href="tips/TIP-0008/../TIP-0006/tip-0006.html">TIP-6</a> using the same <code>Parents</code> as in the created <em>Milestone Payload</em>.</li>
</ul>
<h2 id="syntactical-validation"><a class="header" href="#syntactical-validation">Syntactical validation</a></h2>
<ul>
<li><code>Parents</code> of the payload must match <code>Parents</code> of the encapsulating <em>Message</em>.</li>
<li>PoW score:
<ul>
<li>If <code>Next Pow Score</code> is zero, <code>Next PoW Score Milestone Index</code> must also be zero.</li>
<li>Otherwise <code>Next PoW Score Milestone Index</code> must be larger than <code>Index Number</code>.</li>
</ul>
</li>
<li>Keys:
<ul>
<li><code>Keys Count</code> must be at least the <em>Signature Threshold</em> and at most the number of <em>Applicable Public Keys</em> for the current milestone index.</li>
<li><code>Keys</code> must be sorted in lexicographical order.</li>
<li>Each <code>Public Key</code> must be unique.</li>
<li><code>Keys</code> must form a subset of the <em>Applicable Public Keys</em> for the current milestone index.</li>
</ul>
</li>
<li>Payload (if present):
<ul>
<li><code>Payload Type</code> must match one of the values described under <a href="tips/TIP-0008/tip-0008.html#payloads">Payloads</a>.</li>
<li><code>Data fields</code> must be correctly parsable in the context of the <code>Payload Type</code>.</li>
<li>The payload itself must pass syntactic validation.</li>
</ul>
</li>
<li>Signatures:
<ul>
<li><code>Signatures Count</code> must match <code>Keys Count</code>.</li>
<li><code>Signature</code> at index i must be valid with respect to the <code>Public Key</code> at the same index.</li>
</ul>
</li>
<li>Given the type and length information, the <em>Milestone Payload</em> must consume the entire byte array of the <code>Payload</code> field of the <em>Message</em>.</li>
</ul>
<h3 id="payloads-1"><a class="header" href="#payloads-1">Payloads</a></h3>
<p>The  <em>Milestone Payload</em> itself can contain another payload as described in general in <a href="tips/TIP-0008/../TIP-0006/tip-0006.html">TIP-6</a>. The following table lists all the payloads types that can be nested inside a <em>Milestone Payload</em> as well as links to the corresponding specification:</p>
<div class="table-wrapper"><table><thead><tr><th>Payload Name</th><th>Type Value</th><th>TIP</th></tr></thead><tbody>
<tr><td>Receipts</td><td>4</td><td><a href="tips/TIP-0008/../TIP-0015/tip-0015.html#receipts">TIP-15</a></td></tr>
</tbody></table>
</div>
<h1 id="rationale-and-alternatives-6"><a class="header" href="#rationale-and-alternatives-6">Rationale and alternatives</a></h1>
<ul>
<li>Instead of using EdDSA we could have chosen ECDSA. Both algorithms are well supported and widespread. However, signing with ECDSA requires fresh randomness while EdDSA does not. Especially in the case of milestones where essences are signed many times using the same key, this is a crucial property.</li>
<li>Due to the layered design of messages and payloads, it is practically not possible to prevent reattachments of <em>Milestone Payloads</em>. Hence, this payload has been designed in a way to be independent from the message it is contained in. A milestone should be considered as a virtual marker (referencing <code>Parents</code>) rather than an actual message in the Tangle. This concept is compatible with reattachments and supports a cleaner separation of the message layers.</li>
<li>Forcing matching <code>Parents</code> in the <em>Milestone Payload</em> and its <em>Message</em> makes it impossible to reattach the same payload at different positions in the Tangle. This does not prevent reattachments in general (a different, valid <code>Nonce</code>, for example would lead to a new Message ID) and it violates a strict separation of payload and message. However, it simplifies milestone processing as the position of the <em>Message</em> will be the same as the possition encoded in the <em>Milestone Payload</em>. Having this clear structural properties seem to be more desirable than a strict separation of layers.</li>
</ul>
<h1 id="copyright-7"><a class="header" href="#copyright-7">Copyright</a></h1>
<p>Copyright and related rights waived via <a href="https://creativecommons.org/publicdomain/zero/1.0/">CC0</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><pre>
tip: 9
title: Local Snapshot File Format
description: File format to export/import ledger state 
author: Luca Moser (@luca-moser) <luca.moser@iota.org>
discussions-to: https://github.com/iotaledger/tips/pull/25
status: Replaced
type: Standards
layer: Interface
created: 2020-08-25
superseded-by: TIP-35
</pre>
<h1 id="summary-7"><a class="header" href="#summary-7">Summary</a></h1>
<p>This RFC defines a file format for local snapshots which is compatible with Chrysalis Phase 2.</p>
<h1 id="motivation-8"><a class="header" href="#motivation-8">Motivation</a></h1>
<p>Nodes create local snapshots to produce ledger representations at a point in time of a given milestone to be able to:</p>
<ul>
<li>Start up from a recent milestone instead of having to synchronize from the genesis transaction.</li>
<li>Delete old transaction data below a given milestone.</li>
</ul>
<p>Current node implementations use a <a href="https://github.com/iotaledger/iri-ls-sa-merger/tree/351020d3b5e342b6e9a41f2868575ab7ff8c251c#generating-an-export-file-from-a-localsnapshots-db">local snapshot file format</a> which only works with account based ledgers. For Chrysalis Phase 2, this file format has to be assimilated to support a
UTXO based ledger.</p>
<h1 id="detailed-design-7"><a class="header" href="#detailed-design-7">Detailed design</a></h1>
<p>Since a UTXO based ledger is much larger in size, this RFC proposes two formats for snapshot files:</p>
<ul>
<li>A <code>full</code> format which represents a complete ledger state.</li>
<li>A <code>delta</code> format which only contains diffs (created and consumed outputs) of milestones from a given milestone index onwards.</li>
</ul>
<p>This separation allows nodes to swiftly create new delta snapshot files, which then can be distributed with a companion full snapshot file to reconstruct a recent state.</p>
<p>Unlike the current format, these new formats do not include spent addresses since this information is no longer held by nodes.</p>
<h3 id="formats"><a class="header" href="#formats">Formats</a></h3>
<blockquote>
<p>All types are serialized in little-endian</p>
</blockquote>
<h4 id="full-ledger-state"><a class="header" href="#full-ledger-state">Full Ledger State</a></h4>
<p>A full ledger snapshot file contains the UTXOs (<code>outputs</code> section) of a node's confirmed
milestone (<code>ledger_milestone_index</code>). The <code>diffs</code> contain the diffs to rollback the <code>outputs</code> state to regain the ledger state of the snapshot milestone at (<code>seps_milestone_index</code>).</p>
<p><img src="tips/TIP-0009/diffs_1.png" alt="" /></p>
<p>While the node producing such a full ledger state snapshot could theoretically pre-compute the actual snapshot milestone state, this is deferred to the consumer of the data to speed up local snapshot creation.</p>
<h4 id="delta-ledger-state"><a class="header" href="#delta-ledger-state">Delta Ledger State</a></h4>
<p>A delta ledger state local snapshot only contains the <code>diffs</code> of milestones starting from a
given <code>ledger_milestone_index</code>. A node consuming such data must know the state of the ledger at <code>ledger_milestone_index</code>.</p>
<p><img src="tips/TIP-0009/diffs_2.png" alt="" /></p>
<h4 id="schema"><a class="header" href="#schema">Schema</a></h4>
<h5 id="output"><a class="header" href="#output">Output</a></h5>
<p>Defines an output.</p>
<table>
    <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
    </tr>
    <tr>
        <td>Message Hash</td>
        <td>Array&lt;byte&gt;[32]</td>
        <td>The hash of the message in which the transaction was contained which generated this output.</td>
    </tr>
    <tr>
        <td>Transaction hash</td>
        <td>Array&lt;byte&gt;[32]</td>
        <td>The hash of the transaction which generated this output.</td>
    </tr>
    <tr>
        <td>Output index</td>
        <td>uint16</td>
        <td>The index of this output within the transaction.</td>
    </tr>
    <tr>
        <td valign="top">Output <code>oneOf</code></td>
        <td colspan="2">
            <details>
                <summary>SigLockedSingleDeposit</summary>
                <table>
                    <tr>
                        <td><b>Name</b></td>
                        <td><b>Type</b></td>
                        <td><b>Description</b></td>
                    </tr>
                    <tr>
                        <td>Output Type</td>
                        <td>byte</td>
                        <td>Set to <strong>value 0</strong> to denote a <i>SigLockedSingleDeposit</i>.</td>
                    </tr>
                    <tr>
                        <td valign="top">Address <code>oneOf</code></td>
                        <td colspan="2">
                            <details>
                                <summary>Ed25519 Address</summary>
                                <table>
                                    <tr>
                                        <td><b>Name</b></td>
                                        <td><b>Type</b></td>
                                        <td><b>Description</b></td>
                                    </tr>
                                    <tr>
                                        <td>Address Type</td>
                                        <td>byte/varint</td>
                                        <td>Set to <strong>value 0</strong> to denote an <i>Ed25519 Address</i>.</td>
                                    </tr>
                                    <tr>
                                        <td>Address</td>
                                        <td>ByteArray[32]</td>
                                        <td>The raw bytes of the Ed25519 address which is a BLAKE2b-256 hash of the Ed25519 public key.</td>
                                    </tr>
                                </table>
                            </details>
                        </td>
                    </tr>
                    <tr>
                        <td>Amount</td>
                        <td>uint64</td>
                        <td>The amount of tokens this output deposits.</td>
                    </tr>
                </table>
            </details>
            <details>                                 
                <summary>SigLockedDustAllowanceDeposit</summary>
                <table>
                    <tr>
                        <td><b>Name</b></td>
                        <td><b>Type</b></td>
                        <td><b>Description</b></td>
                    </tr>
                    <tr>
                        <td>Output Type</td>
                        <td>byte</td>
                        <td>Set to <strong>value 1</strong> to denote a <i>SigLockedDustAllowanceDeposit</i>.</td>
                    </tr>
                    <tr>
                        <td valign="top">Address <code>oneOf</code></td>
                        <td colspan="2">
                            <details>
                                <summary>Ed25519 Address</summary>
                                <table>
                                    <tr>
                                        <td><b>Name</b></td>
                                        <td><b>Type</b></td>
                                        <td><b>Description</b></td>
                                    </tr>
                                    <tr>
                                        <td>Address Type</td>
                                        <td>byte/varint</td>
                                        <td>Set to <strong>value 0</strong> to denote an <i>Ed25519 Address</i>.</td>
                                    </tr>
                                    <tr>
                                        <td>Address</td>
                                        <td>ByteArray[32]</td>
                                        <td>The raw bytes of the Ed25519 address which is a BLAKE2b-256 hash of the Ed25519 public key.</td>
                                    </tr>
                                </table>
                            </details>
                        </td>
                    </tr>
                    <tr>
                        <td>Amount</td>
                        <td>uint64</td>
                        <td>The amount of tokens this output deposits.</td>
                    </tr>
                </table>
            </details>
        </td>
    </tr>
</table>
<h5 id="milestone-diff"><a class="header" href="#milestone-diff">Milestone Diff</a></h5>
<p>Defines the diff a milestone produced by listing the created/consumed outputs and the milestone payload itself.</p>
<table>
    <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
    </tr>
    <tr>
        <td>Milestone Payload length</td>
        <td>uint32</td>
        <td>Denotes the length of the milestone payload.</td>
    </tr>
    <tr>
        <td>Milestone Payload</td>
        <td>Array&lt;byte&gt;[Milestone Payload length]</td>
        <td>The milestone payload in its serialized binary form.</td>
    </tr>
    <tr>
        <td>
            Treasury Input
            <blockquote>
                only included if milestone contains a receipt
            </blockquote>
        </td>
        <td colspan="2">
            <table>
                <tr>
                    <th>Name</th>
                    <th>Type</th>
                    <th>Description</th>
                </tr>
                <tr>
                    <td>Treasury Input Milestone Hash</td>
                    <td>Array&lt;byte&gt;[32]</td>
                    <td>The hash of the milestone this input references.</td>
                </tr>
                <tr>
                    <td>Treasury Input Amount</td>
                    <td>uint64</td>
                    <td>The amount of this treasury input.</td>
                </tr>
            </table>
        </td>
    </tr>
    <tr>
        <td>Created Outputs Count</td>
        <td>uint64</td>
        <td>The amount of outputs generated with this milestone diff.</td>
    </tr>
    <tr>
        <td valign="top">Created Outputs <code>anyOf</code></td>
        <td colspan="2">
            <details>
                <summary>Output</summary>
            </details>
        </td>
    </tr>
    <tr>
        <td>Consumed Outputs Count</td>
        <td>uint64</td>
        <td>The amount of outputs consumed with this milestone diff.</td>
    </tr>
    <tr>
        <td valign="top">Consumed Outputs <code>anyOf</code></td>
        <td colspan="2">
            <details>
                <summary>Output</summary>
            </details>
        </td>
    </tr>
</table>
<h5 id="full-snapshot-file-format"><a class="header" href="#full-snapshot-file-format">Full snapshot file format</a></h5>
<p>Defines what a full snapshot file contains.</p>
<table>
    <tr>
        <td><b>Name</b></td>
        <td><b>Type</b></td>
        <td><b>Description</b></td>
    </tr>
    <tr>
        <td>Version</td>
        <td>byte</td>
        <td>Denotes the version of this file format.</td>
    </tr>
    <tr>
        <td>Type</td>
        <td>byte</td>
        <td>Denotes the type of this file format. <b>Value 0</b> denotes a full snapshot.</td>
    </tr>
    <tr>
        <td>Timestamp</td>
        <td>uint64</td>
        <td>The UNIX timestamp in seconds of when this snapshot was produced.</td>
    </tr>
    <tr>
        <td>Network ID</td>
        <td>uint64</td>
        <td>The ID of the network to which this snapshot is compatible.</td>
    </tr>
    <tr>
        <td>SEPs milestone index</td>
        <td>uint64</td>
        <td>The milestone index for which the SEPs were generated for.</td>
    </tr>
    <tr>
        <td>Ledger milestone index</td>
        <td>uint64</td>
        <td>The milestone index of which the UTXOs within the snapshot are from.</td>
    </tr>
    <tr>
        <td>SEPs count</td>
        <td>uint64</td>
        <td>The amount of SEPs contained within this snapshot.</td>
    </tr>
    <tr>
        <td>Outputs count</td>
        <td>uint64</td>
        <td>The amount of UTXOs contained within this snapshot.</td>
    </tr>
    <tr>
        <td>Milestone diffs count</td>
        <td>uint64</td>
        <td>The amount of milestone diffs contained within this snapshot.</td>
    </tr>
    <tr>
        <td>Treasury Output Milestone Hash</td>
        <td>Array&lt;byte&gt;[32]</td>
        <td>The milestone hash of the milestone which generated the treasury output.</td>
    </tr>
    <tr>
        <td>Treasury Output Amount</td>
        <td>uint64</td>
        <td>The amount of funds residing on the treasury output.</td>
    </tr>
    <tr>
        <td valign="top">SEPs</td>
        <td colspan="2">
            <details>
                <summary>SEP Array&lt;byte&gt;[32]</summary>
            </details>
        </td>
    </tr>
    <tr>
        <td valign="top">Outputs</td>
        <td colspan="2">
            <details>
                <summary>Output</summary>
            </details>
        </td>
    </tr>
    <tr>
        <td valign="top">Milestone Diffs</td>
        <td colspan="2">
            <details>
                <summary>Milestone Diff</summary>
            </details>
        </td>
    </tr>
</table>
<h5 id="delta-snapshot-file-format"><a class="header" href="#delta-snapshot-file-format">Delta snapshot file format</a></h5>
<p>Defines what a delta snapshot contains.</p>
<table>
    <tr>
        <td><b>Name</b></td>
        <td><b>Type</b></td>
        <td><b>Description</b></td>
    </tr>
    <tr>
        <td>Version</td>
        <td>byte</td>
        <td>Denotes the version of this file format.</td>
    </tr>
    <tr>
        <td>Type</td>
        <td>byte</td>
        <td>Denotes the type of this file format. <b>Value 1</b> denotes a delta snapshot.</td>
    </tr>
    <tr>
        <td>Timestamp</td>
        <td>uint64</td>
        <td>The UNIX timestamp in seconds of when this snapshot was produced.</td>
    </tr>
    <tr>
        <td>Network ID</td>
        <td>uint64</td>
        <td>The ID of the network to which this snapshot is compatible.</td>
    </tr>
    <tr>
        <td>SEPs milestone index</td>
        <td>uint64</td>
        <td>The milestone index for which the SEPs were generated for.</td>
    </tr>
    <tr>
        <td>Ledger milestone index</td>
        <td>uint64</td>
        <td>The milestone index up on which this delta snapshot builts up from.</td>
    </tr>
    <tr>
        <td>SEPs count</td>
        <td>uint64</td>
        <td>The amount of SEPs contained within this snapshot.</td>
    </tr>
    <tr>
        <td>Milestone diffs count</td>
        <td>uint64</td>
        <td>The amount of milestone diffs contained within this snapshot.</td>
    </tr>
    <tr>
        <td valign="top">SEPs</td>
        <td colspan="2">
            <details>
                <summary>SEP Array&lt;byte&gt;[32]</summary>
            </details>
        </td>
    </tr>
    <tr>
        <td valign="top">Milestone Diffs</td>
        <td colspan="2">
            <details>
                <summary>Milestone Diff</summary>
            </details>
        </td>
    </tr>
</table>
<h1 id="drawbacks-5"><a class="header" href="#drawbacks-5">Drawbacks</a></h1>
<p>Nodes need to support this new format.</p>
<h1 id="rationale-and-alternatives-7"><a class="header" href="#rationale-and-alternatives-7">Rationale and alternatives</a></h1>
<ul>
<li>In conjunction with a companion full snapshot, a tool or node can &quot;truncate&quot; the data from a delta snapshot back to a single full snapshot. In that case, the <code>ledger_milestone_index</code> and <code>seps_milestone_index</code> would be the same. In the example above, given the full and delta snapshots, one could produce a new full snapshot for milestone 1350.</li>
<li>Since snapshots may include millions of UTXOs, code generating such files needs to stream data directly onto disk instead of keeping the entire representation in memory. In order to facilitate this, the count denotations for SEPs, UTXOs and diffs are at the beginning of the file. This allows code generating snapshot files to only have to seek back once after the actual count of elements is known.</li>
</ul>
<h1 id="unresolved-questions-2"><a class="header" href="#unresolved-questions-2">Unresolved questions</a></h1>
<ul>
<li>Is all the information to startup a node from the local snapshot available with the described format?</li>
</ul>
<h1 id="copyright-8"><a class="header" href="#copyright-8">Copyright</a></h1>
<p>Copyright and related rights waived via <a href="https://creativecommons.org/publicdomain/zero/1.0/">CC0</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><pre>
tip: 10
title: Mnemonic Ternary Seed
description: Represent ternary seed as a mnemonic sentence
author: Wolfgang Welz (@Wollac) <wolfgang.welz@iota.org>
discussions-to: https://github.com/iotaledger/tips/pull/10
status: Obsolete
type: Standards
layer: IRC
created: 2020-03-11
</pre>
<h1 id="summary-8"><a class="header" href="#summary-8">Summary</a></h1>
<p>The IOTA protocol uses a 81-tryte seed to derive all the private keys for one account. This RFC describes a method to represent that seed as a mnemonic sentence - a group of easily comprehensible words. </p>
<h1 id="motivation-9"><a class="header" href="#motivation-9">Motivation</a></h1>
<p>The used seed is a 384-bit or 243-trit random string. There are several ways to represent this in a human-readable form, but a mnemonic sentence is superior to raw binary or ternary strings. These sentences can easily be written down or they can even be recorded  over a phone.
Furthermore, having raw strings tempts the user to copy and paste the seed due to convenience over security. This practice opens new attack vectors such as theft or manipulation of the string in the clipboard.</p>
<h1 id="detailed-design-8"><a class="header" href="#detailed-design-8">Detailed design</a></h1>
<p>The <a href="https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki">BIP-0039</a> specification exactly describes an implementation for its use case and how to uniquely represent binary entropy using mnemonic words. However, it is only defined for binary input of 128 - 256 bits. The section(s) below describe the canonical extension of BIP-0039 for longer inputs of 81 trytes or 384 bits.</p>
<p>The 243-trit (81-tryte) seed is used as input for the <a href="https://github.com/iotaledger/kerl/blob/master/IOTA-Kerl-spec.md">Kerl</a> hash function to derive the private keys. Therefore, it is first converted to a 384-bit string to be absorbed by <a href="https://keccak.team/keccak.html">Keccak-384</a>. As the set of all possible 243-trit strings is larger than the set of 384-bit strings, the most significant trit is fixed to zero before converting. This means that the 243rd of the seed is ignored and does not have any impact on the following key derivation and does not need to be considered for the encoding.</p>
<h3 id="generating-the-mnemonic-from-seed"><a class="header" href="#generating-the-mnemonic-from-seed">Generating the mnemonic from seed</a></h3>
<ul>
<li>Interpret the IOTA seed as a little-endian 243-trit balanced ternary integer; assure that its most significant trit is 0 and encode the number as a 384-bit signed integer in big-endian two's complement representation. <a href="https://github.com/iotaledger/kerl/blob/master/IOTA-Kerl-spec.md#trits---bytes-encoding">This exact conversion</a> is also used as part of the current Kerl hash function.</li>
<li>Compute the <a href="https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf">SHA-256</a> hash of the resulting bit string and use its first 384/32=12 bits as the checksum.</li>
<li>The 12-bit checksum is appended to the end of the initial result, making it a 396-bit string.</li>
<li>These concatenated bits are split into 36 groups of 11 bits, each encoding a number from 0-2047, corresponding to an index into the wordlist.</li>
<li>Finally, convert these numbers into words from any one of the <a href="https://github.com/bitcoin/bips/blob/master/bip-0039/bip-0039-wordlists.md">BIP-0039 wordlists</a> and use the joined words as a mnemonic sentence.</li>
</ul>
<h3 id="generating-the-seed-from-mnemonic"><a class="header" href="#generating-the-seed-from-mnemonic">Generating the seed from mnemonic</a></h3>
<ul>
<li>Convert the 36-word mnemonic sentence into its corresponding 396-bit string by taking the 11-bit wordlist index for each word and concatenating all the bits.</li>
<li>Split the resulting bit string into 384-bit entropy and 12-bit checksum.</li>
<li>Verify that the checksum corresponds to the first bits of the SHA-256 hash of the entropy.</li>
<li>Convert the 384-bit entropy, interpreted as a signed integer in big-endian two's complement representation, back to a little-endian 243-trit balanced ternary integer. (The most significant trit will always be zero.) This corresponds to the usual 243-trit or 81-tryte IOTA seed.</li>
</ul>
<h2 id="examples-1"><a class="header" href="#examples-1">Examples</a></h2>
<ul>
<li>Using the <a href="https://github.com/bitcoin/bips/blob/master/bip-0039/english.txt">English word list</a>:
<ul>
<li>IOTA seed (81-tryte): <code>TLEV9HDTGZOXIIGA9DZG9VAKAIUZKNIMAFUGGARTWPOGDLLVUFZZVAABXRMFPWJAYWBBHOERV9EZBAOJD</code></li>
<li>mnemonic (36-word): <code>forget small borrow baby wing law monkey fiber jealous canyon melt all order lift now fish mind index neither discover divert fit curtain raw wealth arrow frozen plug catalog public winner emerge pulse mixture cry arch</code></li>
</ul>
</li>
<li>Using the <a href="https://github.com/bitcoin/bips/blob/master/bip-0039/japanese.txt">Japanese word list</a>:
<ul>
<li>IOTA seed (81-tryte): <code>KMQDKKLGGTPUBRJXYWLMQOIA9WIEWUAAJPASYPVAWOTYYH9JESDKPLVZIWITHDIUMLFEWQUQ9LHAV9GHC</code></li>
<li>mnemonic (36-word): <code>げどく　まもる　してい　ていへん　つめたい　ちつじょ　だいたい　てうち　まいにち　さゆう　よそく　がはく　ねらう　いちおう　くみあわせ　ふいうち　せつでん　きせい　すべて　きひん　しかい　さぎょう　うけたまわる　つとめる　おんしゃ　きかい　なやむ　たいせつ　うんこう　むすめ　いってい　ふめつ　そとづら　つくね　おいこす　ききて</code></li>
</ul>
</li>
</ul>
<h1 id="drawbacks-6"><a class="header" href="#drawbacks-6">Drawbacks</a></h1>
<ul>
<li>This RFC describes a way to represent computer-generated randomness in a human-readable transcription. It is in no way meant to process user created sentences into a binary key. This technique is also sometimes called a &quot;brain wallet&quot; and must not be confused with these mnemonics. </li>
<li>The mnemonics only encode 384 bits of entropy which only covers 242 trits. The 243rd trit will <em>not</em> be encoded and always padded with 0. This is fine, when Kerl is used to derive the private keys, since the Kerl hash function only works on the first 242 trits itself. However, other - currently not used - key derivation functions relying on the full 243-trit entropy are <em>not</em> compatible with this RFC.</li>
</ul>
<h1 id="rationale-and-alternatives-8"><a class="header" href="#rationale-and-alternatives-8">Rationale and alternatives</a></h1>
<ul>
<li>BIP-0039 provides an industry standard to present computer generated, secure entropy in a way that can be &quot;processed&quot; by humans in a much less error-prone way. The word lists are chosen in a way to reduce ambiguity, as such, typos can either be autocorrected or corrected with the help of a dictionary. This is in contrast to a raw ternary (or binary) representation, where typos automatically lead to a completely new seed, changing and breaking all successive private keys.</li>
<li>Thanks to the integrated 12-bit checksum, it is even possible to detect whether one or more words have been exchanged completely.</li>
<li>Presenting the user with a tryte or hex string will lead to situations in which the seed is copied into a text file, while human-readable words encourage the user to copy them on a piece of paper.</li>
</ul>
<h1 id="unresolved-questions-3"><a class="header" href="#unresolved-questions-3">Unresolved questions</a></h1>
<ul>
<li>This RFC does not cover usability aspects of entering mnemonics. Forcing the user to enter a mnemonic sentence and then discarding the input, due to one easily correctable typo in one word, would almost be as frustrating as typing a tryte string. Therefore, this must be combined with different usability improvements, e.g. only allowing entering characters that lead to valid words or fixing the word as soon as it can be unambiguously identified.</li>
<li>The BIP-0039 specification includes several word lists for different languages. Should these word lists be allowed or is it sufficient to only use the English list? </li>
<li>The BIP-0039 specification only considers entropy between 128 and 256 bits, while this RFC extends it in an analogue way for 384 bits. Is it also relevant for certain use cases to extend this for 512 bits (or even longer)?</li>
</ul>
<h1 id="reference-implementation-2"><a class="header" href="#reference-implementation-2">Reference implementation</a></h1>
<p>Example Go implementation in <a href="https://github.com/Wollac/iota-crypto-demo">wollac/iota-crypto-demo</a>:</p>
<ul>
<li>Conversion from mnemonic to seed: <a href="https://github.com/Wollac/iota-crypto-demo/blob/master/pkg/bip39/bip39.go">pkg/bip39/bip39.go</a></li>
<li>Example: <a href="https://github.com/Wollac/iota-crypto-demo/tree/master/examples/mnemseed">examples/mnemseed</a></li>
</ul>
<h1 id="copyright-9"><a class="header" href="#copyright-9">Copyright</a></h1>
<p>Copyright and related rights waived via <a href="https://creativecommons.org/publicdomain/zero/1.0/">CC0</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><pre>
tip: 11
title: Bech32 Address Format
description: Extendable address format supporting various signature schemes and address types
author: Wolfgang Welz (@Wollac) <wolfgang.welz@iota.org>
discussions-to: https://github.com/iotaledger/tips/pull/20
status: Replaced
type: Standards
layer: Interface
created: 2020-07-28
superseded-by: TIP-31
</pre>
<h1 id="summary-9"><a class="header" href="#summary-9">Summary</a></h1>
<p>This document proposes an extendable address format for the IOTA protocol supporting various signature schemes and address types. It relies on the <a href="https://github.com/bitcoin/bips/blob/master/bip-0173.mediawiki">Bech32</a> format to provide a compact, human-readable encoding with strong error correction guarantees.</p>
<h1 id="motivation-10"><a class="header" href="#motivation-10">Motivation</a></h1>
<p>With <a href="https://roadmap.iota.org/chrysalis">Chrysalis</a>, IOTA uses Ed25519 to generate digital signatures, in which addresses correspond to a BLAKE2b-256 hash. It is necessary to define a new universal and extendable address format capable of encoding different types of addresses.</p>
<p>The current IOTA protocol relies on Base27 addresses with a truncated Kerl checksum. However, both the character set and the checksum algorithm have limitations: </p>
<ul>
<li>Base27 is designed for ternary and is ill-suited for binary data.</li>
<li>The Kerl hash function also requires ternary input. Further, it is slow and provides no error-detection guarantees.</li>
<li>It does not support the addition of version or type information to distinguish between different kinds of addresses with the same length.</li>
</ul>
<p>All of these points are addressed in the Bech32 format introduced in <a href="https://github.com/bitcoin/bips/blob/master/bip-0173.mediawiki">BIP-0173</a>: In addition to the usage of the human-friendly Base32 encoding with an optimized character set, it implements a <a href="https://en.wikipedia.org/wiki/BCH_code">BCH code</a> that <em>guarantees detection</em> of any error affecting at most four characters and has less than a 1 in 10<sup>9</sup> chance of failing to detect more errors.</p>
<p>This RFC proposes a simple and extendable binary serialization for addresses of different types that is then Bech32 encoded to provide a unique appearance for human-facing applications such as wallets. </p>
<h1 id="detailed-design-9"><a class="header" href="#detailed-design-9">Detailed design</a></h1>
<h2 id="binary-serialization"><a class="header" href="#binary-serialization">Binary serialization</a></h2>
<p>The address format uses a simple serialization scheme which consists of two parts:</p>
<ul>
<li>The first byte describes the type of the address.</li>
<li>The remaining bytes contain the type-specific raw address bytes.</li>
</ul>
<p>Currently, only one kind of addresses are supported:</p>
<ul>
<li>Ed25519, where the address consists of the BLAKE2b-256 hash of the Ed25519 public key.</li>
</ul>
<p>They are serialized as follows:</p>
<div class="table-wrapper"><table><thead><tr><th>Type</th><th>First byte</th><th>Address bytes</th></tr></thead><tbody>
<tr><td>Ed25519</td><td><code>0x00</code></td><td>32 bytes: The BLAKE2b-256 hash of the Ed25519 public key.</td></tr>
</tbody></table>
</div>
<h2 id="bech32-for-human-readable-encoding"><a class="header" href="#bech32-for-human-readable-encoding">Bech32 for human-readable encoding</a></h2>
<p>The human-readable encoding of the address is Bech32 (as described in <a href="https://github.com/bitcoin/bips/blob/master/bip-0173.mediawiki">BIP-0173</a>). A Bech32 string is at most 90 characters long and consists of: </p>
<ul>
<li>The <strong>human-readable part</strong> (HRP), which conveys the IOTA protocol and distinguishes between Mainnet (the IOTA token) and Testnet (testing version):
<ul>
<li><code>iota</code> is the human-readable part for Mainnet addresses</li>
<li><code>atoi</code> is the human-readable part for Testnet addresses</li>
</ul>
</li>
<li>The <strong>separator</strong>, which is always <code>1</code>.</li>
<li>The <strong>data part</strong>, which consists of the Base32 encoded serialized address and the 6-character checksum.</li>
</ul>
<p>Hence, Ed25519-based addresses will result in a Bech32 string of 64 characters.</p>
<h2 id="examples-2"><a class="header" href="#examples-2">Examples</a></h2>
<ul>
<li><strong>Mainnet</strong>
<ul>
<li>Ed25519 compressed public key (32-byte): <code>6f1581709bb7b1ef030d210db18e3b0ba1c776fba65d8cdaad05415142d189f8</code>
<ul>
<li>BLAKE2b-256 hash (32-byte): <code>efdc112efe262b304bcf379b26c31bad029f616ee3ec4aa6345a366e4c9e43a3</code> </li>
<li>serialized (33-byte): <code>00efdc112efe262b304bcf379b26c31bad029f616ee3ec4aa6345a366e4c9e43a3</code></li>
<li>Bech32 string: <code>iota1qrhacyfwlcnzkvzteumekfkrrwks98mpdm37cj4xx3drvmjvnep6xqgyzyx</code></li>
</ul>
</li>
</ul>
</li>
<li><strong>Testnet</strong>
<ul>
<li>Ed25519 compressed public key (32-byte): <code>6f1581709bb7b1ef030d210db18e3b0ba1c776fba65d8cdaad05415142d189f8</code>
<ul>
<li>BLAKE2b-256 hash (32-byte): <code>efdc112efe262b304bcf379b26c31bad029f616ee3ec4aa6345a366e4c9e43a3</code> </li>
<li>serialized (33-byte): <code>00efdc112efe262b304bcf379b26c31bad029f616ee3ec4aa6345a366e4c9e43a3</code></li>
<li>Bech32 string: <code>atoi1qrhacyfwlcnzkvzteumekfkrrwks98mpdm37cj4xx3drvmjvnep6x8x4r7t</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="drawbacks-7"><a class="header" href="#drawbacks-7">Drawbacks</a></h1>
<ul>
<li>The new addresses look fundamentally different from the established 81-tryte IOTA addresses. However, since the switch from binary to ternary and Chrysalis in general is a substantial change, this is a very reasonable and desired consequence.</li>
<li>A four character HRP plus one type byte only leaves a maximum of 48 bytes for the actual address. </li>
</ul>
<h1 id="rationale-and-alternatives-9"><a class="header" href="#rationale-and-alternatives-9">Rationale and alternatives</a></h1>
<ul>
<li>There are several ways to convert the binary serialization into a human-readable format, e.g. Base58 or hexadecimal. The Bech32 format, however, offers the best compromise between compactness and error correction guarantees. A more detailed motivation can be found in <a href="https://github.com/bitcoin/bips/blob/master/bip-0173.mediawiki#motivation">BIP-0173 Motivation</a>.</li>
<li>The binary serialization itself must be as compact as possible while still allowing you to distinguish between different address types of the same byte length. As such, the introduction of a version byte offers support for up to 256 different kinds of addresses at only the cost of one single byte.</li>
<li>The HRP of the Bech32 string offers a good opportunity to clearly distinguish IOTA addresses from other Bech32 encoded data. Here, any three or four character ASCII strings can be used. However, selecting <code>iota</code> as well as <code>atoi</code> seems like the most recognizable option.</li>
</ul>
<h1 id="reference-implementation-3"><a class="header" href="#reference-implementation-3">Reference implementation</a></h1>
<p>Example Go implementation in <a href="https://github.com/Wollac/iota-crypto-demo">wollac/iota-crypto-demo</a>:</p>
<ul>
<li>Bech32 encoding: <a href="https://github.com/Wollac/iota-crypto-demo/tree/master/pkg/bech32">pkg/bech32</a></li>
<li>Example: <a href="https://github.com/Wollac/iota-crypto-demo/tree/master/examples/bech32">examples/bech32</a></li>
</ul>
<h1 id="copyright-10"><a class="header" href="#copyright-10">Copyright</a></h1>
<p>Copyright and related rights waived via <a href="https://creativecommons.org/publicdomain/zero/1.0/">CC0</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><pre>
tip: 12
title: Message PoW
description: Define message proof-of-work as a means to rate-limit the network
author: Wolfgang Welz (@Wollac) <wolfgang.welz@iota.org>
discussions-to: https://github.com/iotaledger/tips/pull/24
status: Active
type: Standards
layer: Core
created: 2020-08-25
</pre>
<h1 id="summary-10"><a class="header" href="#summary-10">Summary</a></h1>
<p>The IOTA protocol uses proof-of-work as a means to rate-limit the network. Currently, the Curl-P-81 trinary hash function is used and is required to provide a hash with the matching number of trailing zero trits to issue a transaction to the Tangle. With <a href="https://roadmap.iota.org/chrysalis">Chrysalis</a>, it will be possible to issue binary messages of arbitrary size. This RFC presents a proposal to adapt the existing PoW mechanism to these new requirements. It aims to be less disruptive to the current PoW mechanism as possible.</p>
<h1 id="motivation-11"><a class="header" href="#motivation-11">Motivation</a></h1>
<p>In the current IOTA Protocol, each transaction has a fixed size of 8019 trits and is hashed using Curl-P-81 to compute its 243-trit transaction hash, where the PoW's difficulty equals the number of trailing zero trits in that hash.<br/>
Unfortunately, the performance of Curl-P-81 is slow, achieving only about 2 MB/s on a single core. This would make the PoW validation a bottleneck, especially for high usage scenarios with larger messages. Thus, this RFC proposes a two-stage approach to speed up the validation process: First, the <a href="https://tools.ietf.org/html/rfc7693">BLAKE2b-256</a> hash function is used to create a short, fixed length digest of the message. Then, this digest, together with the nonce, is hashed using Curl-P-81. Since the digest only needs to be computed once while iterating over different nonce values, this preserves Curl as the PoW-relevant hash. However, the validation is much faster, as BLAKE2b-256 has a performance of about 1 GB/s and Curl then only needs to be executed for one single 243-trit block of input. Since the input of the final Curl computation is always fixed, parallel Curl variants can be used in this stage to further speed up the validation if necessary.<br/>
Furthermore, it is important to note that the time required to do the PoW depends on the PoW difficulty and not on the message length. As such, to treat messages with different lengths differently, we need to weight the PoW difficulty by the message length.</p>
<p>It will be easy to adapt existing hardware and software implementations of the current PoW mechanism to work with the proposed design. Only the input and the position of the nonce in the buffer needs to be adapted. This enables existing Curl projects to continue persisting and also the entire PoW landscape should stay almost the same.</p>
<h1 id="detailed-design-10"><a class="header" href="#detailed-design-10">Detailed design</a></h1>
<p>The PoW score is defined as the average number of iterations required to find the number of trailing zero trits in the hash divided by the message size.</p>
<p>The PoW validation is performed in the following way:</p>
<ul>
<li>Compute the <a href="https://tools.ietf.org/html/rfc7693">BLAKE2b-256</a> hash of the serialized message (as described in <a href="tips/TIP-0012/../TIP-0006/tip-0006.html">TIP-6</a>) <em>excluding</em> the 8-byte <code>Nonce</code> field and convert the hash into its 192-trit <code>b1t6</code> encoding. (See <a href="tips/TIP-0012/../TIP-0005/tip-0005.html">TIP-5</a> for a description of the encoding.)</li>
<li>Take the 8-byte <code>Nonce</code> in little-endian representation, convert it into its 48-trit <code>b1t6</code> encoding and append it to the hash trits.</li>
<li>Add a padding of three zero trits to create a 243-trit string.</li>
<li>Compute the Curl-P-81 hash.</li>
<li>Count the number of trailing zero trits in the hash.</li>
<li>Then, the PoW score equals 3<sup>#zeros</sup> / size(message).</li>
</ul>
<p>This can also be summarized with the following pseudocode:</p>
<pre><code>pow_digest ← BLAKE2b-256(serialized message excluding nonce field)
pow_hash ← Curl-P-81(b1t6(pow_digest) || b1t6(nonce) || [0, 0, 0])
pow ← 3**trailing_zeros(pow_hash) / size
</code></pre>
<p>where <code>size</code> is the number of bytes of the full serialized message.</p>
<h2 id="example-3"><a class="header" href="#example-3">Example</a></h2>
<ul>
<li>Message including nonce (21-byte): <code>48656c6c6f2c20576f726c64215ee6aaaaaaaaaaaa</code></li>
<li>PoW digest (32-byte): <code>511bc81dde11180838c562c82bb35f3223f46061ebde4a955c27b3f489cf1e03</code></li>
<li>Nonce (8-byte): <code>5ee6aaaaaaaaaaaa</code> (12297829382473049694)</li>
<li>Curl input (81-tryte): <code>9C9AYYBATZQAXAH9BBVYQDYYPBDXNDWBHAO9ODPDFZTZTCAWKCLADXO9PWEYCAC9MCAZVXVXVXVXVXVX9</code></li>
<li>PoW hash (81-tryte): <code>DJCAGKILZPLXNXWFTNXFLCHRFVUHHMTPFIOFKQXMGIKITSEVWECMQOKCFXDIIHK9YVHGQICAIVEVDJ999</code></li>
<li>Trailing zeros: 9</li>
<li>PoW score: 3<sup>9</sup> / 21 = 937.2857142857143</li>
</ul>
<h1 id="drawbacks-8"><a class="header" href="#drawbacks-8">Drawbacks</a></h1>
<ul>
<li>Curl is a ternary hash function that is applied on binary data. This makes it necessary to introduce an additional encoding step. However, the proposed <code>b1t6</code> encoding is reasonably performant. Additionally, hash functions usually contain an encoding step to write the input into their internal state. In that sense, the <code>b1t6</code> encoding is not much different.</li>
<li>One additional trailing zero in the PoW hash effectively allows the message size to be tripled. This could potentially incentivize users to add otherwise unnecessary data, when the PoW difficulty stays the same. Using a binary hash function instead of Curl would only slightly improve this situation as the allowed message length remains exponential in the difficulty parameter.</li>
</ul>
<h1 id="rationale-and-alternatives-10"><a class="header" href="#rationale-and-alternatives-10">Rationale and alternatives</a></h1>
<p>The premise of this proposal is that the PoW should remain Curl-based to cause the least amount of disruption to the protocol and its established projects. Therefore, other hash functions or PoW algorithms have not been considered. However, modifications of the described calculation are possible:</p>
<ul>
<li>There are several potential encodings for the nonce: E.g. converting its value directly to balanced ternary (the most compact encoding) or using the <code>b1t8</code> encoding. The chosen <code>b1t6</code> encoding achieves a nice balance between compactness and performance. Since it is possible to fit the PoW digest and the <code>b1t6</code> encoded nonce into one Curl block, the simplicity of having only one encoding (for PoW digest and nonce) was preferred over minimal performance improvements other encodings could bring.</li>
<li>Curl can be computed directly on the <code>b1t6</code> encoded message (after an appropriate padding has been added). However, performance analysis of existing node implementation suggests that the Curl computations during the PoW could become critical, especially since parallel Curl implementations would be much more difficult to deploy because of the dynamic message lengths.</li>
<li>BLAKE2b-256 could be replaced with BLAKE2b-512 or any other binary cryptographic hash function. However, a 256-bit digest fits very nicely into exactly one Curl block and since BLAKE2b-256 is also used for the <em>message ID</em>, it is reasonable to also use it for the PoW digest. This reduces the number of required hashing implementations and even allows reusage of intermediate values between the PoW digest and the message ID computation.</li>
</ul>
<p>The PoW score formula 3<sup>#zeros</sup> / size(message) could be replaced with an alternative function to better match the network usage, e.g. in order to penalize longer message more than linearly.</p>
<h1 id="reference-implementation-4"><a class="header" href="#reference-implementation-4">Reference implementation</a></h1>
<p>Example Go implementation in <a href="https://github.com/Wollac/iota-crypto-demo">wollac/iota-crypto-demo</a>:</p>
<ul>
<li>b1t6 encoding: <a href="https://github.com/Wollac/iota-crypto-demo/blob/master/pkg/encoding/b1t6/b1t6.go">pkg/encoding/b1t6</a></li>
<li>PoW computation: <a href="https://github.com/Wollac/iota-crypto-demo/blob/master/pkg/pow/pow.go">pkg/pow</a></li>
</ul>
<h1 id="copyright-11"><a class="header" href="#copyright-11">Copyright</a></h1>
<p>Copyright and related rights waived via <a href="https://creativecommons.org/publicdomain/zero/1.0/">CC0</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><pre>
tip: 13
title: REST API
description: Node REST API routes and objects in OpenAPI Specification
author: Samuel Rufinatscha (@rufsam) <samuel.rufinatscha@iota.org>
discussions-to: https://github.com/iotaledger/tips/pull/26
status: Replaced
type: Standards
layer: Interface
created: 2020-09-10
superseded-by: TIP-25
</pre>
<h1 id="summary-11"><a class="header" href="#summary-11">Summary</a></h1>
<p>This document proposes the REST API for nodes supporting the IOTA protocol.</p>
<h1 id="api"><a class="header" href="#api">API</a></h1>
<p>The API is described using the OpenAPI Specification:</p>
<p><a href="https://editor.swagger.io/?url=https://raw.githubusercontent.com/iotaledger/tips/main/tips/TIP-0013/rest-api.yaml">Swagger Editor</a></p>
<h1 id="copyright-12"><a class="header" href="#copyright-12">Copyright</a></h1>
<p>Copyright and related rights waived via <a href="https://creativecommons.org/publicdomain/zero/1.0/">CC0</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><pre>
tip: 14
title: Ed25519 Validation
description: Adopt https://zips.z.cash/zip-0215 to explicitly define Ed25519 validation criteria
author: Gal Rogozinski (@GalRogozinski) <gal.rogozinski@iota.org>, Wolfgang Welz (@Wollac) <wolfgang.welz@iota.org>
discussions-to: https://github.com/iotaledger/tips/pull/28
status: Active
type: Standards
layer: Core
created: 2020-10-30
</pre>
<h1 id="summary-12"><a class="header" href="#summary-12">Summary</a></h1>
<p>The IOTA protocol uses Ed25519 signatures to assure the authenticity of transactions in Chrysalis. However, although Ed25519 is standardized in <a href="https://tools.ietf.org/html/rfc8032">IETF RFC 8032</a>, it does not define strict validation criteria. As a result, compatible implementations do not need to agree on whether a particular signature is valid or not. While this might be acceptable for classical message signing, it is unacceptable in the context of consensus critical applications like IOTA.</p>
<p>This RFC proposes to adopt <a href="https://zips.z.cash/zip-0215">ZIP-215</a> to explicitly define validation criteria. This mainly involves the following sections of the Ed25519 spec:</p>
<ul>
<li>decoding of elliptic curve points as described in <a href="https://tools.ietf.org/html/rfc8032#section-5.1.3">Section 5.1.3</a></li>
<li>validation itself as described in <a href="https://tools.ietf.org/html/rfc8032#section-5.1.7">Section 5.1.7</a></li>
</ul>
<h1 id="motivation-12"><a class="header" href="#motivation-12">Motivation</a></h1>
<p>Based on <a href="https://eprint.iacr.org/2020/1244">Chalkias et al. 2020</a> we know that: </p>
<ol>
<li>Not all implementations follow the decoding rules defined in RFC 8032, but instead accept non-canonically encoded inputs.</li>
<li>The RFC 8032 provides two alternative verification equations, whereas one is stronger than the other. Different implementations use different equations and therefore validation results vary even across implementations that follow the RFC 8032. </li>
</ol>
<p>This lack of consistent validation behavior is especially critical for IOTA as they can cause a breach of consensus across node implementations! For example, one node implementation may consider a particular transaction valid and mutate the ledger state accordingly, while a different implementation may discard the same transaction due to invalidity. This would result in a network fork and could only be resolved outside of the protocol. Therefore, an explicit and unambiguous definition of validation criteria, such as ZIP-215, is necessary.</p>
<p>Furthermore, it is important to note that the holder of the secret key can produce more than one valid distinct signature. Such transactions with the same essence but different signatures are considered as double spends by the consensus protocol and handled accordingly. While this does not pose a problem for the core protocol, it may be a problem for 2nd layer solutions, similar to how <a href="https://en.bitcoinwiki.org/wiki/Transaction_Malleability#How_Does_Transaction_Malleability_Affect_The_Lightning_Network.3F">transaction malleability in bitcoin presented an issue for the lightning network</a>.</p>
<h1 id="detailed-design-11"><a class="header" href="#detailed-design-11">Detailed design</a></h1>
<p>In order to have consistent validation of Ed25519 signatures for all edge cases and throughout different implementations, this RFC proposes explicit validation criteria. These three criteria <strong>must</strong> be checked to evaluate whether a signature is valid.</p>
<p>Using the notation and Ed25519 parameters as described in the RFC 8032, the criteria are defined as follows:</p>
<ol>
<li>Accept non-canonical encodings of A and R.</li>
<li>Reject values for S that are greater or equal than L.</li>
<li>Use the equation [8][S]B = [8]R + [8][k]A' for validation.</li>
</ol>
<p>In the following, we will explain each of these in more detail.</p>
<h2 id="decoding"><a class="header" href="#decoding">Decoding</a></h2>
<p>The Curve25519 is defined over the finite field of order p=2<sup>255</sup>−19. A curve point (x,y) is encoded into its compressed 32-byte representation, namely by the 255-bit encoding of the field element y followed by a single sign bit that is 1 for negative x (see <a href="https://tools.ietf.org/html/rfc8032#section-3.1">RFC 8032, Section 3.1</a>) and 0 otherwise. This approach provides a unique encoding for each valid point. However, there are two classes of edge cases representing non-canonical encodings of valid points:</p>
<ul>
<li>encoding a y-coordinate as y + p</li>
<li>encoding a curve point (0,y) with the sign bit set to 1</li>
</ul>
<p>In contrast to RFC 8032, it is <em>not</em> required that the encodings of A and R are canonical. As long as the corresponding (x,y) is a valid curve point, any of such edge cases will be accepted.</p>
<h2 id="validation-1"><a class="header" href="#validation-1">Validation</a></h2>
<p>The RFC 8032 mentions two alternative verification equations:</p>
<ol>
<li>[8][S]B = [8]R + [8][k]A'</li>
<li>[S]B = R + [k]A'</li>
</ol>
<p>Each honestly generated signature following RFC 8032 satisfies the second, cofactorless equation and thus, also the first equation. However, the opposite is not true. This is due to the fact that dishonestly generated nonce R and public key A' might have order other than L. Testing whether a point has order L is costly. The first, cofactored equation accepts more nonces and public keys including dishonestly generated ones but lets us skip costly order checks. This has the impact that each secret key has not one but eight corresponding public keys. However all those public keys correspond to different addresses.<br/> There are solutions only satisfying the first equation but not the latter. This ambiguity in RFC 8032 has led to the current situation in which different implementations rely on different verification equations.</p>
<p>Ed25519 also supports batch signature verification, which allows verifying several signatures in a single step, much faster than verifying signatures one-by-one. Without going into detail, there are also two alternative verification equations for the batch verification:<br/> [8][∑zᵢsᵢ] B = [8]∑[zᵢ]Rᵢ + [8]∑[zᵢhᵢ]Aᵢ and its corresponding cofactorless version. However, only cofactored verifications, single and batch, are compatible with each other. All other combinations are inconsistent and can lead to false positives or false negatives (see <a href="https://eprint.iacr.org/2020/1244">Chalkias et al. 2020</a>, Section 3.2) for certain edge-cases introduced by an attacker.<br/> Thus, in order to allow batch signature verification and its faster performance in IOTA nodes, the cofactored version <em>must</em> be used for validation, i.e. the group equation [8][S]B = [8]R + [8][k]A' for the single verification.</p>
<p>Since non-canonical encodings of A and R are allowed, it is crucial to also specify which representation must be used for the hash functions:</p>
<ul>
<li>The provided binary encodings of A and R must be used as input to the hash function H instead of their canonical – and potentially different – representation.</li>
<li>During transaction validation, when the public key A is checked against the output's address, the provided binary encoding must be used for the BLAKE2b-256 hash instead of its canonical representation.</li>
</ul>
<h2 id="malleability"><a class="header" href="#malleability">Malleability</a></h2>
<p>The non-negative integer S is encoded into 32 bytes as part of the signature. However, a third party could replace S with S' = S + n·L for any natural n with S' &lt; 2<sup>256</sup> and the modified signature R || S' would still pass verification. Requiring a value less than L resolves this malleability issue. Unfortunately, this check is not present in all common Ed25519 implementations.</p>
<p>Analogous to RFC 8032, the encoding of S <em>must</em> represent an integer less than L.</p>
<p>It is not possible for an external party to mutate R and still pass verification. The owner of the secret key, however, can create many different signatures for the same content: While Ed25519 defines a deterministic method of calculating the integer scalar r from the private key and the message, it is impossible to tell during signature verification if the point R = [r]B was created properly or any other scalar has been used.<br/> As a result, there is a practically countless amount of different valid signatures corresponding to a certain message and public key.</p>
<p>We allow users to have a zero-scalar secret key and consider eight corresponding public keys valid. However, users should not use it as it is equivalent to publishing one's secret key. This also has the impact that any valid signature produced with a zero-scalar secret key will authenticate any message thus making it &quot;super&quot;-malleable.</p>
<h2 id="test-vectors"><a class="header" href="#test-vectors">Test vectors</a></h2>
<p>The test vectors are taken directly from <a href="https://eprint.iacr.org/2020/1244">Chalkias et al. 2020</a>. Here, <code>pub_key</code> corresponds to the encoding of A and <code>address</code> is a 33-byte <em>Ed25519 Address</em> as described in <a href="tips/TIP-0014/../TIP-0007/tip-0007.html#serialized-layout">TIP-7</a>. The address is computed by hashing A. As mentioned in the paper, for test case #10 the key A is reduced before hashing, while in the others it is not. The key <code>valid</code> denotes whether the corresponding item represents a valid <code>signature</code> for the provided <code>address</code> and <code>message</code> or not.</p>
<ul>
<li><a href="tips/TIP-0014/test.json">JSON tests</a></li>
</ul>
<h1 id="drawbacks-9"><a class="header" href="#drawbacks-9">Drawbacks</a></h1>
<ul>
<li>Allowing non-canonical encodings is a direct contradiction of RFC 8032 and rather unintuitive. Furthermore, it introduces alternative encodings for a handful of points on the curve. Even though such points will, for all practical purposes, never occur in honest signatures, it still theoretically introduces an external party malleability vector.</li>
<li>The cofactored validation is computationally slightly more expensive than the cofactorless version since it requires a multiplication by 8.</li>
</ul>
<h1 id="rationale-and-alternatives-11"><a class="header" href="#rationale-and-alternatives-11">Rationale and alternatives</a></h1>
<p>In the IOTA protocol, the <em>Transaction ID</em> corresponds to the hash over the entire transaction including the actual signature bytes. Therefore, it is absolutely crucial that (valid) signatures are not malleable by a public attacker, i.e. that the used Ed25519 variant is strongly-unforgeable. Allowing non-canonical point encodings does not introduce the same attack vector. As such, both options would lead to valid Ed25519 variants.</p>
<p>Unfortunately, the Ed25519 <code>ref10</code> reference implementation as well as other implementations accept non-canonical points. As such, rejecting those inputs now would introduce a breaking change. While this might be acceptable for the IOTA protocol itself, since no Ed25519 signatures have been added to the ledger prior to this RFC, other consensus-critical applications require this backward compatibility with previously accepted signatures. Due to these considerations, the criterion was included in ZIP-215 to allow a seamless transition for existing consensus-critical contexts. This RFC aims to rather follow the existing ZIP-215 specification for compatibility and maintainability than to create a new standard.</p>
<p>Using the cofactorless validation poses a similar breaking change since signatures accepted by implementations using the cofactored validation would then be rejected. More importantly, however, in order to be able to use the much faster batch verification, the cofactored version is required. </p>
<h1 id="copyright-13"><a class="header" href="#copyright-13">Copyright</a></h1>
<p>Copyright and related rights waived via <a href="https://creativecommons.org/publicdomain/zero/1.0/">CC0</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><pre>
tip: 15
title: Dust Protection
description: Prevent bloating the ledger size with dust outputs
author: Gal Rogozinski (@GalRogozinski) <gal.rogozinski@iota.org>
discussions-to: https://github.com/iotaledger/tips/pull/32
status: Replaced
type: Standards
layer: Core
created: 2020-12-07
superseded-by: TIP-19
</pre>
<h1 id="summary-13"><a class="header" href="#summary-13">Summary</a></h1>
<p>In the UTXO model, each node in the network needs to keep track of all the currently unspent outputs. When the number of outputs gets too large, this can cause performance and memory issues.
This RFC proposes a new protocol rule regarding the processing of outputs that transfer a very small amount of IOTA, so-called dust outputs: Dust outputs are only allowed when they are backed up by a certain deposit on the receiving address. This limits the amount of dust outputs, thus making it expensive to proliferate dust. Since a receiver must make a deposit, the protocol makes receiving dust an opt-in feature.</p>
<h1 id="motivation-13"><a class="header" href="#motivation-13">Motivation</a></h1>
<p>An attacker, or even honest users, can proliferate the UTXO ledger with outputs holding a tiny amount of IOTA coins. This can cause the ledger to grow to a prohibitively large size. </p>
<p>In order to protect nodes from such attacks, one possible solution is to make accumulating dust outputs expensive. Since IOTA does not have any fees that might limit the feasibility of issuing many dust transactions, deposits pose a valid alternative to achieve a similar effect.</p>
<p>When an address is supposed to receive micro transactions, it must have an unspent output of a special type as a deposit. This deposit cannot be consumed by any transaction as long as the dust outputs remain unspent.</p>
<p>An additional benefit of this rule is that it makes a mass of privacy violating <a href="https://en.bitcoin.it/wiki/Privacy#Forced_address_reuse">forced address reuse attacks</a> more expensive to carry out.</p>
<h1 id="detailed-design-12"><a class="header" href="#detailed-design-12">Detailed design</a></h1>
<h3 id="definitions"><a class="header" href="#definitions">Definitions</a></h3>
<p><em>Dust output</em>: A transaction output that has an amount smaller than 1 Mi</p>
<p><em>SigLockedDustAllowanceOutput</em>: A new output type for deposits that enables an address to receive dust outputs. It can be consumed as an input like a regular <code>SigLockedSingleOutput</code>.</p>
<table>
  <tr>
    <td><b>Name</b></td>
    <td><b>Type</b></td>
    <td><b>Description</b></td>
  </tr>
  <tr>
    <td>Output Type</td>
    <td>uint8</td>
    <td>
      Set to <strong>value 1</strong> to denote a <i>SigLockedDustAllowanceOutput</i>.
    </td>
  </tr>
  <tr>
    <td valign="top">Address <code>oneOf</code></td>
    <td colspan="2">
      <details open="true">
        <summary>Ed25519 Address</summary>
        <table>
          <tr>
            <td><b>Name</b></td>
            <td><b>Type</b></td>
            <td><b>Description</b></td>
          </tr>
          <tr>
            <td>Address Type</td>
            <td>uint8</td>
            <td>
              Set to <strong>value 0</strong> to denote an <i>Ed25519 Address</i>.
            </td>
          </tr>
          <tr>
            <td>Address</td>
            <td>ByteArray[32]</td>
            <td>The raw bytes of the Ed25519 address which is the BLAKE2b-256 hash of the public key.</td>
          </tr>
        </table>
      </details>
    </td>
  </tr>
  <tr>
    <td>Amount</td>
    <td>uint64</td>
    <td>The amount of tokens to deposit with this <i>SigLockedDustAllowanceOutput</i> output.</td>
  </tr>
</table>
<h3 id="validation-2"><a class="header" href="#validation-2">Validation</a></h3>
<p>Let A be the address that should hold the dust outputs' balances. Let S be the sum of all the amounts of all unspent <code>SigLockedDustAllowanceOutputs</code> on A. Then, the maximum number of allowed dust outputs on A is S divided by 100,000 and rounded down, i.e. 10 outputs for each 1 Mi deposited.
However, regardless of S, the number of dust outputs must never exceed 100 per address.</p>
<p>The amount of a <code>SigLockedDustAllowanceOutput</code> must be at least 1 Mi. Apart from this, <code>SigLockedDustAllowanceOutputs</code> are processed identical to <code>SigLockedSingleOutput</code>. The transaction validation as defined in the IOTA protocol <a href="tips/TIP-0015/../TIP-0007/tip-0007.html">TIP-7</a>, however, needs to be adapted.</p>
<p><em>Syntactical validation</em> for <code>SigLockedDustAllowanceOutput</code>:</p>
<ul>
<li>The <code>Address</code> must be unique in the set of <code>SigLockedDustAllowanceOutputs</code> in one transaction T. However, there can be one <code>SigLockedSingleOutput</code> and one <code>SigLockedDustAllowanceOutputs</code> T.</li>
<li>The <code>Amount</code> must be ≥ 1,000,000.</li>
</ul>
<p>The <em>semantic validation</em> remains unchanged and are checked for both <code>SigLockedSingleOutputs</code> and <code>SigLockedDustAllowanceOutput</code>, but this RFC introduces one additional criterion:</p>
<p>A transaction T</p>
<ul>
<li>consuming a <code>SigLockedDustAllowanceOutput</code> on address A <strong>or</strong></li>
<li>creating a dust output with address A,</li>
</ul>
<p>is only semantically valid, if, after T is booked, the number of confirmed unspent dust outputs on A does not exceed the allowed threshold of min(S / 100000, 100).</p>
<h1 id="drawbacks-10"><a class="header" href="#drawbacks-10">Drawbacks</a></h1>
<ul>
<li>There can no longer be addresses holding less than 1 Mi.</li>
<li>The actual validity of dust transaction can only be checked during semantic validation.</li>
<li>A service receiving micropayments may fail receiving them, if it did not consolidate dust outputs or raised the deposit for the receiving address.</li>
<li>An attacker can send microtransactions to an address with a <code>SigLockedDustAllowanceOutput</code> in order to fill the allowed threshold and block honest senders of microtransactions. The owner of the address can mitigate this by simply consolidating the attacker's dust and collecting it for profit.</li>
</ul>
<h1 id="rationale-and-alternatives-12"><a class="header" href="#rationale-and-alternatives-12">Rationale and alternatives</a></h1>
<p>The rationale for creating a special <code>SigLockedDustAllowanceOutput</code> rather than rely on the default <code>SigLockedSingleOutputs</code> is to prevent attackers from polluting arbitrary addresses that happen to hold
a large amount of funds with dust.</p>
<p>One may note that an attacker can deposit a dust allowance on 3rd party address outside his control and pollute that address with dust.
From a security perspective this is better than an attacker depositing a dust allowance on addresses under his control.
This is because the receiving party might later choose to consolidate the dust outputs and hence relief UTXO memory consumption.
The receiving party is also unlikely to be displeased from obtaining more funds, small as they may be.</p>
<p>There are potential alternatives to introducing dust allowance deposits:</p>
<ul>
<li><em>Burning dust</em>: Allow dust outputs to exists only for a limited amount of time in the ledger. After this, they are removed completely and the associated funds are invalidated.</li>
<li><em>Sweeping dust into Merkle trees</em>: Instead of burning dust outputs after some time, they are instead compressed into a Merkle tree and only the tree root is kept. In order to spend one of these compressed outputs, the corresponding Merkle audit path needs to be supplied in addition to a regular signature.</li>
</ul>
<p>The first option can cause issues, when dust outputs were burned before users could consolidate them. Also, changing the supply can be controversial.</p>
<p>The second option is much more complicated as it introduces a completely new unlock mechanisms and requires the nodes to store the Merkle tree roots indefinitely.</p>
<h1 id="copyright-14"><a class="header" href="#copyright-14">Copyright</a></h1>
<p>Copyright and related rights waived via <a href="https://creativecommons.org/publicdomain/zero/1.0/">CC0</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><pre>
tip: 16
title: Event API
description: Node event API definitions in AsyncAPI Specification
author: Luca Moser (@luca-moser) <luca.moser@iota.org>
discussions-to: https://github.com/iotaledger/tips/pull/33
status: Replaced
type: Standards
layer: Interface
created: 2021-01-06
superseded-by: TIP-28
</pre>
<h1 id="summary-14"><a class="header" href="#summary-14">Summary</a></h1>
<p>This document proposes the Event API for nodes supporting the IOTA protocol.</p>
<h1 id="api-1"><a class="header" href="#api-1">API</a></h1>
<p>The API is described using the AsyncAPI Specification:</p>
<p><a href="https://studio.asyncapi.com/?load=https://raw.githubusercontent.com/iotaledger/tips/main/tips/TIP-0016/event-api.yml">AsyncAPI Editor</a></p>
<h1 id="copyright-15"><a class="header" href="#copyright-15">Copyright</a></h1>
<p>Copyright and related rights waived via <a href="https://creativecommons.org/publicdomain/zero/1.0/">CC0</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><pre>
tip: 17
title: Wotsicide
description: Define migration from legacy WOTS addresses to post-Chrysalis Phase 2 network
author: Luca Moser (@luca-moser) <luca.moser@iota.org>
discussions-to: https://github.com/iotaledger/tips/pull/35
status: Obsolete
type: Standards
layer: Core
created: 2021-01-13
</pre>
<h1 id="summary-15"><a class="header" href="#summary-15">Summary</a></h1>
<p>This RFC defines the migration process of funds residing on WOTS addresses in the current legacy network to the post-Chrysalis Phase 2 network.</p>
<h1 id="motivation-14"><a class="header" href="#motivation-14">Motivation</a></h1>
<p>The IOTA protocol wants to move away from WOTS as it created a number of security, protocol and UX issues:</p>
<ul>
<li>WOTS signatures are big and make up a disproportional amount of data of a transaction.</li>
<li>It is only safe to spend from an address <strong>once</strong>. Spending multiple times from the same address reveals random parts of the private key, making any subsequent transfers (other than the first) susceptible to thefts.</li>
<li>As a prevention mechanism to stop users from spending multiple times from the same address, nodes have to keep an ever growing list of those addresses.</li>
</ul>
<p>In the beginning of the new Chrysalis Phase 2 network, only Ed25519 addresses are supported. The protocol will no longer support WOTS addresses. Therefore, there needs to be a migration process from WOTS addresses to Ed25519 address in the new network.</p>
<p>To make the migration as smooth as possible, the specified mechanism allows for users to migrate their funds at any time with only a small delay until they're available on the new network.</p>
<p>This RFC outlines the detailed architecture of how users will be able to migrate their funds and specifies the underlying components and their purposes.</p>
<h1 id="detailed-design-13"><a class="header" href="#detailed-design-13">Detailed Design</a></h1>
<p>On a high-level the migration process works as follows:</p>
<ul>
<li>Users create migration bundles in the legacy network which target their Ed25519 address in the new network.</li>
<li>The Coordinator then mints those migrated funds in receipts which are placed within milestones on the new network.</li>
<li>Nodes in the new network evaluate receipts and book the corresponding funds by creating new UTXOs in the ledger.</li>
</ul>
<h2 id="migration-timeline"><a class="header" href="#migration-timeline">Migration timeline</a></h2>
<ol>
<li>Users issue migration bundles which effectively burn their funds. During this period, normal value bundles and zero-value transactions are allowed to become part of a milestone cone.</li>
<li>The Coordinator is stopped, and a new global snapshot is created which as its only solid entry point contains the last issued milestone (and put on dbfiles.iota.org). This global snapshot is used to create the genesis snapshot containing the already migrated funds for the new network. The remainder of the total supply which has not been migrated is allocated on the <code>TreasuryOutput</code>. Users are instructed to check the validity of these two snapshots.</li>
<li>A new Hornet version is released which only allows migration bundles to be broadcasted or be part of milestone cones. Users must update their node software as otherwise they will no longer peer.</li>
<li>The legacy network is restarted with the global snapshot, and the new network bootstraps with the genesis snapshot.</li>
<li>Further funds migrated in the legacy network are transferred to the new network using the receipt mechanism.</li>
</ol>
<h2 id="changes-to-the-legacy-network"><a class="header" href="#changes-to-the-legacy-network">Changes to the legacy network</a></h2>
<p>In order to facilitate the migration process, the node software making up the legacy network needs to be updated. This update will be deployed by stopping the Coordinator and forcing all nodes to upgrade to this new version.</p>
<h3 id="migration-bundle"><a class="header" href="#migration-bundle">Migration bundle</a></h3>
<p>The node software will no longer book ledger mutations to non-migration addresses. This means that users are incentivized to migrate their funds as they want to use their tokens. See this document on what <a href="https://hackmd.io/@iota-protocol/rkO-r1qAv">migration addresses</a> are.</p>
<p>A migration bundle is defined as follows:</p>
<ul>
<li>It contains exactly one output transaction of which the destination address is a valid <a href="https://hackmd.io/@iota-protocol/rkO-r1qAv">migration address</a> and is positioned as the tail transaction within the bundle. The output transaction value is at least 1'000'000 tokens.</li>
<li>It does not contain any zero-value transactions which do not hold signature fragments. This means that transactions other than the tail transaction must always be part of an input.</li>
<li>Input transactions must not use migration addresses.</li>
</ul>
<p>The node will only use tail transactions of migration or milestone bundles for the tip-pool. This means that past cones referenced by a milestone will only include such bundles.</p>
<p>The legacy node software is updated with an additional HTTP API command called <code>getWhiteFlagConfirmation</code> which given request data in the following form:</p>
<pre><code class="language-json">{
    &quot;command&quot;: &quot;getWhiteFlagConfirmation&quot;,
    &quot;milestoneIndex&quot;: 1434593
}
</code></pre>
<p>returns data for the given milestone white-flag confirmation:</p>
<pre><code class="language-json">{
    &quot;milestoneBundle&quot;: [
        &quot;SDGKWKJAG...&quot;,
        &quot;WNGHJWIFA...&quot;,
        &quot;DSIEWSDIG...&quot;
    ],
    &quot;includedBundles&quot;: [
        [
            &quot;SKRGI9DFS...&quot;,
            &quot;NBJSKRJGW...&quot;,
            &quot;ITRUQORTZ...&quot;
        ],
        [
            &quot;OTIDFJKSD...&quot;,
            &quot;BNSUGRWER...&quot;,
            &quot;OPRGJSDFJ...&quot;
        ],
        ...
    ]
}
</code></pre>
<p>where <code>milestoneBundle</code> contains the milestone bundle trytes and <code>includedBundles</code> is an array of tryte arrays of included bundles in the same DFS order as the white-flag confirmation. Trytes within a bundle &quot;array&quot; are sorted from <code>currentIndex</code> = 0 ascending to the <code>lastIndex</code>.</p>
<p>This HTTP API command allows interested parties to verify which migration bundles were confirmed by a given milestone.</p>
<h3 id="milestone-inclusion-merkle-proof"><a class="header" href="#milestone-inclusion-merkle-proof">Milestone inclusion Merkle proof</a></h3>
<p>The Coordinator will only include migration bundles (respectively the tails of those bundles) in its inclusion Merkle proof. Nodes which do not run with the updated code will crash once the updated confirmation is in place.</p>
<h3 id="preventing-non-migration-bundles"><a class="header" href="#preventing-non-migration-bundles">Preventing non-migration bundles</a></h3>
<p>As an additional measure to prevent users from submitting never confirming non-migration bundles (which would lead to key-reuse), nodes will no longer accept non-migration bundles in the HTTP API.</p>
<p>HTTP API level checks:</p>
<ul>
<li>The user must submit an entire migration bundle. No more single zero-value transactions, value-spam bundles etc. are allowed.</li>
<li>Input transactions are spending the entirety of the funds residing on the corresponding address. There must be more than 0 tokens on the given address.</li>
</ul>
<p>Wallet software must be updated to no longer support non-migration bundles.</p>
<p>There are no restrictions put in place on the gossip level, as it is too complex to prevent non-migration transactions to be filtered out, however, these transactions will never become part of a milestone cone.</p>
<h2 id="treasury-transaction"><a class="header" href="#treasury-transaction">Treasury Transaction</a></h2>
<p>A <code>TreasuryTransaction</code> is a payload which contains a reference to the current <code>TreasuryOutput</code> (in form of a <code>TreasuryInput</code> object) and an output <code>TreasuryOutput</code> which deposits the remainder.</p>
<p>Serialized form:</p>
<table>
    <tr>
        <td><b>Name</b></td>
        <td><b>Type</b></td>
        <td><b>Description</b></td>
    </tr>
    <tr>
        <td>Type</td>
        <td>uint32</td>
        <td>
            Set to <strong>value 4</strong> to denote a <i>TreasuryTransaction</i>.
        </td>
    </tr>
    <tr>
        <td>Input</td>
        <td colspan="2">
            <summary>TreasuryInput</summary>
            <table>
                <tr>
                    <td><b>Name</b></td>
                    <td><b>Type</b></td>
                    <td><b>Description</b></td>
                </tr>
                <tr>
                    <td>Input Type</td>
                    <td>byte</td>
                    <td>
                        Set to <strong>value 1</strong> to denote an <i>TreasuryInput</i>.
                    </td>
                </tr>
                <tr>
                    <td>Milestone Hash</td>
                    <td>Array&lt;byte&gt;[32]></td>
                    <td>The hash of the milestone which created the referenced <i>TreasuryOutput</i>.</td>
                </tr>
            </table>
        </td>
    </tr>
    <tr>
        <td>Output</td>
        <td colspan="2">
            <summary>TreasuryOutput</summary>
            <table>
                <tr>
                    <td><b>Name</b></td>
                    <td><b>Type</b></td>
                    <td><b>Description</b></td>
                </tr>
                <tr>
                    <td>Output Type</td>
                    <td>byte</td>
                    <td>
                        Set to <strong>value 2</strong> to denote an <i>TreasuryOutput</i>.
                    </td>
                </tr>
                <tr>
                    <td>Amount</td>
                    <td>uint64</td>
                    <td>The amount of funds residing in the treasury.</td>
                </tr>
            </table>
        </td>
    </tr>
</table>
<h3 id="treasury-input"><a class="header" href="#treasury-input">Treasury Input</a></h3>
<p>The <code>TreasuryInput</code> is equivalent to a normal <code>UTXOInput</code> but instead of referencing a transaction, it references a milestone. This input can only be used within <code>TreasuryTransaction</code> payloads.</p>
<p>Serialized form:</p>
<table>
    <tr>
        <td><b>Name</b></td>
        <td><b>Type</b></td>
        <td><b>Description</b></td>
    </tr>
    <tr>
        <td>Input Type</td>
        <td>byte</td>
        <td>
            Set to <strong>value 1</strong> to denote an <i>TreasuryInput</i>.
        </td>
    </tr>
    <tr>
        <td>Milestone Hash</td>
        <td>Array&lt;byte&gt;[32]></td>
        <td>The hash of the milestone which created the referenced <i>TreasuryOutput</i>.</td>
    </tr>
</table>
<h3 id="treasury-output"><a class="header" href="#treasury-output">Treasury Output</a></h3>
<p>The <code>TreasuryOutput</code> is a special output type which represents the treasury of the network, respectively the non yet migrated funds. At any given moment in time, there is only one <code>TreasuryOutput</code>.</p>
<p>Serialized form:</p>
<table>
    <tr>
        <td><b>Name</b></td>
        <td><b>Type</b></td>
        <td><b>Description</b></td>
    </tr>
    <tr>
        <td>Output Type</td>
        <td>byte</td>
        <td>
            Set to <strong>value 2</strong> to denote an <i>TreasuryInput</i>.
        </td>
    </tr>
    <tr>
        <td>Amount</td>
        <td>uint64</td>
        <td>The amount of funds residing in the treasury.</td>
    </tr>
</table>
<p>The <code>TreasuryOutput</code> can not be referenced or spent by transactions, it can only be referenced by receipts.</p>
<p>The <code>TreasuryOutput</code> can be queried from the HTTP API and needs to be included within snapshots in order to keep the total supply intact.</p>
<h2 id="receipts"><a class="header" href="#receipts">Receipts</a></h2>
<p>Receipts allow for fast migration of funds from the legacy into the new network by representing entries of funds which were migrated in the old network.</p>
<h3 id="schema-1"><a class="header" href="#schema-1">Schema</a></h3>
<p>Receipts are listings of funds for which nodes must generate UTXOs in the form of <code>SigLockedSingleOutput</code>s targeting the given address. Receipts are embedded within milestone payloads and therefore signed by the Coordinator. A milestone may contain up to one receipt as a payload. The Coordinator chooses whether to embed a receipt payload or not.</p>
<p>Serialized form:</p>
<table>
    <tr>
        <td><b>Name</b></td>
        <td><b>Type</b></td>
        <td><b>Description</b></td>
    </tr>
    <tr>
        <td>Payload Type</td>
        <td>uint32</td>
        <td>Set to <strong>value 3</strong> to denote a <i>Receipt</i>.</td>
    </tr>
    <tr>
        <td>Migrated At</td>
        <td>uint32</td>
        <td>The index of the legacy milestone in which the listed funds were migrated at.</td>
    </tr>
    <tr>
        <td>Final</td>
        <td>bool</td>
        <td>Flags whether this receipt is the last receipt for the given <i>Migrated At</i> index.</td>
    </tr>
    <tr>
        <td>Funds Count</td>
        <td>uint16</td>
        <td>Denotes how many migrated fund entries are within the receipt.</td>
    </tr>
    <tr>
        <td>Funds</td>
        <td colspan="2">
        <details open="true">
            <summary>Migrated Funds Entry</summary>
            <table>
                <tr>
                    <th>Name</th>
                    <th>Type</th>
                    <th>Description</th>
                </tr>
                <tr>
                    <td>Tail Transaction Hash</td>
                    <td>Array&lt;byte&gt;[49]</td>
                    <td>
                    The tail transaction hash of the bundle in which these funds were migrated.
                    </td>
                </tr>
                <tr>
                    <td valign="top">Address <code>oneOf</code></td>
                    <td colspan="2">
                        <details open="true">
                            <summary>Ed25519 Address</summary>
                            <table>
                                <tr>
                                    <td><b>Name</b></td>
                                    <td><b>Type</b></td>
                                    <td><b>Description</b></td>
                                </tr>
                                <tr>
                                    <td>Address Type</td>
                                    <td>uint8</td>
                                    <td>
                                        Set to <strong>value 0</strong> to denote an <i>Ed25519 Address</i>.
                                    </td>
                                </tr>
                                <tr>
                                    <td>Address</td>
                                    <td>Array&lt;byte&gt;[32]</td>
                                    <td>The raw bytes of the Ed25519 address which is a BLAKE2b-256 hash of the Ed25519 public key.</td>
                                </tr>
                            </table>
                        </details>
                    </td>
                </tr>
                <tr>
                    <td>Amount</td>
                    <td>uint64</td>
                    <td>The amount which was migrated</td>
                </tr>
            </table>
        </details>
        </td>
    </tr>
    <tr>
        <td>Payload Length</td>
        <td>uint32</td>
        <td>The length in bytes of the payload.</td>
    </tr>
    <tr>
        <td valign="top">Payload</td>
        <td colspan="2">
            <details>
                <summary>TreasuryTransaction Payload</summary>
            </details>
        </td>
    </tr>
</table>
<h3 id="validation-3"><a class="header" href="#validation-3">Validation</a></h3>
<h4 id="syntactical"><a class="header" href="#syntactical">Syntactical</a></h4>
<ul>
<li><code>funds_array_count</code> can be max 127 and must be &gt; 0.</li>
<li><code>funds</code> array must be in lexical sort order (by their serialized form).</li>
<li>any <code>tail_transaction_hash</code> must be unique over the entire receipt.</li>
<li><code>deposit</code> must be ≥ 1'000'000 IOTA tokens.</li>
<li><code>payload_length</code> can not be zero.</li>
<li><code>treasury_transaction</code> must be a <code>Treasury Transaction</code> payload.</li>
</ul>
<h4 id="semantic"><a class="header" href="#semantic">Semantic</a></h4>
<ul>
<li><code>migrated_at</code> can not decrease between subsequent receipts.</li>
<li>There must not be any subsequent receipts with the same <code>migrated_at</code> index after the one with the <code>final</code> flag set to true.</li>
<li>The amount field of the previous <code>TreasuryOutput</code> minus the sum of all the newly migrated funds must equal the amount of the new <code>TreasuryOutput</code> within the <code>TreasuryTransaction</code> payload.</li>
</ul>
<h4 id="legitimacy-of-migrated-funds"><a class="header" href="#legitimacy-of-migrated-funds">Legitimacy of migrated funds</a></h4>
<p>While the syntactical and semantic validation ensures that the receipt's integrity is correct, it doesn't actually tell whether the given funds were really migrated in the legacy network.</p>
<p>In order validate this criteria, the node software performs following operation:</p>
<ol>
<li>The HTTP API of a legacy node is queried for all the <code>tail_transaction_hashes</code>, the addresses and their corresponding migrated funds.</li>
<li>The node checks whether the funds within the receipt matches the response from the legacy node.</li>
<li>Additionally, if the receipt's <code>final</code> flag was set to true, it is validated whether all funds for the given legacy milestone were migrated by looking at all the receipts with the same <code>migrated_at</code> index.</li>
</ol>
<p>If the operation fails, the node software must gracefully terminate with an appropriate error message.</p>
<p>In an optimal setting, node operators choose to only ask <strong>their own</strong> deployed nodes in the legacy network.</p>
<h3 id="booking-receipts"><a class="header" href="#booking-receipts">Booking receipts</a></h3>
<p>After successful receipt validation, the node software generates UTXOs in the following form: A <code>SigLockedSingleOutput</code> is allocated with the given <code>ed25519_address</code> and the funds as the deposit. As there is no actual transaction which generates the UTXO and normally a UTXO ID consists of <code>transaction hash | the output index</code>, the milestone hash of the milestone which included the receipt with the given funds is used as the <code>transaction hash</code>. The <code>output index</code> equals the index of the funds within the receipt (this is also why the receipt is limited to 127 entries). This allows to easily look up in which milestone these funds were generated in.</p>
<p>If one wants to audit the UTXO path of an input, it means that milestones need to be kept forever as they're needed to recognize that a certain output was generated by it. However, this can be offloaded to a 2nd level service.</p>
<p>All the generated <code>SigLockedSingleOutput</code>s from the migrated funds are then booked into the ledger and the new <code>TreasuryOutput</code> is persisted as a UTXO using the milestone hash of the receipt which included the <code>Treasury Transaction</code> payload.</p>
<h2 id="transparency"><a class="header" href="#transparency">Transparency</a></h2>
<p>For transparency reasons, the IF offers software which renders a dashboard showing details throughout the entire migration process:</p>
<ul>
<li>A list of outstanding funds residing on migration addresses to be migrated with the milestone index at which they were created.</li>
<li>Migrated funds.</li>
<li>Generated receipts.</li>
</ul>
<h2 id="misc"><a class="header" href="#misc">Misc</a></h2>
<p>At current legacy network ledger size of 261446 entries (addresses with ≥ 1'000'000 tokens), it would take min. ~2058 receipts to migrate all funds. While theoretically the max message size allows for more entries to be within one receipt, it is limited by the fact that the index of the migrated address within the receipt is used to generate the <code>output_index</code> of the generated <code>SigLockedSingleDeposit</code> (further explained below).</p>
<p>Assuming the best case scenario in which all 261446 entries were sent to migration addresses in the legacy network, these funds could therefore be migrated into the new network within ~5.7h (at a 10 second milestone interval). Of course, in practice users will migrate over time and the receipt mechanism will need to be in place as long as the new network runs.</p>
<p>If looked at the receipt validation from a higher-level, it becomes quite apparent that this is analogous to previous global snapshots where users would post comments on a PR on GitHub saying that they computed the same ledger state, just that it is more granular and automatic while still leveraging the same source of truth: the ledger state/database of nodes.</p>
<h2 id="caveats"><a class="header" href="#caveats">Caveats</a></h2>
<ul>
<li>The local snapshot file format needs to also include the to be applied receipts and supply information.</li>
</ul>
<h1 id="copyright-16"><a class="header" href="#copyright-16">Copyright</a></h1>
<p>Copyright and related rights waived via <a href="https://creativecommons.org/publicdomain/zero/1.0/">CC0</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><pre>
tip: 18
title: Multi-Asset Ledger and ISC Support
description: Transform IOTA into a multi-asset ledger that supports running IOTA Smart Contracts
author: Levente Pap (@lzpap) <levente.pap@iota.org>
discussions-to: https://github.com/iotaledger/tips/pull/38
status: Active
type: Standards
layer: Core
created: 2021-11-04
requires: TIP-19, TIP-20, TIP-21 and TIP-22
</pre>
<h1 id="summary-16"><a class="header" href="#summary-16">Summary</a></h1>
<p>This document proposes new output types and transaction validation rules for the IOTA protocol to support <strong>native
tokenization</strong> and <strong>smart contract</strong> features.</p>
<p>Native tokenization refers to the capability of the IOTA ledger to <strong>track the ownership and transfer of user defined
tokens, so-called native tokens</strong>, thus making it a <strong>multi-asset ledger</strong>. The scalable and feeless nature of IOTA
makes it a prime candidate for tokenization use cases.</p>
<p>The <strong>IOTA Smart Contract Protocol (ISCP)</strong> is a <strong>layer 2 extension</strong> of the IOTA protocol that adds smart contract
features to the Tangle. Many so-called <strong>smart contract chains</strong>, which anchor their state to the base ledger, can be
run in parallel. Users wishing to interact with smart contract chains can send <strong>requests to layer 1 chain accounts
either as regular transactions or directly to the chain</strong>, but <strong>chains may also interact with other chains</strong> in a
trustless manner through the Tangle.</p>
<p>This TIP presents output types that realize the required new features:</p>
<ul>
<li>Smart contract chains have a new account type, called alias account, represented by an <strong>alias output.</strong></li>
<li>Requests to smart contract chains can be carried out using the configurable new output type called
<strong>basic output.</strong></li>
<li>Native tokens have their own <strong>supply control policy</strong> enforced by <strong>foundry outputs.</strong></li>
<li>Layer 1 native <strong>non-fungible tokens</strong> (unique tokens with attached metadata) are introduced via <strong>NFT outputs.</strong></li>
</ul>
<h1 id="motivation-15"><a class="header" href="#motivation-15">Motivation</a></h1>
<p>IOTA transitioned from an account based ledger model to an unspent transaction output (UTXO) model with the upgrade to
<a href="tips/TIP-0018/../TIP-0007/tip-0007.html">Chrysalis phase 2</a>. In this model, transactions explicitly
reference funds produced by previous transactions to be consumed. This property is desired for scalability: transaction
validation does not depend on the shared global state and, as such, transactions can be validated in parallel.
Double-spends can easily be detected as they spend the very same output more than once.</p>
<p>The UTXO model becomes even more powerful when unlocking criteria (validation) of outputs is extended as demonstrated
by the <a href="https://fc20.ifca.ai/wtsc/WTSC2020/WTSC20_paper_25.pdf">EUTXO model (Chakravarty et al., 2020)</a>: instead of
requiring only a valid signature for the output's address to unlock it, additional unlocking conditions can be
programmed into outputs. This programmability of outputs is the main idea behind the new output types presented in this
document.</p>
<p>Today, outputs in the IOTA protocol are designed for one specific use case: the single asset cryptocurrency. The aim of
this TIP is to design several output types for the use cases of:</p>
<ul>
<li>Native Tokenization Framework,</li>
<li>ISCP style smart contracts,</li>
<li>seamless interoperability between layer 1 and layer 2 tokenization concepts.</li>
</ul>
<p>Users will be able to mint their own native tokens directly in the base ledger, which can then be transferred without
any fees just like regular IOTA coins. Each native token has its own supply control policy enforced by the protocol.
These policies are transparent to all network participants. Issuers will be able to store metadata about their tokens
on-ledger, accessible to anyone.</p>
<p>Non-fungible tokens can be minted and transferred with zero fees. The validated issuers of such NFTs are immutably
attached to the tokens, making it impossible to counterfeit them.</p>
<p>Users will be able to interact with smart contracts by posting requests through the Tangle. Requests can carry commands
to smart contracts and can additionally also transfer native tokens and NFTs. By depositing native tokens to smart
contracts, their features can be greatly enhanced and programmed to specific use cases.</p>
<p>The proposal in this TIP not only makes it possible to transfer native tokens to layer 2 smart contracts, but tokens
that originate from layer 2 smart contract chains can also be wrapped into their respective layer 1 representation.
Smart contract chains may transfer tokens between themselves through this mechanism, and they can also post requests to
other chains.</p>
<p>Composability of smart contracts extends the realm of one smart contract chain, as smart contracts residing on
different chains can call each other in a trustless manner.</p>
<p>In conclusion, the IOTA protocol will become a scalable general purpose multi-asset DLT with the addition of smart
contracts and native tokenization frameworks. The transition is motivated by the ever-growing need for a scalable and
affordable decentralized application platform.</p>
<h1 id="detailed-design-14"><a class="header" href="#detailed-design-14">Detailed Design</a></h1>
<p>Outputs in the UTXO model are essential, core parts of the protocol. The new output types introduce new validation and
unlocking mechanisms, therefore the protocol needs to be adapted. The structure of the remaining sections is as follows:</p>
<ol>
<li><a href="tips/TIP-0018/tip-0018.html#ledger-programmability">Introduction to ledger programmability</a></li>
<li><a href="tips/TIP-0018/tip-0018.html#data-types--subschema-notation">Data types, subschemas and protocol constants</a></li>
<li><a href="tips/TIP-0018/tip-0018.html#transaction-payload-changes">Transaction Payload changes compared to Chrysalis Part 2</a></li>
<li><a href="tips/TIP-0018/tip-0018.html#new-concepts">New concepts of output design</a>
<ul>
<li><a href="tips/TIP-0018/tip-0018.html#native-tokens-in-outputs">Native tokens</a></li>
<li><a href="tips/TIP-0018/tip-0018.html#unlock-conditions">Unlock Conditions</a></li>
<li><a href="tips/TIP-0018/tip-0018.html#features">Features</a></li>
<li><a href="tips/TIP-0018/tip-0018.html#chain-constraint-in-utxo">Chain constraint</a></li>
</ul>
</li>
<li><a href="tips/TIP-0018/tip-0018.html#output-design">Detailed design of new output types</a>
<ul>
<li><a href="tips/TIP-0018/tip-0018.html#basic-output">Basic Output</a></li>
<li><a href="tips/TIP-0018/tip-0018.html#alias-output">Alias Output</a></li>
<li><a href="tips/TIP-0018/tip-0018.html#foundry-output">Foundry Output</a></li>
<li><a href="tips/TIP-0018/tip-0018.html#nft-output">NFT Output</a></li>
</ul>
</li>
<li><a href="tips/TIP-0018/tip-0018.html#unlocking-chain-script-locked-outputs">New unlocking mechanisms</a></li>
<li><a href="tips/TIP-0018/tip-0018.html#drawbacks">Discussion</a></li>
</ol>
<h2 id="ledger-programmability"><a class="header" href="#ledger-programmability">Ledger Programmability</a></h2>
<p>The current UTXO model only provides support to transfer IOTA coins. However, the UTXO model presents a unique
opportunity to extend the range of possible applications by programming outputs.</p>
<p>Programming the base ledger of a DLT is not a new concept. Bitcoin uses the UTXO model and attaches small executables
(scripts) that need to be executed during transaction validation. The bitcoin script language is however not
<a href="https://en.wikipedia.org/wiki/Turing_completeness">Turing-complete</a> as it can only support a small set of instructions
that are executed in a stack based environment. As each validator has to execute the same scripts and arrive at the
same conclusion, such scripts must terminate very quickly. Also, as transaction validation happens in the context of
the transaction and block, the scripts have no access to the global shared state of the system (all unspent transaction
outputs).</p>
<p>The novelty of Ethereum was to achieve quasi Turing-completeness by employing an account based model and gas to limit
resource usage during program execution. As the amount of gas used per block is limited, only quasi Turing-completeness
can be achieved. The account based model of Ethereum makes it possible for transactions to have access to the global
shared state of the system, furthermore, transactions are executed one-after-the-other. These two properties make
Ethereum less scalable and susceptible to high transaction fees.</p>
<p>Cardano achieves UTXO programmability by using the EUTXO model. This makes it possible to represent smart contracts in
a UTXO model as state machines. In EUTXO, states of the machine are encoded in outputs, while state transition rules
are governed by scripts. Just like in bitcoin, these scripts may only use a limited set of instructions.</p>
<p>It would be quite straightforward to support EUTXO in IOTA too, except that IOTA transactions are feeless. There is no
reward to be paid out to validators for validating transactions, as all nodes in the network validate all transactions.
Due to the unique data structure of the Tangle, there is no need for miners to explicitly choose which transactions are
included in the ledger, but there still has to be a notion of objective validity of transactions. Since it is not
possible without fees to penalize scripts that consume excessive network resources (node CPU cycles) during transaction
validation, IOTA has to be overly restrictive about what instructions are supported on layer 1.</p>
<p>It must also be noted that UTXO scripts are finite state machines with the state space restricted by the output and
transaction validation rules. It makes expressiveness of UTXO scripts inherently limited. In the context of complicated
application logic required by use cases such as modern DeFi, this leads to unconventional and complicated architectures
of the application, consisting of many interacting finite state machines. Apart from complexity and UX costs, it also
has performance and scalability penalties.</p>
<p>For the reason mentioned above, <strong>IOTA chooses to support configurable yet hard-coded scripts for output and
transaction validation on layer 1.</strong> The general full-scale quasi Turing-complete programmability of the IOTA ledger is
achieved by extending the ledger state transition function with layer 2 smart contract chains. This not only makes it
possible to keep layer 1 scalable and feeless, but also allows to support any type of virtual machine on layer 2 to
program advanced business logic and features.</p>
<p>Below, several new output types are discussed that implement their own configurable script logic. They can be viewed as
UTXO state machines in which the state of the machine is encoded as data inside the output. The state transition rules
are defined by the output type and by the parameters chosen upon deployment.</p>
<h2 id="data-types--subschema-notation"><a class="header" href="#data-types--subschema-notation">Data Types &amp; Subschema Notation</a></h2>
<p>Data types and subschemas used throughout this TIP are defined in <a href="tips/TIP-0018/../TIP-0021/tip-0021.html">TIP-21</a>.</p>
<h2 id="global-protocol-parameters"><a class="header" href="#global-protocol-parameters">Global Protocol Parameters</a></h2>
<p>Global protocol parameters used throughout this TIP are defined in <a href="tips/TIP-0018/../TIP-0022/tip-0022.html">TIP-22 (IOTA)</a> and <a href="tips/TIP-0018/../TIP-0032/tip-0032.html">TIP-32 (Shimmer)</a>.</p>
<h2 id="transaction-payload-changes"><a class="header" href="#transaction-payload-changes">Transaction Payload Changes</a></h2>
<p>The new output types and unlocking mechanisms require new transaction validation rules, furthermore some protocol rules
have been modified compared to
Chrysalis Part 2 Transaction Payload <a href="tips/TIP-0018/../TIP-0007/tip-0007.html">TIP-7</a>.</p>
<p><a href="tips/TIP-0018/../TIP-0020/tip-0020.html">TIP-20</a> replaces aforementioned
TIP-7 with the new transaction layout and validation rules. The updated version is the basis for
output validation in this TIP.</p>
<h3 id="summary-of-changes"><a class="header" href="#summary-of-changes">Summary of Changes</a></h3>
<ul>
<li>Deprecating <i>SigLockedSingleOutput</i> and <i>SigLockedDustAllowanceOutput</i>.
<ul>
<li>The new dust protection mechanism does not need a distinct output type, therefore
<i>SigLockedDustAllowanceOutput</i> will be deprecated. One alternative is that during migration to the new
protocol version, all dust outputs sitting on an address will be merged into a <i>Basic Output</i> together
with their respective <i>SigLockedDustAllowanceOutputs</i> to create the snapshot for the updated protocol.
The exact migration strategy will be decided later.</li>
</ul>
</li>
<li>Adding new <a href="tips/TIP-0018/tip-0018.html#output-design">output types</a> to <em>Transaction Payload</em>.</li>
<li>Adding new <a href="tips/TIP-0018/tip-0018.html#unlocking-chain-script-locked-outputs">unlock types</a> to <em>Transaction Payload</em>.</li>
<li><i>Inputs</i> and <i>Outputs</i> of a transaction become a list instead of a set. Binary duplicate inputs are not
allowed as they anyway mean double-spends, but binary duplicate outputs are allowed.</li>
<li>There can be many outputs created to the same address in the transaction.</li>
<li>Confirming milestone supplies notion of time to semantic transaction validation.</li>
</ul>
<h2 id="new-concepts"><a class="header" href="#new-concepts">New Concepts</a></h2>
<p>New output types add new features to the protocol and hence new transaction validation rules. While some of these new
features are specifically tied to one output type, some are general, LEGO like building blocks that may be put in
several types of outputs.</p>
<p>Below is a summary of such new features and the validation rules they introduce.</p>
<h3 id="native-tokens-in-outputs"><a class="header" href="#native-tokens-in-outputs">Native Tokens in Outputs</a></h3>
<p>Outputs are records in the UTXO ledger that track ownership of funds. Thus, each output must be able to specify which
funds it holds. With the addition of the Native Tokenization Framework, outputs may also carry user defined native
tokens, that is, tokens that are not IOTA coins but were minted by foundries and are tracked in the very same ledger.
Therefore, <strong>every output must be able to hold not only IOTA coins, but also native tokens</strong>.</p>
<p>Dust protection applies to all outputs, therefore it is not possible for outputs to hold only native tokens, the
storage deposit requirements must be covered via IOTA coins.</p>
<p>User defined tokens are called <i>Native Tokens</i> on protocol level. The maximum supply of a particular native token
is defined by the representation chosen on protocol level for defining their amounts in outputs. Since native tokens
are also a vehicle to wrap layer 2 tokens into layer 1 tokens, the chosen representation must take into account the
maximum possible supply of layer 2 tokens. Solidity, the most popular smart contract language defines the
maximum supply of an ERC-20 token as <code>MaxUint256</code>, therefore it should be possible to represent such huge amount of
assets on layer 1.</p>
<p>Outputs must have the following fields to define the balance of native tokens they hold:</p>
<table>
    <tr>
        <td><b>Name</b></td>
        <td><b>Type</b></td>
        <td><b>Description</b></td>
    </tr>
    <tr>
        <td>Native Tokens Count</td>
        <td>uint8</td>
        <td>The number of native tokens present in the output.</td>
    </tr>
    <tr>
        <td valign="top">Native Tokens <code>optAnyOf</code></td>
        <td colspan="2">
            <details>
                <summary>Native Token</summary>
                <table>
                    <tr>
                        <td><b>Name</b></td>
                        <td><b>Type</b></td>
                        <td><b>Description</b></td>
                    </tr>
                    <tr>
                        <td>Token ID</td>
                        <td>ByteArray[38]</td>
                        <td>
                            Identifier of the native token. Derivation defined <a href='https://github.com/iotaledger/tips/blob/main/tips/TIP-0018/tip-0018.md#foundry-output'>here</a>.
                        </td>
                    </tr>
                    <tr>
                        <td>Amount</td>
                        <td>uint256</td>
                        <td>
                            Amount of tokens.
                        </td>
                    </tr>
                </table>
            </details>
        </td>
    </tr>
</table>
<h4 id="additional-syntactic-output-validation-rules"><a class="header" href="#additional-syntactic-output-validation-rules">Additional syntactic output validation rules:</a></h4>
<ul>
<li><code>Native Tokens</code> must be lexicographically sorted based on <code>Token ID</code>.</li>
<li>Each <i>Native Token</i> must be unique in the set of <code>Native Tokens</code> based on its <code>Token ID</code>. No duplicates are
allowed.</li>
<li><code>Amount</code> of any <i>Native Token</i> must not be <code>0</code>.</li>
</ul>
<h4 id="additional-semantic-transaction-validation-rules"><a class="header" href="#additional-semantic-transaction-validation-rules">Additional semantic transaction validation rules:</a></h4>
<ul>
<li>The transaction is balanced in terms of native tokens, that is, the sum of native token balances in consumed outputs
equals that of the created outputs.</li>
<li>When the transaction is <strong>imbalanced</strong> and there is a surplus of native tokens on the:
<ul>
<li><strong>output side of the transaction:</strong> the foundry outputs controlling outstanding native token balances must be present in the transaction. The validation of the foundry output(s) determines if the minting operations are valid.</li>
<li><strong>input side of the transaction:</strong> the transaction destroys tokens. The presence and validation of the foundry outputs of the native tokens determines whether the tokens are burned (removed from the ledger) or melted in the foundry.</li>
</ul>
</li>
</ul>
<h3 id="new-functionalities-in-outputs"><a class="header" href="#new-functionalities-in-outputs">New Functionalities in Outputs</a></h3>
<p>The programmability of outputs opens the door for implementing new functionalities for the base protocol. While some outputs
were specifically designed for such new features, some are optional additions that may be used with any outputs that
support them.</p>
<p>These new functionalities are grouped into two categories:</p>
<ul>
<li><strong>Unlock Conditions</strong> and</li>
<li>simple <strong>Features</strong>.</li>
</ul>
<p>The <a href="tips/TIP-0018/tip-0018.html#output-design">Output Design</a> section lists all supported <i>Unlock Conditions</i> and <i>Features</i> for
each output type.</p>
<h4 id="unlock-conditions"><a class="header" href="#unlock-conditions">Unlock Conditions</a></h4>
<p>New output features that introduce unlocking conditions, that is, they define constraints on how the output can
be unlocked and spent, are grouped under the field <i>Unlock Conditions</i>.</p>
<p>Each output <strong>must not contain more than one unlock condition of each type</strong> and not all unlock condition types are
supported for each output type.</p>
<h5 id="address-unlock-condition"><a class="header" href="#address-unlock-condition">Address Unlock Condition</a></h5>
<p>It is merely a layout change that the previously defined <code>Address</code> field of outputs (<a href="tips/TIP-0018/../TIP-0007/tip-0007.html">TIP-7</a>)
is represented as an <i>Address Unlock Condition</i>. Unlocking an <i>Ed25519 Address</i> doesn't change, it has to
be performed via a <i>Signature Unlock</i> in a transaction by signing the hash of the transaction essence.
Transaction validation rules are detailed in <a href="tips/TIP-0018/../TIP-0020/tip-0020.html">TIP-20</a>.</p>
<p>New additions are the <i>Alias Address</i> and <i>NFT Address</i> types, which have to be unlocked with their
corresponding unlocks, as defined in <a href="tips/TIP-0018/tip-0018.html#unlocking-chain-script-locked-outputs">Unlocking Chain Script Locked Outputs</a>.</p>
<details>
    <summary>Address Unlock</summary>
    <blockquote>
        Defines the Address that owns this output, that is, it can unlock it with the proper <i>Unlock</i> in a
        transaction.
    </blockquote>
</details>
<table>
    <tr>
        <td><b>Name</b></td>
        <td><b>Type</b></td>
        <td><b>Description</b></td>
    </tr>
    <tr>
        <td>Unlock Condition Type</td>
        <td>uint8</td>
        <td>
            Set to <strong>value 0</strong> to denote an <i>Address Unlock Condition</i>.
        </td>
    </tr>
    <tr>
        <td>Address</td>
        <td colspan="2">
            <details>
                <summary>Ed25519 Address</summary>
                <table>
                    <tr>
                        <td><b>Name</b></td>
                        <td><b>Type</b></td>
                        <td><b>Description</b></td>
                    </tr>
                    <tr>
                        <td>Address Type</td>
                        <td>uint8</td>
                        <td>
                            Set to <strong>value 0</strong> to denote an <i>Ed25519 Address</i>.
                        </td>
                    </tr>
                    <tr>
                        <td>PubKeyHash</td>
                        <td>ByteArray[32]</td>
                        <td>The raw bytes of the Ed25519 address which is a BLAKE2b-256 hash of the Ed25519 public key.</td>
                    </tr>
                </table>
            </details>
            <details>
                <summary>Alias Address</summary>
                <table>
                    <tr>
                        <td><b>Name</b></td>
                        <td><b>Type</b></td>
                        <td><b>Description</b></td>
                    </tr>
                    <tr>
                        <td>Address Type</td>
                        <td>uint8</td>
                        <td>
                            Set to <strong>value 8</strong> to denote an <i>Alias Address</i>.
                        </td>
                    </tr>
                    <tr>
                        <td>Alias ID</td>
                        <td>ByteArray[32]</td>
                        <td>The raw bytes of the <i>Alias ID</i> which is the BLAKE2b-256 hash of the outputID that created it.</td>
                    </tr>
                </table>
            </details>
            <details>
                <summary>NFT Address</summary>
                <table>
                    <tr>
                        <td><b>Name</b></td>
                        <td><b>Type</b></td>
                        <td><b>Description</b></td>
                    </tr>
                    <tr>
                        <td>Address Type</td>
                        <td>uint8</td>
                        <td>
                            Set to <strong>value 16</strong> to denote an <i>NFT Address</i>.
                        </td>
                    </tr>
                    <tr>
                        <td>NFT ID</td>
                        <td>ByteArray[32]</td>
                        <td>The raw bytes of the <i>NFT ID</i> which is the BLAKE2b-256 hash of the outputID that created it.</td>
                    </tr>
                </table>
            </details>
        </td>
    </tr>
</table>
<div class="table-wrapper"><table><thead><tr><th>:information_source:  Good to know about address format</th></tr></thead><tbody>
</tbody></table>
</div>
<p>The <i>Address Type</i> byte of a raw address has an effect on the starting character of the bech32 encoded address,
which is the recommended address format for user facing applications.</p>
<p>A usual bech32 encoded mainnet address starts with <code>iota1</code>, and continues with the bech32 encoded bytes of the address.
By choosing <i>Address Type</i> as a multiple of 8 for different address types, the first character after the <code>1</code>
separator in the bech32 address will always be different.</p>
<div class="table-wrapper"><table><thead><tr><th>Address</th><th>Type Byte as <code>uint8</code></th><th>Bech32 Encoded</th></tr></thead><tbody>
<tr><td>Ed25519</td><td>0</td><td>iota1<strong>q</strong>...</td></tr>
<tr><td>Alias</td><td>8</td><td>iota1<strong>p</strong>...</td></tr>
<tr><td>NFT</td><td>16</td><td>iota1<strong>z</strong>...</td></tr>
</tbody></table>
</div>
<p>A user can identify by looking at the address whether it is a signature backed address, a smart contract chain account
or an NFT address.</p>
<h5 id="storage-deposit-return-unlock-condition"><a class="header" href="#storage-deposit-return-unlock-condition">Storage Deposit Return Unlock Condition</a></h5>
<p>This unlock condition is employed to achieve conditional sending. An output that has
<i>Storage Deposit Return Unlock Condition</i> specified can only be consumed in a transaction that deposits
<code>Return Amount</code> IOTA coins into <code>Return Address</code>. When several of such outputs are consumed, their return amounts per
<code>Return Addresses</code> are summed up and the output side must deposit this total sum per <code>Return Address</code>.</p>
<h6 id="additional-syntactic-transaction-validation-rule"><a class="header" href="#additional-syntactic-transaction-validation-rule">Additional syntactic transaction validation rule:</a></h6>
<ul>
<li><code>Minimum Storage Deposit</code> is the storage deposit in the base currency required for a <i>Basic Output</i> that only
has an <i>Address Unlock Condition</i>, no additional unlock conditions, no features and
no native tokens.</li>
<li>It must hold true, that <code>Minimum Storage Deposit</code> ≤  <code>Return Amount</code> ≤ <code>Amount</code>.</li>
</ul>
<h6 id="additional-semantic-transaction-validation-rule"><a class="header" href="#additional-semantic-transaction-validation-rule">Additional semantic transaction validation rule:</a></h6>
<ul>
<li>An output that has <i>Storage Deposit Return Unlock Condition</i> specified must only be consumed and unlocked in a
transaction that deposits <code>Return Amount</code> IOTA coins to <code>Return Address</code> via one or more outputs that:
<ul>
<li>are of type <a href="tips/TIP-0018/tip-0018.html#basic-output"><i>Basic Output</i></a>,</li>
<li>have only an <a href="tips/TIP-0018/tip-0018.html#address-unlock-condition"><i>Address Unlock Condition</i></a> defined,</li>
<li>have no <a href="tips/TIP-0018/tip-0018.html#native-tokens-in-outputs"><i>Native Tokens</i></a>, and</li>
<li>have no <a href="tips/TIP-0018/tip-0018.html#features"><i>Features</i></a>.</li>
</ul>
</li>
<li>When several outputs with <i>Storage Deposit Return Unlock Condition</i> and the same <code>Return Address</code> are consumed,
their return amounts per <code>Return Addresses</code> are summed up and the output side of the transaction must deposit
<em>at least</em> this total sum per <code>Return Address</code> via output(s) that satisfy the previous condition.</li>
</ul>
<details>
    <summary>Storage Deposit Return Unlock Condition</summary>
    <blockquote>
        Defines the amount of IOTAs used as storage deposit that have to be returned to <i>Return Address</i>.
    </blockquote>
</details>
<table>
    <tr>
        <td><b>Name</b></td>
        <td><b>Type</b></td>
        <td><b>Description</b></td>
    </tr>
    <tr>
        <td>Unlock Condition Type</td>
        <td>uint8</td>
        <td>
            Set to <strong>value 1</strong> to denote a <i>Storage Deposit Return Unlock Condition</i>.
        </td>
    </tr>
    <tr>
        <td valign="top">Return Address<code>oneOf</code></td>
        <td colspan="2">
            <details>
                <summary>Ed25519 Address</summary>
                <table>
                    <tr>
                        <td><b>Name</b></td>
                        <td><b>Type</b></td>
                        <td><b>Description</b></td>
                    </tr>
                    <tr>
                        <td>Address Type</td>
                        <td>uint8</td>
                        <td>
                            Set to <strong>value 0</strong> to denote an <i>Ed25519 Address</i>.
                        </td>
                    </tr>
                    <tr>
                        <td>PubKeyHash</td>
                        <td>ByteArray[32]</td>
                        <td>The raw bytes of the Ed25519 address which is a BLAKE2b-256 hash of the Ed25519 public key.</td>
                    </tr>
                </table>
            </details>
            <details>
                <summary>Alias Address</summary>
                <table>
                    <tr>
                        <td><b>Name</b></td>
                        <td><b>Type</b></td>
                        <td><b>Description</b></td>
                    </tr>
                    <tr>
                        <td>Address Type</td>
                        <td>uint8</td>
                        <td>
                            Set to <strong>value 8</strong> to denote an <i>Alias Address</i>.
                        </td>
                    </tr>
                    <tr>
                        <td>Alias ID</td>
                        <td>ByteArray[32]</td>
                        <td>The raw bytes of the <i>Alias ID</i> which is the BLAKE2b-256 hash of the outputID that created it.</td>
                    </tr>
                </table>
            </details>
            <details>
                <summary>NFT Address</summary>
                <table>
                    <tr>
                        <td><b>Name</b></td>
                        <td><b>Type</b></td>
                        <td><b>Description</b></td>
                    </tr>
                    <tr>
                        <td>Address Type</td>
                        <td>uint8</td>
                        <td>
                            Set to <strong>value 16</strong> to denote an <i>NFT Address</i>.
                        </td>
                    </tr>
                    <tr>
                        <td>NFT ID</td>
                        <td>ByteArray[32]</td>
                        <td>The raw bytes of the <i>NFT ID</i> which is the BLAKE2b-256 hash of the outputID that created it.</td>
                    </tr>
                </table>
            </details>
        </td>
    </tr>
    <tr>
        <td>Return Amount</td>
        <td>uint64</td>
        <td>
            Amount of IOTA coins the consuming transaction should deposit to <i>Return Address</i>.
        </td>
    </tr>
</table>
<p>This unlock condition makes it possible to send small amounts of IOTA coins or native tokens to addresses without having
to lose control of the required storage deposit. It is also a vehicle to send on-chain requests to ISCP chains that do not
require fees. To prevent the receiving party from blocking access to the storage deposit, it is advised to be used
together with the <a href="tips/TIP-0018/tip-0018.html#expiration-unlock-conditions">Expiration Unlock Conditions</a>. The receiving party then has a sender-defined
time window to agree to the transfer by consuming the output, or the sender regains total control after expiration.</p>
<h5 id="timelock-unlock-condition"><a class="header" href="#timelock-unlock-condition">Timelock Unlock Condition</a></h5>
<p>The notion of time in the Tangle is introduced via milestones. Each milestone
<a href="tips/TIP-0018/../TIP-0008/tip-0008.html#structure">carries the current unix timestamp</a>
corresponding to that milestone index. Whenever a new milestone appears, nodes perform the white-flag ordering and transaction
validation on its past cone. The timestamp of the confirming milestone provide the time as an input parameter to
transaction validation.</p>
<p>An output that contains a <i>Timelock Unlock Condition</i> can not be unlocked before the specified timelock has
expired. The timelock is expired when the timestamp of the confirming milestone is equal or past the timestamp defined
in the <i>Timelock Unlock Condition</i>.</p>
<h6 id="additional-syntactic-transaction-validation-rules"><a class="header" href="#additional-syntactic-transaction-validation-rules">Additional syntactic transaction validation rules:</a></h6>
<ul>
<li><code>Unix Time</code> field of a <i>Timelock Unlock Condition</i> must be &gt; <code>0</code>.</li>
</ul>
<h6 id="additional-semantic-transaction-validation-rules-1"><a class="header" href="#additional-semantic-transaction-validation-rules-1">Additional semantic transaction validation rules:</a></h6>
<ul>
<li>An output that has <i>Timelock Unlock Condition</i> specified must only be consumed and unlocked in a
transaction, if the timestamp of the confirming milestone is equal or past the <code>Unix Time</code> specified in the unlock
condition.</li>
</ul>
<details>
    <summary>Timelock Unlock Condition</summary>
    <blockquote>
        Defines a unix timestamp until which the output can not be unlocked.
    </blockquote>
</details>
<table>
    <tr>
        <td><b>Name</b></td>
        <td><b>Type</b></td>
        <td><b>Description</b></td>
    </tr>
    <tr>
        <td>Unlock Condition Type</td>
        <td>uint8</td>
        <td>
            Set to <strong>value 2</strong> to denote a <i>Timelock Unlock Condition</i>.
        </td>
    </tr>
    <tr>
        <td>Unix Time</td>
        <td>uint32</td>
        <td>
            Unix time (seconds since Unix epoch) starting from which the output can be consumed.
        </td>
    </tr>
</table>
<h5 id="expiration-unlock-condition"><a class="header" href="#expiration-unlock-condition">Expiration Unlock Condition</a></h5>
<p>The expiration feature of outputs makes it possible for the return address to reclaim an output after a given expiration
time has been passed. The expiration can be specified as a unix timestamp.</p>
<p>The expiration feature can be viewed as an opt-in receive feature, because the recipient loses access to the received
funds after the output expires, while the return address specified by the sender regains control over them. This feature
is a big help for on-chain smart contract requests. Those that have expiration set and are sent to dormant smart contract
chains can be recovered by their senders. Not to mention the possibility to time requests by specifying both a
timelock and an expiration unlock condition.</p>
<h6 id="additional-syntactic-transaction-validation-rules-1"><a class="header" href="#additional-syntactic-transaction-validation-rules-1">Additional syntactic transaction validation rules:</a></h6>
<ul>
<li><code>Unix Time</code> field of an <i>Expiration Unlock Condition</i> must be &gt; <code>0</code>.</li>
</ul>
<h6 id="additional-semantic-transaction-validation-rules-2"><a class="header" href="#additional-semantic-transaction-validation-rules-2">Additional semantic transaction validation rules:</a></h6>
<ul>
<li>An output that has <i>Expiration Unlock Condition</i> set must only be consumed and
unlocked by the target <code>Address</code> (defined in <i>Address Unlock Condition</i>) in a transaction that has a confirming
milestone timestamp earlier than the <code>Unix Time</code> defined in the unlock condition.</li>
<li>An output that has <i>Expiration Unlock Condition</i> set must only be consumed and unlocked by the <code>Return Address</code>
in a transaction that has a confirming milestone timestamp same or later than the <code>Unix Time</code> defined in the unlock
condition.</li>
<li>Semantic validation of an output that has <i>Expiration Unlock Condition</i> set and is unlocked by the
<code>Return Address</code> must ignore:
<ul>
<li><a href="tips/TIP-0018/tip-0018.html#storage-deposit-return-unlock-condition">Semantic validation of <i>Storage Deposit Return Unlock Condition</i></a> if present.</li>
</ul>
</li>
</ul>
<p>The following table summarizes the outcome of syntactic and semantic validation rules with respect to which account
is allowed to unlock the output containing the <i>Expiration Unlock Condition</i>:</p>
<div class="table-wrapper"><table><thead><tr><th>Milestone Unix Timestamp Condition</th><th>Outcome</th></tr></thead><tbody>
<tr><td><code>Unix Time</code> = <code>0</code></td><td>Output and containing transaction is invalid.</td></tr>
<tr><td><code>Unix Time</code> &gt; <code>Confirming Milestone Unix Timestamp</code></td><td>Unlockable by <code>Address</code></td></tr>
<tr><td><code>Unix Time</code> ≤ <code>Confirming Milestone Unix Timestamp</code></td><td>Unlockable by <code>Return Address</code></td></tr>
</tbody></table>
</div><details>
    <summary>Expiration Unlock Condition</summary>
    <blockquote>
        Defines a unix time until which only <i>Address</i>, defined in <i>Address Unlock Condition</i>, is allowed to
        unlock the output. After the unix time is reached/passed, only <i>Return Address</i> can unlock it.
    </blockquote>
</details>
<table>
    <tr>
        <td><b>Name</b></td>
        <td><b>Type</b></td>
        <td><b>Description</b></td>
    </tr>
    <tr>
        <td>Unlock Condition Type</td>
        <td>uint8</td>
        <td>
            Set to <strong>value 3</strong> to denote a <i>Expiration Unlock Condition</i>.
        </td>
    </tr>
    <tr>
        <td valign="top">Return Address <code>oneOf</code></td>
        <td colspan="2">
            <details>
                <summary>Ed25519 Address</summary>
                <table>
                    <tr>
                        <td><b>Name</b></td>
                        <td><b>Type</b></td>
                        <td><b>Description</b></td>
                    </tr>
                    <tr>
                        <td>Address Type</td>
                        <td>uint8</td>
                        <td>
                            Set to <strong>value 0</strong> to denote an <i>Ed25519 Address</i>.
                        </td>
                    </tr>
                    <tr>
                        <td>PubKeyHash</td>
                        <td>ByteArray[32]</td>
                        <td>The raw bytes of the Ed25519 address which is a BLAKE2b-256 hash of the Ed25519 public key.</td>
                    </tr>
                </table>
            </details>
            <details>
                <summary>Alias Address</summary>
                <table>
                    <tr>
                        <td><b>Name</b></td>
                        <td><b>Type</b></td>
                        <td><b>Description</b></td>
                    </tr>
                    <tr>
                        <td>Address Type</td>
                        <td>uint8</td>
                        <td>
                            Set to <strong>value 8</strong> to denote an <i>Alias Address</i>.
                        </td>
                    </tr>
                    <tr>
                        <td>Alias ID</td>
                        <td>ByteArray[32]</td>
                        <td>The raw bytes of the <i>Alias ID</i> which is the BLAKE2b-256 hash of the outputID that created it.</td>
                    </tr>
                </table>
            </details>
            <details>
                <summary>NFT Address</summary>
                <table>
                    <tr>
                        <td><b>Name</b></td>
                        <td><b>Type</b></td>
                        <td><b>Description</b></td>
                    </tr>
                    <tr>
                        <td>Address Type</td>
                        <td>uint8</td>
                        <td>
                            Set to <strong>value 16</strong> to denote an <i>NFT Address</i>.
                        </td>
                    </tr>
                    <tr>
                        <td>NFT ID</td>
                        <td>ByteArray[32]</td>
                        <td>The raw bytes of the <i>NFT ID</i> which is the BLAKE2b-256 hash of the outputID that created it.</td>
                    </tr>
                </table>
            </details>
        </td>
    </tr>
    <tr>
        <td>Unix Time</td>
        <td>uint32</td>
        <td>
            Before this unix time, <i>Address Unlock Condition</i> is allowed to unlock the output, after that only the address defined in <i>Return Address</i>.
        </td>
    </tr>
</table>
<h5 id="state-controller-address-unlock-condition"><a class="header" href="#state-controller-address-unlock-condition">State Controller Address Unlock Condition</a></h5>
<p>An unlock condition defined solely for <i>Alias Output</i>. It is functionally equivalent to an
<i>Address Unlock Condition</i>, however there are additional transition constraints defined for the Alias UTXO state
machine that can only be carried out by the <code>State Controller Address</code>, hence the distinct unlock condition type.</p>
<details>
    <summary>State Controller Address Unlock</summary>
    <blockquote>
        Defines the State Controller Address that owns this output, that is, it can unlock it with the proper <i>Unlock</i> in a
        transaction that state transitions the alias output.
    </blockquote>
</details>
<table>
    <tr>
        <td><b>Name</b></td>
        <td><b>Type</b></td>
        <td><b>Description</b></td>
    </tr>
    <tr>
        <td>Unlock Condition Type</td>
        <td>uint8</td>
        <td>
            Set to <strong>value 4</strong> to denote an <i>State Controller Address Unlock Condition</i>.
        </td>
    </tr>
    <tr>
        <td>Address</td>
        <td colspan="2">
            <details>
                <summary>Ed25519 Address</summary>
                <table>
                    <tr>
                        <td><b>Name</b></td>
                        <td><b>Type</b></td>
                        <td><b>Description</b></td>
                    </tr>
                    <tr>
                        <td>Address Type</td>
                        <td>uint8</td>
                        <td>
                            Set to <strong>value 0</strong> to denote an <i>Ed25519 Address</i>.
                        </td>
                    </tr>
                    <tr>
                        <td>PubKeyHash</td>
                        <td>ByteArray[32]</td>
                        <td>The raw bytes of the Ed25519 address which is a BLAKE2b-256 hash of the Ed25519 public key.</td>
                    </tr>
                </table>
            </details>
            <details>
                <summary>Alias Address</summary>
                <table>
                    <tr>
                        <td><b>Name</b></td>
                        <td><b>Type</b></td>
                        <td><b>Description</b></td>
                    </tr>
                    <tr>
                        <td>Address Type</td>
                        <td>uint8</td>
                        <td>
                            Set to <strong>value 8</strong> to denote an <i>Alias Address</i>.
                        </td>
                    </tr>
                    <tr>
                        <td>Alias ID</td>
                        <td>ByteArray[32]</td>
                        <td>The raw bytes of the <i>Alias ID</i> which is the BLAKE2b-256 hash of the outputID that created it.</td>
                    </tr>
                </table>
            </details>
            <details>
                <summary>NFT Address</summary>
                <table>
                    <tr>
                        <td><b>Name</b></td>
                        <td><b>Type</b></td>
                        <td><b>Description</b></td>
                    </tr>
                    <tr>
                        <td>Address Type</td>
                        <td>uint8</td>
                        <td>
                            Set to <strong>value 16</strong> to denote an <i>NFT Address</i>.
                        </td>
                    </tr>
                    <tr>
                        <td>NFT ID</td>
                        <td>ByteArray[32]</td>
                        <td>The raw bytes of the <i>NFT ID</i> which is the BLAKE2b-256 hash of the outputID that created it.</td>
                    </tr>
                </table>
            </details>
        </td>
    </tr>
</table>
<p>The additional constraints are defined in <a href="tips/TIP-0018/tip-0018.html#alias-output">Alias Output Design</a> section.</p>
<h5 id="governor-address-unlock-condition"><a class="header" href="#governor-address-unlock-condition">Governor Address Unlock Condition</a></h5>
<p>An unlock condition defined solely for <i>Alias Output</i>. It is functionally equivalent to an
<i>Address Unlock Condition</i>, however there are additional transition constraints defined for the Alias UTXO state
machine that can only be carried out by the <code>Governor Address</code>, hence the distinct unlock condition type.</p>
<details>
    <summary>Governor Address Unlock</summary>
    <blockquote>
        Defines the Governor Address that owns this output, that is, it can unlock it with the proper <i>Unlock</i> in a
        transaction that governance transitions the alias output.
    </blockquote>
</details>
<table>
    <tr>
        <td><b>Name</b></td>
        <td><b>Type</b></td>
        <td><b>Description</b></td>
    </tr>
    <tr>
        <td>Unlock Condition Type</td>
        <td>uint8</td>
        <td>
            Set to <strong>value 5</strong> to denote an <i>Governor Address Unlock Condition</i>.
        </td>
    </tr>
    <tr>
        <td>Address</td>
        <td colspan="2">
            <details>
                <summary>Ed25519 Address</summary>
                <table>
                    <tr>
                        <td><b>Name</b></td>
                        <td><b>Type</b></td>
                        <td><b>Description</b></td>
                    </tr>
                    <tr>
                        <td>Address Type</td>
                        <td>uint8</td>
                        <td>
                            Set to <strong>value 0</strong> to denote an <i>Ed25519 Address</i>.
                        </td>
                    </tr>
                    <tr>
                        <td>PubKeyHash</td>
                        <td>ByteArray[32]</td>
                        <td>The raw bytes of the Ed25519 address which is a BLAKE2b-256 hash of the Ed25519 public key.</td>
                    </tr>
                </table>
            </details>
            <details>
                <summary>Alias Address</summary>
                <table>
                    <tr>
                        <td><b>Name</b></td>
                        <td><b>Type</b></td>
                        <td><b>Description</b></td>
                    </tr>
                    <tr>
                        <td>Address Type</td>
                        <td>uint8</td>
                        <td>
                            Set to <strong>value 8</strong> to denote an <i>Alias Address</i>.
                        </td>
                    </tr>
                    <tr>
                        <td>Alias ID</td>
                        <td>ByteArray[32]</td>
                        <td>The raw bytes of the <i>Alias ID</i> which is the BLAKE2b-256 hash of the outputID that created it.</td>
                    </tr>
                </table>
            </details>
            <details>
                <summary>NFT Address</summary>
                <table>
                    <tr>
                        <td><b>Name</b></td>
                        <td><b>Type</b></td>
                        <td><b>Description</b></td>
                    </tr>
                    <tr>
                        <td>Address Type</td>
                        <td>uint8</td>
                        <td>
                            Set to <strong>value 16</strong> to denote an <i>NFT Address</i>.
                        </td>
                    </tr>
                    <tr>
                        <td>NFT ID</td>
                        <td>ByteArray[32]</td>
                        <td>The raw bytes of the <i>NFT ID</i> which is the BLAKE2b-256 hash of the outputID that created it.</td>
                    </tr>
                </table>
            </details>
        </td>
    </tr>
</table>
<p>The additional constraints are defined in <a href="tips/TIP-0018/tip-0018.html#alias-output">Alias Output Design</a> section.</p>
<h5 id="immutable-alias-address-unlock-condition"><a class="header" href="#immutable-alias-address-unlock-condition">Immutable Alias Address Unlock Condition</a></h5>
<p>An unlock condition defined for chain constrained UTXOs that can only be unlocked by a permanent <i>Alias Address</i>.</p>
<p>Output unlocking is functionally equivalent to an <i>Address Unlock Condition</i> with an <i>Alias Address</i>,
however there are additional transition constraints: the next state of the UTXO machine must have the same
<i>Immutable Alias Address Unlock Condition</i>.</p>
<details>
    <summary>Immutable Alias Address Unlock Condition</summary>
    <blockquote>
        Defines the permanent <i>Alias Address</i> that owns this output.
    </blockquote>
</details>
<table>
    <tr>
        <td><b>Name</b></td>
        <td><b>Type</b></td>
        <td><b>Description</b></td>
    </tr>
    <tr>
        <td>Unlock Condition Type</td>
        <td>uint8</td>
        <td>
            Set to <strong>value 6</strong> to denote an <i>Immutable Alias Address Unlock Condition</i>.
        </td>
    </tr>
    <tr>
        <td>Address</td>
        <td colspan="2">
            <details>
                <summary>Alias Address</summary>
                <table>
                    <tr>
                        <td><b>Name</b></td>
                        <td><b>Type</b></td>
                        <td><b>Description</b></td>
                    </tr>
                    <tr>
                        <td>Address Type</td>
                        <td>uint8</td>
                        <td>
                            Set to <strong>value 8</strong> to denote an <i>Alias Address</i>.
                        </td>
                    </tr>
                    <tr>
                        <td>Alias ID</td>
                        <td>ByteArray[32]</td>
                        <td>The raw bytes of the <i>Alias ID</i> which is the BLAKE2b-256 hash of the outputID that created it.</td>
                    </tr>
                </table>
            </details>
        </td>
    </tr>
</table>
<h6 id="additional-semantic-transaction-validation-rules-3"><a class="header" href="#additional-semantic-transaction-validation-rules-3">Additional semantic transaction validation rules:</a></h6>
<ul>
<li>The output must be unlocked with an <i><a href="tips/TIP-0018/tip-0018.html#alias-unlock-semantic-validation">Alias Unlock</a></i>.</li>
<li>The next state of the UTXO state machine must have the same <i>Immutable Alias Address Unlock Condition</i> defined.</li>
</ul>
<h3 id="features"><a class="header" href="#features">Features</a></h3>
<p>New output features that do not introduce unlocking conditions, but rather add new functionality and add constraints on
output creation are grouped under <i>Features</i>.</p>
<p>Each output <strong>must not contain more than one feature of each type</strong> and not all feature types are supported for each output
type.</p>
<h5 id="sender-feature"><a class="header" href="#sender-feature">Sender Feature</a></h5>
<p>Every transaction consumes several elements from the UTXO set and creates new outputs. However, certain applications
(smart contracts) require to associate each output with exactly one sender address. Here, the sender feature is used to
specify the validated sender of an output.</p>
<p>Outputs that support the <i>Sender Feature</i> may specify a <code>Sender</code> address which is validated by the protocol during
transaction validation.</p>
<h6 id="additional-semantic-transaction-validation-rule-1"><a class="header" href="#additional-semantic-transaction-validation-rule-1">Additional semantic transaction validation rule:</a></h6>
<ul>
<li>The <i>Sender Feature</i>, and hence the output and transaction that contain it, is valid, if and only if <code>Sender</code> address is unlocked in the transaction. Based on the <code>Address Type</code>, an address is unlocked in the transaction, if and only if:
<ul>
<li><i>Ed25519 Address</i>:
<ul>
<li>The <i>Unlock</i> of the first output in the transaction that contains the address is a valid <i>Signature Unlock</i> with respect to the address.</li>
</ul>
</li>
<li><i>Alias Address</i>:
<ul>
<li>The <i>Alias Output</i> that defines the address is <strong>state transitioned</strong> in the transaction. A governance transition does not unlock the address.</li>
</ul>
</li>
<li><i>NFT Address</i>:
<ul>
<li>The <i>NFT Output</i> that defines the address is consumed as input in the transaction.</li>
</ul>
</li>
</ul>
</li>
</ul>
<details>
    <summary>Sender Feature</summary>
    <blockquote>
        Identifies the validated sender of the output.
    </blockquote>
</details>
<table>
    <tr>
        <td><b>Name</b></td>
        <td><b>Type</b></td>
        <td><b>Description</b></td>
    </tr>
    <tr>
        <td>Feature Type</td>
        <td>uint8</td>
        <td>
            Set to <strong>value 0</strong> to denote a <i>Sender Feature</i>.
        </td>
    </tr>
    <tr>
        <td valign="top">Address <code>oneOf</code></td>
        <td colspan="2">
            <details>
                <summary>Ed25519 Address</summary>
                <table>
                    <tr>
                        <td><b>Name</b></td>
                        <td><b>Type</b></td>
                        <td><b>Description</b></td>
                    </tr>
                    <tr>
                        <td>Address Type</td>
                        <td>uint8</td>
                        <td>
                            Set to <strong>value 0</strong> to denote an <i>Ed25519 Address</i>.
                        </td>
                    </tr>
                    <tr>
                        <td>PubKeyHash</td>
                        <td>ByteArray[32]</td>
                        <td>The raw bytes of the Ed25519 address which is a BLAKE2b-256 hash of the Ed25519 public key.</td>
                    </tr>
                </table>
            </details>
            <details>
                <summary>Alias Address</summary>
                <table>
                    <tr>
                        <td><b>Name</b></td>
                        <td><b>Type</b></td>
                        <td><b>Description</b></td>
                    </tr>
                    <tr>
                        <td>Address Type</td>
                        <td>uint8</td>
                        <td>
                            Set to <strong>value 8</strong> to denote an <i>Alias Address</i>.
                        </td>
                    </tr>
                    <tr>
                        <td>Alias ID</td>
                        <td>ByteArray[32]</td>
                        <td>The raw bytes of the <i>Alias ID</i> which is the BLAKE2b-256 hash of the outputID that created it.</td>
                    </tr>
                </table>
            </details>
            <details>
                <summary>NFT Address</summary>
                <table>
                    <tr>
                        <td><b>Name</b></td>
                        <td><b>Type</b></td>
                        <td><b>Description</b></td>
                    </tr>
                    <tr>
                        <td>Address Type</td>
                        <td>uint8</td>
                        <td>
                            Set to <strong>value 16</strong> to denote an <i>NFT Address</i>.
                        </td>
                    </tr>
                    <tr>
                        <td>NFT ID</td>
                        <td>ByteArray[32]</td>
                        <td>The raw bytes of the <i>NFT ID</i> which is the BLAKE2b-256 hash of the outputID that created it.</td>
                    </tr>
                </table>
            </details>
        </td>
    </tr>
</table>
<h5 id="issuer-feature"><a class="header" href="#issuer-feature">Issuer Feature</a></h5>
<p>The issuer feature is a special case of the sender feature that is only supported by outputs that implement a UTXO state
machine with <a href="tips/TIP-0018/tip-0018.html#chain-constraint-in-utxo">chain constraint</a> (alias, NFT).
Only when the state machine is created (e.g. minted) it is checked during transaction validation that an output
corresponding to the <code>Issuer</code> address is consumed. In every future transition of the state machine, it is instead
checked that the issuer feature is still present and unchanged.</p>
<h6 id="additional-semantic-transaction-validation-rule-2"><a class="header" href="#additional-semantic-transaction-validation-rule-2">Additional semantic transaction validation rule:</a></h6>
<ul>
<li>When an <i>Issuer Feature</i> is present in an output representing the initial state of an UTXO state machine, the
transaction that contains this output is valid, if and only if <code>Issuer</code> address is unlocked in the transaction. Based on the <code>Address Type</code>, an address is unlocked in the transaction, if and only if:
<ul>
<li><i>Ed25519 Address</i>:
<ul>
<li>The <i>Unlock</i> of the first output in the transaction that contains the address is a valid <i>Signature Unlock</i> with respect to the address.</li>
</ul>
</li>
<li><i>Alias Address</i>:
<ul>
<li>The <i>Alias Output</i> that defines the address is <strong>state transitioned</strong> in the transaction. A governance transition does not unlock the address.</li>
</ul>
</li>
<li><i>NFT Address</i>:
<ul>
<li>The <i>NFT Output</i> that defines the address is consumed as input in the transaction.</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>The main use case is proving authenticity of NFTs. Whenever an NFT is minted as an NFT output, the creator (issuer) can
fill the <i>Issuer Feature</i> with their address that they have to unlock in the transaction. Issuers then can publicly
disclose their addresses to prove the authenticity of the NFT once it is in circulation.</p>
<details>
    <summary>Issuer Feature</summary>
    <blockquote>
        Identifies the validated issuer of the UTXO state machine.
    </blockquote>
</details>
<table>
    <tr>
        <td><b>Name</b></td>
        <td><b>Type</b></td>
        <td><b>Description</b></td>
    </tr>
    <tr>
        <td>Feature Type</td>
        <td>uint8</td>
        <td>
            Set to <strong>value 1</strong> to denote an <i>Issuer Feature</i>.
        </td>
    </tr>
    <tr>
        <td valign="top">Address <code>oneOf</code></td>
        <td colspan="2">
            <details>
                <summary>Ed25519 Address</summary>
                <table>
                    <tr>
                        <td><b>Name</b></td>
                        <td><b>Type</b></td>
                        <td><b>Description</b></td>
                    </tr>
                    <tr>
                        <td>Address Type</td>
                        <td>uint8</td>
                        <td>
                            Set to <strong>value 0</strong> to denote an <i>Ed25519 Address</i>.
                        </td>
                    </tr>
                    <tr>
                        <td>PubKeyHash</td>
                        <td>ByteArray[32]</td>
                        <td>The raw bytes of the Ed25519 address which is a BLAKE2b-256 hash of the Ed25519 public key.</td>
                    </tr>
                </table>
            </details>
            <details>
                <summary>Alias Address</summary>
                <table>
                    <tr>
                        <td><b>Name</b></td>
                        <td><b>Type</b></td>
                        <td><b>Description</b></td>
                    </tr>
                    <tr>
                        <td>Address Type</td>
                        <td>uint8</td>
                        <td>
                            Set to <strong>value 8</strong> to denote an <i>Alias Address</i>.
                        </td>
                    </tr>
                    <tr>
                        <td>Alias ID</td>
                        <td>ByteArray[32]</td>
                        <td>The raw bytes of the <i>Alias ID</i> which is the BLAKE2b-256 hash of the outputID that created it.</td>
                    </tr>
                </table>
            </details>
            <details>
                <summary>NFT Address</summary>
                <table>
                    <tr>
                        <td><b>Name</b></td>
                        <td><b>Type</b></td>
                        <td><b>Description</b></td>
                    </tr>
                    <tr>
                        <td>Address Type</td>
                        <td>uint8</td>
                        <td>
                            Set to <strong>value 16</strong> to denote an <i>NFT Address</i>.
                        </td>
                    </tr>
                    <tr>
                        <td>NFT ID</td>
                        <td>ByteArray[32]</td>
                        <td>The raw bytes of the <i>NFT ID</i> which is the BLAKE2b-256 hash of the outputID that created it.</td>
                    </tr>
                </table>
            </details>
        </td>
    </tr>
</table>
<p>Whenever a chain account mints an NFT on layer 1 on behalf of some user, the <code>Issuer</code> field can only contain the
chain's address, since user does not sign the layer 1 transaction. As a consequence, artist would have to mint NFTs
themselves on layer 1 and then deposit it to chains if they want to place their own address in the <code>Issuer</code> field.</p>
<h5 id="metadata-feature"><a class="header" href="#metadata-feature">Metadata Feature</a></h5>
<p>Outputs may carry additional data with them that is interpreted by higher layer applications built on the Tangle. The
protocol treats this metadata as pure binary data, it has no effect on the validity of an output except that it
increases the required storage deposit. ISC is a great example of a higher layer protocol that makes use of
<i>Metadata Feature</i>: smart contract request parameters are encoded in the metadata field of outputs.</p>
<h6 id="additional-syntactic-transaction-validation-rules-2"><a class="header" href="#additional-syntactic-transaction-validation-rules-2">Additional syntactic transaction validation rules:</a></h6>
<ul>
<li>An output with <i>Metadata Feature</i> is valid, if and only if 0 &lt; <code>length(Data)</code> ≤ <code>Max Metadata Length</code>.</li>
</ul>
<details>
    <summary>Metadata Feature</summary>
    <blockquote>
        Defines metadata (arbitrary binary data) that will be stored in the output.
    </blockquote>
</details>
<table>
    <tr>
        <td><b>Name</b></td>
        <td><b>Type</b></td>
        <td><b>Description</b></td>
    </tr>
    <tr>
        <td>Feature Type</td>
        <td>uint8</td>
        <td>
            Set to <strong>value 2</strong> to denote a <i>Metadata Feature</i>.
        </td>
    </tr>
    <tr>
        <td>Data</td>
        <td>(uint16)ByteArray</td>
        <td>Binary data. A leading uint16 denotes its length.</td>
    </tr>
</table>
<h4 id="tag-feature"><a class="header" href="#tag-feature">Tag Feature</a></h4>
<p>A <i>Tag Feature</i> makes it possible to tag outputs with an index, so they can be retrieved through an indexer API not
only by their address, but also based on the <code>Tag</code>. <strong>The combination of a <i>Tag Feature</i>, a
<i>Metadata Feature</i> and a <i>Sender Feature</i> makes it possible to retrieve data associated to an address and stored
in outputs that were created by a specific party (<code>Sender</code>) for a specific purpose (<code>Tag</code>).</strong></p>
<p>An example use case is voting on the Tangle via the <a href="https://github.com/iota-community/treasury/blob/main/specifications/hornet-participation-plugin.md">participation</a> plugin.</p>
<h5 id="additional-syntactic-transaction-validation-rules-3"><a class="header" href="#additional-syntactic-transaction-validation-rules-3">Additional syntactic transaction validation rules:</a></h5>
<ul>
<li>An output with <i>Tag Feature</i> is valid, if and only if 0 &lt; <code>length(Tag)</code> ≤
<code>Max Tag Length</code>.</li>
</ul>
<details>
    <summary>Tag Feature</summary>
    <blockquote>
        Defines an indexation tag to which the output can be indexed by additional node plugins.
    </blockquote>
</details>
<table>
    <tr>
        <td><b>Name</b></td>
        <td><b>Type</b></td>
        <td><b>Description</b></td>
    </tr>
    <tr>
        <td>Feature Type</td>
        <td>uint8</td>
        <td>
            Set to <strong>value 3</strong> to denote a <i>Tag Feature</i>.
        </td>
    </tr>
    <tr>
        <td>Tag</td>
        <td>(uint8)ByteArray</td>
        <td>Binary indexation tag. A leading uint8 denotes its length.</td>
    </tr>
</table>
<h3 id="chain-constraint-in-utxo"><a class="header" href="#chain-constraint-in-utxo">Chain Constraint in UTXO</a></h3>
<p>Previously created transaction outputs are destroyed when they are consumed in a subsequent transaction as an input.
The chain constraint makes it possible to <strong>carry the UTXO state machine state encoded in outputs across transactions.</strong>
When an output with chain constraint is consumed, that transaction has to create a single subsequent output that
carries the state forward. The <strong>state can be updated according to the transition rules defined for the given type of
output and its current state</strong>. As a consequence, each such output has a unique successor, and together they form a path
or <em>chain</em> in the graph induced by the UTXO spends. Each chain is identified by its globally unique identifier.</p>
<p><img src="tips/TIP-0018/chain-constraint.png" alt="" /></p>
<p>Alias outputs, foundry outputs and NFT outputs all use this chain constraint concept and define their own unique
identifiers.</p>
<h2 id="output-design"><a class="header" href="#output-design">Output Design</a></h2>
<p>In the following, we define four new output types. They are all designed with specific use cases in mind:</p>
<ul>
<li><strong>Basic Output</strong>: transfer of funds with attached metadata and optional spending restrictions. Main use cases are
on-ledger ISC requests, native asset transfers and indexed data storage in the UTXO ledger.</li>
<li><strong>Alias Output</strong>: representing ISC chain accounts on L1 that can process requests and transfer funds.</li>
<li><strong>Foundry Output</strong>: supply control of user defined native tokens. A vehicle for cross-chain asset transfers and asset
wrapping.</li>
<li><strong>NFT Output</strong>: an output that represents a Non-fungible token with attached metadata and proof-of-origin. A NFT is
represented as an output so that the token and metadata are transferred together, for example as a smart contract
requests. NFTs are possible to implement with native tokens as well, but then ownership of the token does not mean
ownership of the foundry that holds its metadata.</li>
</ul>
<p>The validation of outputs is part of the transaction validation process. There are two levels of validation for
transactions: syntactic and semantic validation. The former validates the structure of the transaction (and outputs),
while the latter validates whether protocol rules are respected in the semantic context of the transaction. Outputs
hence are validated on both levels:</p>
<ol>
<li><strong>Transaction Syntactic Validation</strong>: validates the structure of each output created by the transaction.</li>
<li><strong>Transaction Semantic Validation</strong>:
<ul>
<li><strong>For consumed outputs</strong>: validates whether the output can be unlocked in a transaction given the semantic
transaction context.</li>
<li><strong>For created outputs</strong>: validates whether the output can be created in a transaction given the semantic
transaction context.</li>
</ul>
</li>
</ol>
<p>Each new output type may add its own validation rules which become part of the transaction validation rules if the
output is placed inside a transaction. <i>Unlock Conditions</i> and <i>Features</i> described previously also add
constraints to transaction validation when they are placed in outputs.</p>
<h2 id="basic-output"><a class="header" href="#basic-output">Basic Output</a></h2>
<p><i>Basic Output</i> can hold native tokens and might have several unlock conditions and optional features. The
combination of several features provide the base functionality for the output to be used as an on-ledger smart contract
request:</p>
<ul>
<li>Verified <code>Sender</code>,</li>
<li>Attached <code>Metadata</code> that can encode the request payload for layer 2,</li>
<li><code>Return Amount</code> to get back the storage deposit,</li>
<li><code>Timelock</code> to be able to time requests,</li>
<li><code>Expiration</code> to recover funds in case of chain inactivity.</li>
</ul>
<p>Besides, the <i>Tag Feature</i> is a tool to store arbitrary, indexed data with verified origin in the ledger.</p>
<p>Note, that a <i>Basic Output</i> in its simplest possible form with only an <i>Address Unlock Condition</i> and
without features or native tokens is functionally equivalent to a <i>SigLockedSingleOutput</i>: it has an address
and an IOTA balance. Therefore, 
aforementioned output type, that was <a href="tips/TIP-0018/../TIP-0007/tip-0007.html">introduced for Chrysalis Part 2 via TIP-7</a>
is deprecated with the replacement of the <a href="tips/TIP-0018/../TIP-0020/tip-0020.html">TIP-20 Transaction Payload</a>.</p>
<table>
    <details>
        <summary>Basic Output</summary>
        <blockquote>
            Describes a basic output with optional features.
        </blockquote>
        <table>
            <tr>
                <td><b>Name</b></td>
                <td><b>Type</b></td>
                <td><b>Description</b></td>
            </tr>
            <tr>
                <td>Output Type</td>
                <td>uint8</td>
                <td>
                    Set to <strong>value 3</strong> to denote a <i>Basic Output</i>.
                </td>
            </tr>
            <tr>
                <td>Amount</td>
                <td>uint64</td>
                <td>The amount of IOTA coins to held by the output.</td>
            </tr>
            <tr>
                <td>Native Tokens Count</td>
                <td>uint8</td>
                <td>The number of native tokens held by the output.</td>
            </tr>
            <tr>
                <td valign="top">Native Tokens <code>optAnyOf</code></td>
                <td colspan="2">
                    <details>
                        <summary>Native Token</summary>
                        <table>
                            <tr>
                                <td><b>Name</b></td>
                                <td><b>Type</b></td>
                                <td><b>Description</b></td>
                            </tr>
                            <tr>
                                <td>Token ID</td>
                                <td>ByteArray[38]</td>
                                <td>
                                    Identifier of the native token.
                                </td>
                            </tr>
                            <tr>
                                <td>Amount</td>
                                <td>uint256</td>
                                <td>
                                    Amount of native tokens of the given <i>Token ID</i>.
                                </td>
                            </tr>
                        </table>
                    </details>
                </td>
            </tr>
            <tr>
                <td>Unlock Conditions Count</td>
                <td>uint8</td>
                <td>The number of unlock conditions following.</td>
            </tr>
            <tr>
                <td valign="top">Unlock Conditions <code>atMostOneOfEach</code></td>
                <td colspan="2">
                    <details>
                        <summary>Address Unlock Condition</summary>
                        <table>
                            <tr>
                                <td><b>Name</b></td>
                                <td><b>Type</b></td>
                                <td><b>Description</b></td>
                            </tr>
                            <tr>
                                <td>Unlock Condition Type</td>
                                <td>uint8</td>
                                <td>
                                    Set to <strong>value 0</strong> to denote an <i>Address Unlock Condition</i>.
                                </td>
                            </tr>
                            <tr>
                                <td>Address</td>
                                <td colspan="2">
                                    <details>
                                        <summary>Ed25519 Address</summary>
                                        <table>
                                            <tr>
                                                <td><b>Name</b></td>
                                                <td><b>Type</b></td>
                                                <td><b>Description</b></td>
                                            </tr>
                                            <tr>
                                                <td>Address Type</td>
                                                <td>uint8</td>
                                                <td>
                                                    Set to <strong>value 0</strong> to denote an <i>Ed25519 Address</i>.
                                                </td>
                                            </tr>
                                            <tr>
                                                <td>PubKeyHash</td>
                                                <td>ByteArray[32]</td>
                                                <td>The raw bytes of the Ed25519 address which is a BLAKE2b-256 hash of the Ed25519 public key.</td>
                                            </tr>
                                        </table>
                                    </details>
                                    <details>
                                        <summary>Alias Address</summary>
                                        <table>
                                            <tr>
                                                <td><b>Name</b></td>
                                                <td><b>Type</b></td>
                                                <td><b>Description</b></td>
                                            </tr>
                                            <tr>
                                                <td>Address Type</td>
                                                <td>uint8</td>
                                                <td>
                                                    Set to <strong>value 8</strong> to denote an <i>Alias Address</i>.
                                                </td>
                                            </tr>
                                            <tr>
                                                <td>Alias ID</td>
                                                <td>ByteArray[32]</td>
                                                <td>The raw bytes of the <i>Alias ID</i> which is the BLAKE2b-256 hash of the outputID that created it.</td>
                                            </tr>
                                        </table>
                                    </details>
                                    <details>
                                        <summary>NFT Address</summary>
                                        <table>
                                            <tr>
                                                <td><b>Name</b></td>
                                                <td><b>Type</b></td>
                                                <td><b>Description</b></td>
                                            </tr>
                                            <tr>
                                                <td>Address Type</td>
                                                <td>uint8</td>
                                                <td>
                                                    Set to <strong>value 16</strong> to denote an <i>NFT Address</i>.
                                                </td>
                                            </tr>
                                            <tr>
                                                <td>NFT ID</td>
                                                <td>ByteArray[32]</td>
                                                <td>The raw bytes of the <i>NFT ID</i> which is the BLAKE2b-256 hash of the outputID that created it.</td>
                                            </tr>
                                        </table>
                                    </details>
                                </td>
                            </tr>
                        </table>
                    </details>
                    <details>
                        <summary>Storage Deposit Return Unlock Condition</summary>
                        <blockquote>
                            Defines the amount of IOTAs used as storage deposit that have to be returned to <i>Return Address</i>.
                        </blockquote>
                        <table>
                            <tr>
                                <td><b>Name</b></td>
                                <td><b>Type</b></td>
                                <td><b>Description</b></td>
                            </tr>
                            <tr>
                                <td>Unlock Condition Type</td>
                                <td>uint8</td>
                                <td>
                                    Set to <strong>value 1</strong> to denote a <i>Storage Deposit Return Unlock Condition</i>.
                                </td>
                            </tr>
                            <tr>
                                <td valign="top">Return Address <code>oneOf</code></td>
                                <td colspan="2">
                                    <details>
                                        <summary>Ed25519 Address</summary>
                                        <table>
                                            <tr>
                                                <td><b>Name</b></td>
                                                <td><b>Type</b></td>
                                                <td><b>Description</b></td>
                                            </tr>
                                            <tr>
                                                <td>Address Type</td>
                                                <td>uint8</td>
                                                <td>
                                                    Set to <strong>value 0</strong> to denote an <i>Ed25519 Address</i>.
                                                </td>
                                            </tr>
                                            <tr>
                                                <td>PubKeyHash</td>
                                                <td>ByteArray[32]</td>
                                                <td>The raw bytes of the Ed25519 address which is a BLAKE2b-256 hash of the Ed25519 public key.</td>
                                            </tr>
                                        </table>
                                    </details>
                                    <details>
                                        <summary>Alias Address</summary>
                                        <table>
                                            <tr>
                                                <td><b>Name</b></td>
                                                <td><b>Type</b></td>
                                                <td><b>Description</b></td>
                                            </tr>
                                            <tr>
                                                <td>Address Type</td>
                                                <td>uint8</td>
                                                <td>
                                                    Set to <strong>value 8</strong> to denote an <i>Alias Address</i>.
                                                </td>
                                            </tr>
                                            <tr>
                                                <td>Alias ID</td>
                                                <td>ByteArray[32]</td>
                                                <td>The raw bytes of the <i>Alias ID</i> which is the BLAKE2b-256 hash of the outputID that created it.</td>
                                            </tr>
                                        </table>
                                    </details>
                                    <details>
                                        <summary>NFT Address</summary>
                                        <table>
                                            <tr>
                                                <td><b>Name</b></td>
                                                <td><b>Type</b></td>
                                                <td><b>Description</b></td>
                                            </tr>
                                            <tr>
                                                <td>Address Type</td>
                                                <td>uint8</td>
                                                <td>
                                                    Set to <strong>value 16</strong> to denote an <i>NFT Address</i>.
                                                </td>
                                            </tr>
                                            <tr>
                                                <td>NFT ID</td>
                                                <td>ByteArray[32]</td>
                                                <td>The raw bytes of the <i>NFT ID</i> which is the BLAKE2b-256 hash of the outputID that created it.</td>
                                            </tr>
                                        </table>
                                    </details>
                                </td>
                            </tr>
                            <tr>
                                <td>Return Amount</td>
                                <td>uint64</td>
                                <td>
                                    Amount of IOTA coins the consuming transaction should deposit to the address defined in <i>Return Address</i>.
                                </td>
                            </tr>
                        </table>
                    </details>
                    <details>
                        <summary>Timelock Unlock Condition</summary>
                        <blockquote>
                            Defines a unix timestamp until which the output can not be unlocked.
                        </blockquote>
                        <table>
                            <tr>
                                <td><b>Name</b></td>
                                <td><b>Type</b></td>
                                <td><b>Description</b></td>
                            </tr>
                            <tr>
                                <td>Unlock Condition Type</td>
                                <td>uint8</td>
                                <td>
                                    Set to <strong>value 2</strong> to denote a <i>Timelock Unlock Condition</i>.
                                </td>
                            </tr>
                            <tr>
                                <td>Unix Time</td>
                                <td>uint32</td>
                                <td>
                                    Unix time (seconds since Unix epoch) starting from which the output can be consumed.
                                </td>
                            </tr>
                        </table>
                    </details>
                    <details>
                        <summary>Expiration Unlock Condition</summary>
                        <blockquote>
                            Defines a unix time until which only <i>Address</i>, defined in <i>Address Unlock Condition</i>, is allowed to
                            unlock the output. After the unix time is reached or passed, only <i>Return Address</i> can unlock it.
                        </blockquote>
                        <table>
                            <tr>
                                <td><b>Name</b></td>
                                <td><b>Type</b></td>
                                <td><b>Description</b></td>
                            </tr>
                            <tr>
                                <td>Unlock Condition Type</td>
                                <td>uint8</td>
                                <td>
                                    Set to <strong>value 3</strong> to denote a <i>Expiration Unlock Condition</i>.
                                </td>
                            </tr>
                            <tr>
                                <td valign="top">Return Address <code>oneOf</code></td>
                                <td colspan="2">
                                    <details>
                                        <summary>Ed25519 Address</summary>
                                        <table>
                                            <tr>
                                                <td><b>Name</b></td>
                                                <td><b>Type</b></td>
                                                <td><b>Description</b></td>
                                            </tr>
                                            <tr>
                                                <td>Address Type</td>
                                                <td>uint8</td>
                                                <td>
                                                    Set to <strong>value 0</strong> to denote an <i>Ed25519 Address</i>.
                                                </td>
                                            </tr>
                                            <tr>
                                                <td>PubKeyHash</td>
                                                <td>ByteArray[32]</td>
                                                <td>The raw bytes of the Ed25519 address which is a BLAKE2b-256 hash of the Ed25519 public key.</td>
                                            </tr>
                                        </table>
                                    </details>
                                    <details>
                                        <summary>Alias Address</summary>
                                        <table>
                                            <tr>
                                                <td><b>Name</b></td>
                                                <td><b>Type</b></td>
                                                <td><b>Description</b></td>
                                            </tr>
                                            <tr>
                                                <td>Address Type</td>
                                                <td>uint8</td>
                                                <td>
                                                    Set to <strong>value 8</strong> to denote an <i>Alias Address</i>.
                                                </td>
                                            </tr>
                                            <tr>
                                                <td>Alias ID</td>
                                                <td>ByteArray[32]</td>
                                                <td>The raw bytes of the <i>Alias ID</i> which is the BLAKE2b-256 hash of the outputID that created it.</td>
                                            </tr>
                                        </table>
                                    </details>
                                    <details>
                                        <summary>NFT Address</summary>
                                        <table>
                                            <tr>
                                                <td><b>Name</b></td>
                                                <td><b>Type</b></td>
                                                <td><b>Description</b></td>
                                            </tr>
                                            <tr>
                                                <td>Address Type</td>
                                                <td>uint8</td>
                                                <td>
                                                    Set to <strong>value 16</strong> to denote an <i>NFT Address</i>.
                                                </td>
                                            </tr>
                                            <tr>
                                                <td>NFT ID</td>
                                                <td>ByteArray[32]</td>
                                                <td>The raw bytes of the <i>NFT ID</i> which is the BLAKE2b-256 hash of the outputID that created it.</td>
                                            </tr>
                                        </table>
                                    </details>
                                </td>
                            </tr>
                            <tr>
                                <td>Unix Time</td>
                                <td>uint32</td>
                                <td>
                                    Before this unix time, <i>Address Unlock Condition</i> is allowed to unlock the output, after that only the address defined in <i>Return Address</i>.
                                </td>
                            </tr>
                        </table>
                    </details>
                </td>
            </tr>
            <tr>
                <td>Features Count</td>
                <td>uint8</td>
                <td>The number of features following.</td>
            </tr>
            <tr>
                <td valign="top">Features <code>atMostOneOfEach</code></td>
                <td colspan="2">
                    <details>
                        <summary>Sender Feature</summary>
                        <blockquote>
                            Identifies the validated sender of the output.
                        </blockquote>
                        <table>
                            <tr>
                                <td><b>Name</b></td>
                                <td><b>Type</b></td>
                                <td><b>Description</b></td>
                            </tr>
                            <tr>
                                <td>Feature Type</td>
                                <td>uint8</td>
                                <td>
                                    Set to <strong>value 0</strong> to denote a <i>Sender Feature</i>.
                                </td>
                            </tr>
                            <tr>
                                <td valign="top">Address <code>oneOf</code></td>
                                <td colspan="2">
                                    <details>
                                        <summary>Ed25519 Address</summary>
                                        <table>
                                            <tr>
                                                <td><b>Name</b></td>
                                                <td><b>Type</b></td>
                                                <td><b>Description</b></td>
                                            </tr>
                                            <tr>
                                                <td>Address Type</td>
                                                <td>uint8</td>
                                                <td>
                                                    Set to <strong>value 0</strong> to denote an <i>Ed25519 Address</i>.
                                                </td>
                                            </tr>
                                            <tr>
                                                <td>PubKeyHash</td>
                                                <td>ByteArray[32]</td>
                                                <td>The raw bytes of the Ed25519 address which is a BLAKE2b-256 hash of the Ed25519 public key.</td>
                                            </tr>
                                        </table>
                                    </details>
                                    <details>
                                        <summary>Alias Address</summary>
                                        <table>
                                            <tr>
                                                <td><b>Name</b></td>
                                                <td><b>Type</b></td>
                                                <td><b>Description</b></td>
                                            </tr>
                                            <tr>
                                                <td>Address Type</td>
                                                <td>uint8</td>
                                                <td>
                                                    Set to <strong>value 8</strong> to denote an <i>Alias Address</i>.
                                                </td>
                                            </tr>
                                            <tr>
                                                <td>Alias ID</td>
                                                <td>ByteArray[32]</td>
                                                <td>The raw bytes of the <i>Alias ID</i> which is the BLAKE2b-256 hash of the outputID that created it.</td>
                                            </tr>
                                        </table>
                                    </details>
                                    <details>
                                        <summary>NFT Address</summary>
                                        <table>
                                            <tr>
                                                <td><b>Name</b></td>
                                                <td><b>Type</b></td>
                                                <td><b>Description</b></td>
                                            </tr>
                                            <tr>
                                                <td>Address Type</td>
                                                <td>uint8</td>
                                                <td>
                                                    Set to <strong>value 16</strong> to denote an <i>NFT Address</i>.
                                                </td>
                                            </tr>
                                            <tr>
                                                <td>NFT ID</td>
                                                <td>ByteArray[32]</td>
                                                <td>The raw bytes of the <i>NFT ID</i> which is the BLAKE2b-256 hash of the outputID that created it.</td>
                                            </tr>
                                        </table>
                                    </details>
                                </td>
                            </tr>
                        </table>
                    </details>
                    <details>
                        <summary>Metadata Feature</summary>
                        <blockquote>
                            Defines metadata (arbitrary binary data) that will be stored in the output.
                        </blockquote>
                        <table>
                            <tr>
                                <td><b>Name</b></td>
                                <td><b>Type</b></td>
                                <td><b>Description</b></td>
                            </tr>
                            <tr>
                                <td>Feature Type</td>
                                <td>uint8</td>
                                <td>
                                    Set to <strong>value 2</strong> to denote a <i>Metadata Feature</i>.
                                </td>
                            </tr>
                            <tr>
                                <td>Data</td>
                                <td>(uint16)ByteArray</td>
                                <td>Binary data. A leading uint16 denotes its length.</td>
                            </tr>
                        </table>
                    </details>
                    <details>
                        <summary>Tag Feature</summary>
                        <blockquote>
                            Defines an indexation tag to which the output can be indexed by additional node plugins.
                        </blockquote>
                        <table>
                            <tr>
                                <td><b>Name</b></td>
                                <td><b>Type</b></td>
                                <td><b>Description</b></td>
                            </tr>
                            <tr>
                                <td>Feature Type</td>
                                <td>uint8</td>
                                <td>
                                    Set to <strong>value 3</strong> to denote a <i>Tag Feature</i>.
                                </td>
                            </tr>
                            <tr>
                                <td>Tag</td>
                                <td>(uint8)ByteArray</td>
                                <td>Binary indexation data. A leading uint8 denotes its length.</td>
                            </tr>
                        </table>
                    </details>
                </td>
            </tr>
        </table>
    </details>
</table>
<h3 id="additional-transaction-syntactic-validation-rules"><a class="header" href="#additional-transaction-syntactic-validation-rules">Additional Transaction Syntactic Validation Rules</a></h3>
<ul>
<li><code>Amount</code> field must fulfill the dust protection requirements and must not be <code>0</code>.</li>
<li><code>Amount</code> field must be ≤ <code>Max IOTA Supply</code>.</li>
<li><code>Native Tokens Count</code> must not be greater than <code>Max Native Tokens Count</code>.</li>
<li><code>Native Tokens</code> must be lexicographically sorted based on <code>Token ID</code>.</li>
<li>Each <i>Native Token</i> must be unique in the set of <code>Native Tokens</code> based on its <code>Token ID</code>. No duplicates are
allowed.</li>
<li><code>Amount</code> of any <i>Native Token</i> must not be <code>0</code>.</li>
<li>It must hold true that <code>1</code> ≤ <code>Unlock Conditions Count</code> ≤ <code>4</code>.</li>
<li><code>Unlock Condition Type</code> of an <i>Unlock Condition</i> must define one of the following types:
<ul>
<li><i>Address Unlock Condition</i></li>
<li><i>Storage Deposit Return Unlock Condition</i></li>
<li><i>Timelock Unlock Condition</i></li>
<li><i>Expiration Unlock Condition</i></li>
</ul>
</li>
<li><i>Unlock Conditions</i> must be sorted in ascending order based on their <code>Unlock Condition Type</code>.</li>
<li>Syntactic validation of all present unlock conditions must pass.</li>
<li><i>Address Unlock Condition</i> must be present.</li>
<li>It must hold true that <code>0</code> ≤ <code>Features Count</code> ≤ <code>3</code>.</li>
<li><code>Feature Type</code> of a <i>Feature</i> must define one of the following types:
<ul>
<li><i>Sender Feature</i></li>
<li><i>Metadata Feature</i></li>
<li><i>Tag Feature</i></li>
</ul>
</li>
<li><i>Features</i> must be sorted in ascending order based on their <code>Feature Type</code>.</li>
<li>Syntactic validation of all present features must pass.</li>
</ul>
<h3 id="additional-transaction-semantic-validation-rules"><a class="header" href="#additional-transaction-semantic-validation-rules">Additional Transaction Semantic Validation Rules</a></h3>
<h4 id="consumed-outputs"><a class="header" href="#consumed-outputs">Consumed Outputs</a></h4>
<ul>
<li>The unlock of the input must correspond to <code>Address</code> field in the <i>Address Unlock Condition</i> and the
unlock must be valid.</li>
<li>The unlock is valid if and only if all unlock conditions and features present in the output validate.</li>
</ul>
<h4 id="created-outputs"><a class="header" href="#created-outputs">Created Outputs</a></h4>
<ul>
<li>All <i>Unlock Condition</i> imposed transaction validation criteria must be fulfilled.</li>
<li>All <i>Feature</i> imposed transaction validation criteria must be fulfilled.</li>
</ul>
<h2 id="alias-output"><a class="header" href="#alias-output">Alias Output</a></h2>
<p>The <i>Alias Output</i> is a specific implementation of a UTXO state machine. <code>Alias ID</code>, the unique identifier of an
instance of the deployed state machine, is generated deterministically by the protocol and is not allowed to change in
any future state transitions.</p>
<p><i>Alias Output</i> represents an alias account in the ledger with two control levels and a permanent
<i>Alias Address</i>. The account owns other outputs that are locked under <i>Alias Address</i>. The account keeps
track of state transitions (<code>State Index</code> counter), controlled foundries (<code>Foundry Counter</code>) and anchors the layer 2
state as metadata into the UTXO ledger.</p>
<table>
    <details>
        <summary>Alias Output</summary>
        <blockquote>
            Describes an alias account in the ledger that can be controlled by the state and governance controllers.
        </blockquote>
        <table>
            <tr>
                <td><b>Name</b></td>
                <td><b>Type</b></td>
                <td><b>Description</b></td>
            </tr>
            <tr>
                <td>Output Type</td>
                <td>uint8</td>
                <td>
                    Set to <strong>value 4</strong> to denote a <i>Alias Output</i>.
                </td>
            </tr>
            <tr>
                <td>Amount</td>
                <td>uint64</td>
                <td>The amount of IOTA coins held by the output.</td>
            </tr>
            <tr>
                <td>Native Tokens Count</td>
                <td>uint8</td>
                <td>The number of native tokens held by the output.</td>
            </tr>
            <tr>
                <td valign="top">Native Tokens <code>optAnyOf</code></td>
                <td colspan="2">
                    <details>
                        <summary>Native Token</summary>
                        <table>
                            <tr>
                                <td><b>Name</b></td>
                                <td><b>Type</b></td>
                                <td><b>Description</b></td>
                            </tr>
                            <tr>
                                <td>Token ID</td>
                                <td>ByteArray[38]</td>
                                <td>
                                    Identifier of the native token.
                                </td>
                            </tr>
                            <tr>
                                <td>Amount</td>
                                <td>uint256</td>
                                <td>
                                    Amount of native tokens of the given <i>Token ID</i>.
                                </td>
                            </tr>
                        </table>
                    </details>
                </td>
            </tr>
            <tr>
                <td>Alias ID</td>
                <td>ByteArray[32]</td>
                <td>Unique identifier of the alias, which is the BLAKE2b-256 hash of the <i>Output ID</i> that created it.<i> Alias Address = Alias Address Type || Alias ID</i></td>
            </tr>
            <tr>
                <td>State Index</td>
                <td>uint32</td>
                <td>A counter that must increase by 1 every time the alias is state transitioned.</td>
            </tr>
            <tr>
                <td>State Metadata</td>
                <td>(uint16)ByteArray</td>
                <td>Metadata that can only be changed by the state controller. A leading uint16 denotes its length.</td>
            </tr>
            <tr>
                <td>Foundry Counter</td>
                <td>uint32</td>
                <td>A counter that denotes the number of foundries created by this alias account.</td>
            </tr>
            <tr>
                <td>Unlock Conditions Count</td>
                <td>uint8</td>
                <td>The number of unlock conditions following.</td>
            </tr>
            <tr>
                <td valign="top">Unlock Conditions <code>atMostOneOfEach</code></td>
                <td colspan="2">
                    <details>
                        <summary>State Controller Address Unlock Condition</summary>
                        <table>
                            <tr>
                                <td><b>Name</b></td>
                                <td><b>Type</b></td>
                                <td><b>Description</b></td>
                            </tr>
                            <tr>
                                <td>Unlock Condition Type</td>
                                <td>uint8</td>
                                <td>
                                    Set to <strong>value 4</strong> to denote an <i>State Controller Address Unlock Condition</i>.
                                </td>
                            </tr>
                            <tr>
                                <td>Address</td>
                                <td colspan="2">
                                    <details>
                                        <summary>Ed25519 Address</summary>
                                        <table>
                                            <tr>
                                                <td><b>Name</b></td>
                                                <td><b>Type</b></td>
                                                <td><b>Description</b></td>
                                            </tr>
                                            <tr>
                                                <td>Address Type</td>
                                                <td>uint8</td>
                                                <td>
                                                    Set to <strong>value 0</strong> to denote an <i>Ed25519 Address</i>.
                                                </td>
                                            </tr>
                                            <tr>
                                                <td>PubKeyHash</td>
                                                <td>ByteArray[32]</td>
                                                <td>The raw bytes of the Ed25519 address which is a BLAKE2b-256 hash of the Ed25519 public key.</td>
                                            </tr>
                                        </table>
                                    </details>
                                    <details>
                                        <summary>Alias Address</summary>
                                        <table>
                                            <tr>
                                                <td><b>Name</b></td>
                                                <td><b>Type</b></td>
                                                <td><b>Description</b></td>
                                            </tr>
                                            <tr>
                                                <td>Address Type</td>
                                                <td>uint8</td>
                                                <td>
                                                    Set to <strong>value 8</strong> to denote an <i>Alias Address</i>.
                                                </td>
                                            </tr>
                                            <tr>
                                                <td>Alias ID</td>
                                                <td>ByteArray[32]</td>
                                                <td>The raw bytes of the <i>Alias ID</i> which is the BLAKE2b-256 hash of the outputID that created it.</td>
                                            </tr>
                                        </table>
                                    </details>
                                    <details>
                                        <summary>NFT Address</summary>
                                        <table>
                                            <tr>
                                                <td><b>Name</b></td>
                                                <td><b>Type</b></td>
                                                <td><b>Description</b></td>
                                            </tr>
                                            <tr>
                                                <td>Address Type</td>
                                                <td>uint8</td>
                                                <td>
                                                    Set to <strong>value 16</strong> to denote an <i>NFT Address</i>.
                                                </td>
                                            </tr>
                                            <tr>
                                                <td>NFT ID</td>
                                                <td>ByteArray[32]</td>
                                                <td>The raw bytes of the <i>NFT ID</i> which is the BLAKE2b-256 hash of the outputID that created it.</td>
                                            </tr>
                                        </table>
                                    </details>
                                </td>
                            </tr>
                        </table>
                    </details>
                    <details>
                        <summary>Governor Address Unlock Condition</summary>
                        <table>
                            <tr>
                                <td><b>Name</b></td>
                                <td><b>Type</b></td>
                                <td><b>Description</b></td>
                            </tr>
                            <tr>
                                <td>Unlock Condition Type</td>
                                <td>uint8</td>
                                <td>
                                    Set to <strong>value 5</strong> to denote an <i>Governor Address Unlock Condition</i>.
                                </td>
                            </tr>
                            <tr>
                                <td>Address</td>
                                <td colspan="2">
                                    <details>
                                        <summary>Ed25519 Address</summary>
                                        <table>
                                            <tr>
                                                <td><b>Name</b></td>
                                                <td><b>Type</b></td>
                                                <td><b>Description</b></td>
                                            </tr>
                                            <tr>
                                                <td>Address Type</td>
                                                <td>uint8</td>
                                                <td>
                                                    Set to <strong>value 0</strong> to denote an <i>Ed25519 Address</i>.
                                                </td>
                                            </tr>
                                            <tr>
                                                <td>PubKeyHash</td>
                                                <td>ByteArray[32]</td>
                                                <td>The raw bytes of the Ed25519 address which is a BLAKE2b-256 hash of the Ed25519 public key.</td>
                                            </tr>
                                        </table>
                                    </details>
                                    <details>
                                        <summary>Alias Address</summary>
                                        <table>
                                            <tr>
                                                <td><b>Name</b></td>
                                                <td><b>Type</b></td>
                                                <td><b>Description</b></td>
                                            </tr>
                                            <tr>
                                                <td>Address Type</td>
                                                <td>uint8</td>
                                                <td>
                                                    Set to <strong>value 8</strong> to denote an <i>Alias Address</i>.
                                                </td>
                                            </tr>
                                            <tr>
                                                <td>Alias ID</td>
                                                <td>ByteArray[32]</td>
                                                <td>The raw bytes of the <i>Alias ID</i> which is the BLAKE2b-256 hash of the outputID that created it.</td>
                                            </tr>
                                        </table>
                                    </details>
                                    <details>
                                        <summary>NFT Address</summary>
                                        <table>
                                            <tr>
                                                <td><b>Name</b></td>
                                                <td><b>Type</b></td>
                                                <td><b>Description</b></td>
                                            </tr>
                                            <tr>
                                                <td>Address Type</td>
                                                <td>uint8</td>
                                                <td>
                                                    Set to <strong>value 16</strong> to denote an <i>NFT Address</i>.
                                                </td>
                                            </tr>
                                            <tr>
                                                <td>NFT ID</td>
                                                <td>ByteArray[32]</td>
                                                <td>The raw bytes of the <i>NFT ID</i> which is the BLAKE2b-256 hash of the outputID that created it.</td>
                                            </tr>
                                        </table>
                                    </details>
                                </td>
                            </tr>
                        </table>
                    </details>
                </td>
            </tr>
            <tr>
                <td>Features Count</td>
                <td>uint8</td>
                <td>The number of features following.</td>
            </tr>
            <tr>
                <td valign="top">Features <code>atMostOneOfEach</code></td>
                <td colspan="2">
                    <details>
                        <summary>Sender Feature</summary>
                        <blockquote>
                            Identifies the validated sender of the output.
                        </blockquote>
                        <table>
                            <tr>
                                <td><b>Name</b></td>
                                <td><b>Type</b></td>
                                <td><b>Description</b></td>
                            </tr>
                            <tr>
                                <td>Feature Type</td>
                                <td>uint8</td>
                                <td>
                                    Set to <strong>value 0</strong> to denote a <i>Sender Feature</i>.
                                </td>
                            </tr>
                            <tr>
                                <td valign="top">Address <code>oneOf</code></td>
                                <td colspan="2">
                                    <details>
                                        <summary>Ed25519 Address</summary>
                                        <table>
                                            <tr>
                                                <td><b>Name</b></td>
                                                <td><b>Type</b></td>
                                                <td><b>Description</b></td>
                                            </tr>
                                            <tr>
                                                <td>Address Type</td>
                                                <td>uint8</td>
                                                <td>
                                                    Set to <strong>value 0</strong> to denote an <i>Ed25519 Address</i>.
                                                </td>
                                            </tr>
                                            <tr>
                                                <td>PubKeyHash</td>
                                                <td>ByteArray[32]</td>
                                                <td>The raw bytes of the Ed25519 address which is a BLAKE2b-256 hash of the Ed25519 public key.</td>
                                            </tr>
                                        </table>
                                    </details>
                                    <details>
                                        <summary>Alias Address</summary>
                                        <table>
                                            <tr>
                                                <td><b>Name</b></td>
                                                <td><b>Type</b></td>
                                                <td><b>Description</b></td>
                                            </tr>
                                            <tr>
                                                <td>Address Type</td>
                                                <td>uint8</td>
                                                <td>
                                                    Set to <strong>value 8</strong> to denote an <i>Alias Address</i>.
                                                </td>
                                            </tr>
                                            <tr>
                                                <td>Alias ID</td>
                                                <td>ByteArray[32]</td>
                                                <td>The raw bytes of the <i>Alias ID</i> which is the BLAKE2b-256 hash of the outputID that created it.</td>
                                            </tr>
                                        </table>
                                    </details>
                                    <details>
                                        <summary>NFT Address</summary>
                                        <table>
                                            <tr>
                                                <td><b>Name</b></td>
                                                <td><b>Type</b></td>
                                                <td><b>Description</b></td>
                                            </tr>
                                            <tr>
                                                <td>Address Type</td>
                                                <td>uint8</td>
                                                <td>
                                                    Set to <strong>value 16</strong> to denote an <i>NFT Address</i>.
                                                </td>
                                            </tr>
                                            <tr>
                                                <td>NFT ID</td>
                                                <td>ByteArray[32]</td>
                                                <td>The raw bytes of the <i>NFT ID</i> which is the BLAKE2b-256 hash of the outputID that created it.</td>
                                            </tr>
                                        </table>
                                    </details>
                                </td>
                            </tr>
                        </table>
                    </details>
                    <details>
                        <summary>Metadata Feature</summary>
                        <blockquote>
                            Defines metadata (arbitrary binary data) that will be stored in the output.
                        </blockquote>
                        <table>
                            <tr>
                                <td><b>Name</b></td>
                                <td><b>Type</b></td>
                                <td><b>Description</b></td>
                            </tr>
                            <tr>
                                <td>Feature Type</td>
                                <td>uint8</td>
                                <td>
                                    Set to <strong>value 2</strong> to denote a <i>Metadata Feature</i>.
                                </td>
                            </tr>
                            <tr>
                                <td>Data</td>
                                <td>(uint16)ByteArray</td>
                                <td>Binary data. A leading uint16 denotes its length.</td>
                            </tr>
                        </table>
                    </details>
                </td>
            </tr>
            <tr>
                <td>Immutable Features Count</td>
                <td>uint8</td>
                <td>The number of immutable features following. Immutable features are defined upon deployment of the UTXO state machine and are not allowed to change in any future state transition.</td>
            </tr>
            <tr>
                <td valign="top">Immutable Features <code>atMostOneOfEach</code></td>
                <td colspan="2">
                    <details>
                        <summary>Issuer Feature</summary>
                        <blockquote>
                            Identifies the validated issuer of the UTXO state machine.
                        </blockquote>
                        <table>
                            <tr>
                                <td><b>Name</b></td>
                                <td><b>Type</b></td>
                                <td><b>Description</b></td>
                            </tr>
                            <tr>
                                <td>Feature Type</td>
                                <td>uint8</td>
                                <td>
                                    Set to <strong>value 1</strong> to denote an <i>Issuer Feature</i>.
                                </td>
                            </tr>
                            <tr>
                                <td valign="top">Address <code>oneOf</code></td>
                                <td colspan="2">
                                    <details>
                                        <summary>Ed25519 Address</summary>
                                        <table>
                                            <tr>
                                                <td><b>Name</b></td>
                                                <td><b>Type</b></td>
                                                <td><b>Description</b></td>
                                            </tr>
                                            <tr>
                                                <td>Address Type</td>
                                                <td>uint8</td>
                                                <td>
                                                    Set to <strong>value 0</strong> to denote an <i>Ed25519 Address</i>.
                                                </td>
                                            </tr>
                                            <tr>
                                                <td>PubKeyHash</td>
                                                <td>ByteArray[32]</td>
                                                <td>The raw bytes of the Ed25519 address which is a BLAKE2b-256 hash of the Ed25519 public key.</td>
                                            </tr>
                                        </table>
                                    </details>
                                    <details>
                                        <summary>Alias Address</summary>
                                        <table>
                                            <tr>
                                                <td><b>Name</b></td>
                                                <td><b>Type</b></td>
                                                <td><b>Description</b></td>
                                            </tr>
                                            <tr>
                                                <td>Address Type</td>
                                                <td>uint8</td>
                                                <td>
                                                    Set to <strong>value 8</strong> to denote an <i>Alias Address</i>.
                                                </td>
                                            </tr>
                                            <tr>
                                                <td>Alias ID</td>
                                                <td>ByteArray[32]</td>
                                                <td>The raw bytes of the <i>Alias ID</i> which is the BLAKE2b-256 hash of the outputID that created it.</td>
                                            </tr>
                                        </table>
                                    </details>
                                    <details>
                                        <summary>NFT Address</summary>
                                        <table>
                                            <tr>
                                                <td><b>Name</b></td>
                                                <td><b>Type</b></td>
                                                <td><b>Description</b></td>
                                            </tr>
                                            <tr>
                                                <td>Address Type</td>
                                                <td>uint8</td>
                                                <td>
                                                    Set to <strong>value 16</strong> to denote an <i>NFT Address</i>.
                                                </td>
                                            </tr>
                                            <tr>
                                                <td>NFT ID</td>
                                                <td>ByteArray[32]</td>
                                                <td>The raw bytes of the <i>NFT ID</i> which is the BLAKE2b-256 hash of the outputID that created it.</td>
                                            </tr>
                                        </table>
                                    </details>
                                </td>
                            </tr>
                        </table>
                    </details>
                    <details>
                        <summary>Metadata Feature</summary>
                        <blockquote>
                            Defines metadata (arbitrary binary data) that will be stored in the output.
                        </blockquote>
                        <table>
                            <tr>
                                <td><b>Name</b></td>
                                <td><b>Type</b></td>
                                <td><b>Description</b></td>
                            </tr>
                            <tr>
                                <td>Feature Type</td>
                                <td>uint8</td>
                                <td>
                                    Set to <strong>value 2</strong> to denote a <i>Metadata Feature</i>.
                                </td>
                            </tr>
                            <tr>
                                <td>Data</td>
                                <td>(uint16)ByteArray</td>
                                <td>Binary data. A leading uint16 denotes its length.</td>
                            </tr>
                        </table>
                    </details>
                </td>
            </tr>
        </table>
    </details>
</table>
<h3 id="additional-transaction-syntactic-validation-rules-1"><a class="header" href="#additional-transaction-syntactic-validation-rules-1">Additional Transaction Syntactic Validation Rules</a></h3>
<h4 id="output-syntactic-validation"><a class="header" href="#output-syntactic-validation">Output Syntactic Validation</a></h4>
<ul>
<li><code>Amount</code> field must fulfill the dust protection requirements and must not be <code>0</code>.</li>
<li><code>Amount</code> field must be ≤ <code>Max IOTA Supply</code>.</li>
<li><code>Native Tokens Count</code> must not be greater than <code>Max Native Tokens Count</code>.</li>
<li><code>Native Tokens</code> must be lexicographically sorted based on <code>Token ID</code>.</li>
<li>Each <i>Native Token</i> must be unique in the set of <code>Native Tokens</code> based on its <code>Token ID</code>. No duplicates are
allowed.</li>
<li><code>Amount</code> of any <i>Native Token</i> must not be <code>0</code>.</li>
<li>It must hold true that <code>Unlock Conditions Count</code> = <code>2</code>.</li>
<li><code>Unlock Condition Type</code> of an <i>Unlock Condition</i> must define one of the following types:
<ul>
<li><i>State Controller Address Unlock Condition</i></li>
<li><i>Governor Address Unlock Condition</i></li>
</ul>
</li>
<li><i>Unlock Conditions</i> must be sorted in ascending order based on their <code>Unlock Condition Type</code>.</li>
<li>Syntactic validation of all present unlock conditions must pass.</li>
<li>It must hold true that <code>0</code> ≤ <code>Features Count</code> ≤ <code>2</code>.</li>
<li><code>Feature Type</code> of a <i>Feature</i> in <code>Features</code> must define one of the following types:
<ul>
<li><i>Sender Feature</i></li>
<li><i>Metadata Feature</i></li>
</ul>
</li>
<li>It must hold true that <code>0</code> ≤ <code>Immutable Features Count</code> ≤ <code>2</code>.</li>
<li><code>Feature Type</code> of a <i>Feature</i> in <code>Immutable Features</code> must define on of the following types:
<ul>
<li><i>Issuer Feature</i></li>
<li><i>Metadata Feature</i></li>
</ul>
</li>
<li><i>Features</i> must be sorted in ascending order based on their <code>Feature Type</code> both in <code>Features</code> and <code>Immutable Features</code>
fields.</li>
<li>Syntactic validation of all present features must pass.</li>
<li>When <code>Alias ID</code> is zeroed out, <code>State Index</code> and <code>Foundry Counter</code> must be <code>0</code>.</li>
<li><code>length(State Metadata)</code> must not be greater than <code>Max Metadata Length</code>.</li>
<li><code>Address</code> of <i>State Controller Address Unlock Condition</i> and <code>Address</code> of
<i>Governor Address Unlock Condition</i> must be different from the alias address derived from <code>Alias ID</code>.</li>
</ul>
<h3 id="additional-transaction-semantic-validation-rules-1"><a class="header" href="#additional-transaction-semantic-validation-rules-1">Additional Transaction Semantic Validation Rules</a></h3>
<ul>
<li>Explicit <code>Alias ID</code>: <code>Alias ID</code> is taken as the value of the <code>Alias ID</code> field in the alias output.</li>
<li>Implicit <code>Alias ID</code>: When an alias output is consumed as an input in a transaction and <code>Alias ID</code> field is zeroed out
while <code>State Index</code> and <code>Foundry Counter</code> are zero, take the BLAKE2b-256 hash of the <code>Output ID</code> of the input as
<code>Alias ID</code>.</li>
<li>For every non-zero explicit <code>Alias ID</code> on the output side there must be a corresponding alias on the input side. The
corresponding alias has the explicit or implicit <code>Alias ID</code> equal to that of the alias on the output side.</li>
</ul>
<h4 id="consumed-outputs-1"><a class="header" href="#consumed-outputs-1">Consumed Outputs</a></h4>
<p>Whenever an alias output is consumed in a transaction, it means that the alias is transitioned into its next state. The
<strong>current state</strong> is defined as the <strong>consumed alias output</strong>, while the <strong>next state</strong> is defined as the <strong>alias
output with the same explicit <code>AliasID</code> on the output side</strong>. There are two types of transitions: <code>state transition</code>
and <code>governance transition</code>.</p>
<ul>
<li>State transition:
<ul>
<li>A state transition is identified by an incremented <code>State Index</code>.</li>
<li>The <code>State Index</code> must be incremented by 1.</li>
<li>The unlock must correspond to the <code>Address</code> of <i>State Controller Address Unlock Condition</i>.</li>
<li>State transition can only change the following fields in the next state:
<ul>
<li><code>IOTA Amount</code>,</li>
<li><code>Native Tokens</code>,</li>
<li><code>State Index</code>,</li>
<li><code>State Metadata</code>,</li>
<li><code>Foundry Counter</code> and</li>
<li><code>Sender Feature</code> in <code>Features</code>.</li>
</ul>
</li>
<li><code>Foundry Counter</code> field must increase by the number of foundry outputs created in the transaction that map to
<code>Alias ID</code>. The <code>Serial Number</code> fields of the created foundries must be the set of natural numbers that cover the
open-ended interval between the previous and next values of the <code>Foundry Counter</code> field in the alias output.</li>
<li>The created foundry outputs must be sorted in the list of outputs by their <code>Serial Number</code>. Note, that any
foundry that maps to <code>Alias ID</code> and has a <code>Serial Number</code> that is less or equal to the <code>Foundry Counter</code> of the
input alias is ignored when it comes to sorting.</li>
<li>Newly created foundries in the transaction that map to different aliases can be interleaved when it comes to
sorting.</li>
</ul>
</li>
<li>Governance transition:
<ul>
<li>A governance transition is identified by an unchanged <code>State Index</code> in next state. If there is no alias output on
the output side with a corresponding explicit <code>Alias ID</code>, the alias is being destroyed. The next state is the
empty state.</li>
<li>The unlock must correspond to the <code>Address</code> of <i>Governor Address Unlock Condition</i>.</li>
<li>Governance transition must only change the following fields:
<ul>
<li><code>Address</code> of <i>State Controller Address Unlock Condition</i>,</li>
<li><code>Address</code> of <i>Governor Address Unlock Condition</i>,</li>
<li><code>Metadata Feature</code> and <code>Sender Feature</code> in <code>Features</code>.</li>
</ul>
</li>
<li>The <code>Metadata Feature</code> is optional, the governor can put additional info about the chain here, for example chain
name, fee structure, supported VMs, list of access nodes, etc., anything that helps clients to fetch info (i.e.
account balances) about the layer 2 network.</li>
</ul>
</li>
<li>When a consumed alias output has <i>Features</i> defined in <code>Immutable Features</code> and a corresponding alias output on the
output side, <code>Immutable Features</code> is not allowed to change.</li>
</ul>
<h4 id="created-outputs-1"><a class="header" href="#created-outputs-1">Created Outputs</a></h4>
<ul>
<li>When <i>Issuer Feature</i> is present in an output and explicit <code>Alias ID</code> is zeroed out, an input with <code>Address</code> field
that corresponds to <code>Issuer</code> must be unlocked in the transaction.</li>
</ul>
<h3 id="notes"><a class="header" href="#notes">Notes</a></h3>
<ul>
<li><i>Governor Address Unlock Condition</i> field is made mandatory for now to help formal verification. When the same
entity is defined for state and governance controllers, the output is self governed. Later, for compression reasons,
it is possible to make the governance controller optional and define a self-governed alias as one that does not have
the governance <i>Governor Address Unlock Condition</i> set.</li>
<li>Indexers and node plugins shall map the alias address of the output derived with <code>Alias ID</code> to the regular
<i>address -&gt; output</i> mapping table, so that given an <i>Alias Address</i>, its most recent unspent alias output
can be retrieved.</li>
</ul>
<h2 id="foundry-output"><a class="header" href="#foundry-output">Foundry Output</a></h2>
<p>A foundry output is an output that <strong>controls the supply of user defined native tokens.</strong> It can mint and melt tokens
according to the <strong>policy</strong> defined in the <code>Token Scheme</code> field of the output. Foundries can only be created and
controlled by aliases.</p>
<p><strong>The concatenation of <code>Address</code> || <code>Serial Number</code> || <code>Token Scheme Type</code> fields defines the unique identifier of the
foundry, the <code>Foundry ID</code>.</strong></p>
<p>Upon creation of the foundry, the alias defined in the <code>Address</code> field of the
<i>Immutable Alias Address Unlock Condition</i> must be unlocked in the same transaction, and its <code>Foundry Counter</code>
field must increment. This incremented value defines <code>Serial Number</code>, while the <code>Token Scheme</code> can be chosen freely.</p>
<p><code>Foundry ID</code> is not allowed to change after deployment, therefore neither <code>Address</code>, nor <code>Serial Number</code> or
<code>Token Scheme</code> can change during the lifetime of the foundry.</p>
<p>Foundries control the supply of tokens with unique identifiers, so-called <code>Token IDs</code>. The **<code>Token ID</code> of tokens
controlled by a specific foundry is the same as the <strong><code>Foundry ID</code></strong>.</p>
<table>
    <details>
        <summary>Foundry Output</summary>
        <blockquote>
            Describes a foundry output that is controlled by an alias.
        </blockquote>
        <table>
            <tr>
                <td><b>Name</b></td>
                <td><b>Type</b></td>
                <td><b>Description</b></td>
            </tr>
            <tr>
                <td>Output Type</td>
                <td>uint8</td>
                <td>
                    Set to <strong>value 5</strong> to denote a <i>Foundry Output</i>.
                </td>
            </tr>
            <tr>
                <td>Amount</td>
                <td>uint64</td>
                <td>The amount of IOTA coins to held by the output.</td>
            </tr>
            <tr>
                <td>Native Tokens Count</td>
                <td>uint8</td>
                <td>The number of different native tokens held by the output.</td>
            </tr>
            <tr>
                <td valign="top">Native Tokens <code>optAnyOf</code></td>
                <td colspan="2">
                    <details>
                        <summary>Native Token</summary>
                        <table>
                            <tr>
                                <td><b>Name</b></td>
                                <td><b>Type</b></td>
                                <td><b>Description</b></td>
                            </tr>
                            <tr>
                                <td>Token ID</td>
                                <td>ByteArray[38]</td>
                                <td>
                                    Identifier of the native tokens.
                                </td>
                            </tr>
                            <tr>
                                <td>Amount</td>
                                <td>uint256</td>
                                <td>Amount of native tokens of the given <i>Token ID</i>.</td>
                            </tr>
                        </table>
                    </details>
                </td>
            </tr>
            <tr>
                <td>Serial Number</td>
                <td>uint32</td>
                <td>The serial number of the foundry with respect to the controlling alias.</td>
            </tr>
            <tr>
                <td valign="top">Token Scheme <code>oneOf</code></td>
                <td colspan="2">
                    <details>
                        <summary>Simple Token Scheme</summary>
                        <table>
                            <tr>
                                <td><b>Name</b></td>
                                <td><b>Type</b></td>
                                <td><b>Description</b></td>
                            </tr>
                            <tr>
                                <td>Token Scheme Type</td>
                                <td>uint8</td>
                                <td>
                                    Set to <strong>value 0</strong> to denote an <i>Simple Token Scheme</i>.
                                </td>
                            </tr>
                            <tr>
                                <td>Minted Tokens</td>
                                <td>uint256</td>
                                <td>Amount of tokens minted by this foundry.</td>
                            </tr>
                            <tr>
                                <td>Melted Tokens</td>
                                <td>uint256</td>
                                <td>Amount of tokens melted by this foundry.</td>
                            </tr>
                            <tr>
                                <td>Maximum Supply</td>
                                <td>uint256</td>
                                <td>Maximum supply of tokens controlled by this foundry.</td>
                            </tr>
                        </table>
                    </details>
                </td>
            </tr>
            <tr>
                <td>Unlock Conditions Count</td>
                <td>uint8</td>
                <td>The number of unlock conditions following.</td>
            </tr>
            <tr>
                <td valign="top">Unlock Conditions <code>atMostOneOfEach</code></td>
                <td colspan="2">
                    <details>
                        <summary>Immutable Alias Address Unlock Condition</summary>
                        <table>
                            <tr>
                                <td><b>Name</b></td>
                                <td><b>Type</b></td>
                                <td><b>Description</b></td>
                            </tr>
                            <tr>
                                <td>Unlock Condition Type</td>
                                <td>uint8</td>
                                <td>
                                    Set to <strong>value 6</strong> to denote an <i>Immutable Alias Address Unlock Condition</i>.
                                </td>
                            </tr>
                            <tr>
                                <td>Address</td>
                                <td colspan="2">
                                    <details>
                                        <summary>Alias Address</summary>
                                        <table>
                                            <tr>
                                                <td><b>Name</b></td>
                                                <td><b>Type</b></td>
                                                <td><b>Description</b></td>
                                            </tr>
                                            <tr>
                                                <td>Address Type</td>
                                                <td>uint8</td>
                                                <td>
                                                    Set to <strong>value 8</strong> to denote an <i>Alias Address</i>.
                                                </td>
                                            </tr>
                                            <tr>
                                                <td>Alias ID</td>
                                                <td>ByteArray[32]</td>
                                                <td>The raw bytes of the <i>Alias ID</i> which is the BLAKE2b-256 hash of the outputID that created it.</td>
                                            </tr>
                                        </table>
                                    </details>
                                </td>
                            </tr>
                        </table>
                    </details>
                </td>
            </tr>
            <tr>
                <td>Features Count</td>
                <td>uint8</td>
                <td>The number of features following.</td>
            </tr>
            <tr>
                <td valign="top">Features <code>atMostOneOfEach</code></td>
                <td colspan="2">
                    <details>
                        <summary>Metadata Feature</summary>
                        <blockquote>
                            Defines metadata (arbitrary binary data) that will be stored in the output.
                        </blockquote>
                        <table>
                            <tr>
                                <td><b>Name</b></td>
                                <td><b>Type</b></td>
                                <td><b>Description</b></td>
                            </tr>
                            <tr>
                                <td>Feature Type</td>
                                <td>uint8</td>
                                <td>
                                    Set to <strong>value 2</strong> to denote a <i>Metadata Feature</i>.
                                </td>
                            </tr>
                            <tr>
                                <td>Data</td>
                                <td>(uint16)ByteArray</td>
                                <td>Binary data. A leading uint16 denotes its length.</td>
                            </tr>
                        </table>
                    </details>
                </td>
            </tr>
            <tr>
                <td>Immutable Features Count</td>
                <td>uint8</td>
                <td>The number of immutable features following. Immutable features are defined upon deployment of the UTXO state machine and are not allowed to change in any future state transition.</td>
            </tr>
            <tr>
                <td valign="top">Immutable Features <code>atMostOneOfEach</code></td>
                <td colspan="2">
                    <details>
                        <summary>Metadata Feature</summary>
                        <blockquote>
                            Defines metadata (arbitrary binary data) that will be stored in the output.
                        </blockquote>
                        <table>
                            <tr>
                                <td><b>Name</b></td>
                                <td><b>Type</b></td>
                                <td><b>Description</b></td>
                            </tr>
                            <tr>
                                <td>Feature Type</td>
                                <td>uint8</td>
                                <td>
                                    Set to <strong>value 2</strong> to denote a <i>Metadata Feature</i>.
                                </td>
                            </tr>
                            <tr>
                                <td>Data</td>
                                <td>(uint16)ByteArray</td>
                                <td>Binary data. A leading uint16 denotes its length.</td>
                            </tr>
                        </table>
                    </details>
                </td>
            </tr>
        </table>
    </details>
</table>
<h3 id="additional-transaction-syntactic-validation-rules-2"><a class="header" href="#additional-transaction-syntactic-validation-rules-2">Additional Transaction Syntactic Validation Rules</a></h3>
<h4 id="output-syntactic-validation-1"><a class="header" href="#output-syntactic-validation-1">Output Syntactic Validation</a></h4>
<ul>
<li><code>Amount</code> field must fulfill the dust protection requirements and must not be <code>0</code>.</li>
<li><code>Amount</code> field must be ≤ <code>Max IOTA Supply</code>.</li>
<li><code>Native Tokens Count</code> must not be greater than <code>Max Native Tokens Count</code>.</li>
<li><code>Native Tokens</code> must be lexicographically sorted based on <code>Token ID</code>.</li>
<li>Each <i>Native Token</i> must be unique in the set of <code>Native Tokens</code> based on its <code>Token ID</code>. No duplicates are
allowed.</li>
<li><code>Amount</code> of any <i>Native Token</i> must not be <code>0</code>.</li>
<li>It must hold true that <code>Unlock Conditions Count</code> = <code>1</code>.</li>
<li><code>Unlock Condition Type</code> of an <i>Unlock Condition</i> must define one of the following types:
<ul>
<li><i>Immutable Alias Address Unlock Condition</i></li>
</ul>
</li>
<li>Syntactic validation of all present unlock conditions must pass.</li>
<li>It must hold true that <code>0</code> ≤ <code>Features Count</code> ≤ <code>1</code>.</li>
<li><code>Feature Type</code> of a <i>Feature</i> in <code>Features</code> must define one of the following types:
<ul>
<li><i>Metadata Feature</i></li>
</ul>
</li>
<li>It must hold true that <code>0</code> ≤ <code>Immutable Features Count</code> ≤ <code>1</code>.</li>
<li><code>Feature Type</code> of a <i>Feature</i> in <code>Immutable Features</code> must define one of the following types:
<ul>
<li><i>Metadata Feature</i></li>
</ul>
</li>
<li>Syntactic validation of all present features must pass.</li>
<li><code>Token Scheme</code> must define one of the following types:
<ul>
<li><i>Simple Token Scheme</i></li>
</ul>
</li>
</ul>
<h5 id="simple-token-scheme-syntactic-validation"><a class="header" href="#simple-token-scheme-syntactic-validation">Simple Token Scheme Syntactic Validation</a></h5>
<ul>
<li><code>Token Scheme Type</code> of a <i>Simple Token Scheme</i> must be <code>0</code>.</li>
<li><code>Minted Tokens</code> - <code>Melted Tokens</code> must not be greater than <code>Maximum Supply</code>.</li>
<li><code>Melted Tokens</code> must not be greater than <code>Minted Tokens</code>.</li>
<li><code>Maximum Supply</code> must be larger than zero.</li>
</ul>
<h3 id="additional-transaction-semantic-validation-rules-2"><a class="header" href="#additional-transaction-semantic-validation-rules-2">Additional Transaction Semantic Validation Rules</a></h3>
<p>A foundry is essentially a UTXO state machine. A transaction might either create a new foundry with a unique
<code>Foundry ID</code>, transition an already existing foundry or destroy it. The current and next states of the state machine
are encoded in inputs and outputs respectively.</p>
<ul>
<li>The <strong>current state of the foundry</strong> with <code>Foundry ID</code> <code>X</code> in a transaction is defined as the consumed foundry output
where <code>Foundry ID</code> = <code>X</code>.</li>
<li>The <strong>next state of the foundry</strong> with <code>Foundry ID</code> <code>X</code> in a transaction is defined as the created foundry output
where <code>Foundry ID</code> = <code>X</code>.</li>
<li><code>Foundry Diff</code> is the pair of the <strong>current and next state</strong> of the foundry output in the transaction.</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th>A transaction that...</th><th>Current State</th><th>Next State</th></tr></thead><tbody>
<tr><td>Creates the foundry</td><td>Empty</td><td>Output with <code>Foundry ID</code></td></tr>
<tr><td>Transitions the foundry</td><td>Input with <code>Foundry ID</code></td><td>Output with <code>Foundry ID</code></td></tr>
<tr><td>Destroys the foundry</td><td>Input with <code>Foundry ID</code></td><td>Empty</td></tr>
</tbody></table>
</div>
<ul>
<li>The foundry output must be unlocked like any other output type where the <strong>Address Unlock Condition</strong> defines an
<strong>Alias Address</strong>, by transitioning the alias in the very same transaction. See section
<a href="tips/TIP-0018/tip-0018.html#unlocking-chain-script-locked-outputs">alias unlocking</a> for more details.</li>
<li>When the current state of the foundry with <code>Foundry ID</code> is empty, it must hold true for <code>Serial Number</code> in the next
state, that:
<ul>
<li><code>Foundry Counter(InputAlias) &lt; Serial Number &lt;= Foundry Counter(OutputAlias)</code></li>
<li>An alias can create several new foundries in one transaction. It was written for the alias output that freshly
created foundry outputs must be sorted in the list of outputs based on their <code>Serial Number</code>. No duplicates are
allowed.</li>
<li>The two previous rules make sure that each foundry output produced by an alias has a unique <code>Serial Number</code>,
hence each <code>Foundry ID</code> is unique.</li>
</ul>
</li>
<li>Native tokens present in a transaction are all native tokens present in inputs and outputs of the transaction. Native
tokens of a transaction must be a set based on their <code>Token ID</code>.</li>
<li>There must be at most one <code>Token ID</code> in the native token set of the transaction that maps to a specific <code>Foundry ID</code>.</li>
<li>When neither <code>Current State</code> nor <code>Next State</code> is empty:
<ul>
<li><i>Immutable Alias Address Unlock Condition</i> must not change.</li>
<li><code>Serial Number</code> must not change.</li>
<li><code>Token Scheme Type</code> must not change.</li>
<li><i>Features</i> in <code>Immutable Features</code> must not change.</li>
</ul>
</li>
<li><a href="tips/TIP-0018/tip-0018.html#token-scheme-semantic-validation-rules">Token Scheme Semantic Validation Rules</a> must be fulfilled.</li>
</ul>
<h4 id="token-scheme-semantic-validation-rules"><a class="header" href="#token-scheme-semantic-validation-rules">Token Scheme Semantic Validation Rules</a></h4>
<p><code>Token Scheme Validation</code> takes <code>Token Diff</code> and <code>Foundry Diff</code> and validates if the scheme constraints are respected.</p>
<h5 id="simple-token-scheme-validation-rules"><a class="header" href="#simple-token-scheme-validation-rules">Simple Token Scheme Validation Rules</a></h5>
<ul>
<li>Let <code>Token Diff</code> denote the <strong>difference between native token balances of the input and the output side</strong> of the
transaction of the single <code>Token ID</code> that maps to the <code>Foundry ID</code>. Minting results in excess of tokens on the output
side (positive diff), melting results in excess on the input side (negative diff). Now, the following conditions must
hold for <code>Token Diff</code>:
<ol>
<li>When <code>Token Diff</code> &gt; 0</li>
</ol>
<ul>
<li><code>Current State(Minted Tokens) + Token Diff = Next State(Minted Tokens)</code>.</li>
<li><code>Current State(Melted Tokens) = Next State(Melted Tokens)</code></li>
</ul>
<ol start="2">
<li>When <code>Token Diff</code> &lt; 0, it must hold true that:</li>
</ol>
<ul>
<li><code>Current State(Melted Tokens) &lt;= Next State(Melted Tokens)</code></li>
<li><code>[Next State(Melted Tokens) - Current State(Melted Tokens)] &lt;= |Token Diff|</code>.</li>
<li>When <code>Current State(Melted Tokens) != Next State(Melted Tokens)</code>, it must be true that <code>Current State(Minted Tokens) = Next State(Minted Tokens)</code></li>
</ul>
<ol start="3">
<li>When <code>Current State</code> is empty, <code>Current State(Minted Tokens) = 0</code> and <code>Current State(Melted Tokens) = 0</code>.</li>
<li>When <code>Next State</code> is empty, condition <code>1</code> and <code>2</code> are ignored. It must hold true, that
<code>Current State(Minted Tokens) + Token Diff = Current State(Melted Tokens)</code></li>
</ol>
</li>
<li>When neither <code>Current State</code> nor <code>Next State</code> is empty:
<ul>
<li><code>Maximum Supply</code> field must not change.</li>
</ul>
</li>
</ul>
<h3 id="notes-1"><a class="header" href="#notes-1">Notes</a></h3>
<ul>
<li>A token scheme is a list of hard coded constraints. It is not feasible at the moment to foresee the future
needs/requirements of hard coded constraints, so it is impossible to design token schemes as any possible combination
of those constraints. A better design would be to have a list of possible constraints (and their related fields) from
which the user can choose. The chosen combination should still be encoded as a bitmask inside the <code>Token ID</code>.</li>
<li>Additional token schemes will be defined that make use of the <code>Foundry Diff</code> as well, for example validating that
a certain amount of tokens can only be minted/melted after a certain date.</li>
<li>For now, only token scheme <code>0</code> is supported. Additional token schemes will be designed iteratively when the need arises.</li>
<li>The <code>Foundry ID</code> of a foundry output should be queryable in indexers, so that given a <code>Foundry ID</code>, the
<code>Output ID</code> of the foundry output can be retrieved. <code>Foundry ID</code> behaves like an address that can't unlock anything.
While it is not necessarily needed for the protocol, it is needed for client side operations, such as:
<ul>
<li>Retrieving the current state of the foundry.</li>
<li>Accessing token metadata in foundry based on <code>Foundry ID</code>/<code>Tokend ID</code>.</li>
</ul>
</li>
</ul>
<h2 id="nft-output"><a class="header" href="#nft-output">NFT Output</a></h2>
<p>Non-fungible tokens in the ledger are implemented with a special output type, the so-called <i>NFTOutput</i>.</p>
<p>Each NFT output gets assigned a unique identifier <code>NFT ID</code> upon creation by the protocol. <code>NFT ID</code> is BLAKE2b-256 hash
of the <i>Output ID</i> that created the NFT. The address of the NFT is the concatenation of <code>NFT Address Type</code> ||
<code>NFT ID</code>.</p>
<p>The NFT may contain immutable metadata set upon creation, and a verified <code>Issuer</code>. The output type supports all
non-alias specific (state controller, governor) unlock conditions and optional features so that the output can be
sent as a request to smart contract chain accounts.</p>
<table>
    <details>
        <summary>NFT Output</summary>
        <blockquote>
            Describes an NFT output, a globally unique token with metadata attached.
        </blockquote>
        <table>
            <tr>
                <td><b>Name</b></td>
                <td><b>Type</b></td>
                <td><b>Description</b></td>
            </tr>
            <tr>
                <td>Output Type</td>
                <td>uint8</td>
                <td>
                    Set to <strong>value 6</strong> to denote a <i>NFT Output</i>.
                </td>
            </tr>
            <tr>
                <td>Amount</td>
                <td>uint64</td>
                <td>The amount of IOTA coins held by the output.</td>
            </tr>
            <tr>
                <td>Native Tokens Count</td>
                <td>uint8</td>
                <td>The number of native tokens held by the output.</td>
            </tr>
            <tr>
                <td valign="top">Native Tokens <code>optAnyOf</code></td>
                <td colspan="2">
                    <details>
                        <summary>Native Token</summary>
                        <table>
                            <tr>
                                <td><b>Name</b></td>
                                <td><b>Type</b></td>
                                <td><b>Description</b></td>
                            </tr>
                            <tr>
                                <td>Token ID</td>
                                <td>ByteArray[38]</td>
                                <td>
                                    Identifier of the native token.
                                </td>
                            </tr>
                            <tr>
                                <td>Amount</td>
                                <td>uint256</td>
                                <td>
                                    Amount of native tokens of the given <i>Token ID</i>.
                                </td>
                            </tr>
                        </table>
                    </details>
                </td>
            </tr>
            <tr>
                <td>NFT ID</td>
                <td>ByteArray[32]</td>
                <td>Unique identifier of the NFT, which is the BLAKE2b-256 hash of the <i>Output ID</i> that created it.<i> NFT Address = NFT Address Type || NFT ID</i></td>
            </tr>
            <tr>
                <td>Unlock Conditions Count</td>
                <td>uint8</td>
                <td>The number of unlock conditions following.</td>
            </tr>
            <tr>
                <td valign="top">Unlock Conditions <code>atMostOneOfEach</code></td>
                <td colspan="2">
                    <details>
                        <summary>Address Unlock Condition</summary>
                        <table>
                            <tr>
                                <td><b>Name</b></td>
                                <td><b>Type</b></td>
                                <td><b>Description</b></td>
                            </tr>
                            <tr>
                                <td>Unlock Condition Type</td>
                                <td>uint8</td>
                                <td>
                                    Set to <strong>value 0</strong> to denote an <i>Address Unlock Condition</i>.
                                </td>
                            </tr>
                            <tr>
                                <td>Address</td>
                                <td colspan="2">
                                    <details>
                                        <summary>Ed25519 Address</summary>
                                        <table>
                                            <tr>
                                                <td><b>Name</b></td>
                                                <td><b>Type</b></td>
                                                <td><b>Description</b></td>
                                            </tr>
                                            <tr>
                                                <td>Address Type</td>
                                                <td>uint8</td>
                                                <td>
                                                    Set to <strong>value 0</strong> to denote an <i>Ed25519 Address</i>.
                                                </td>
                                            </tr>
                                            <tr>
                                                <td>PubKeyHash</td>
                                                <td>ByteArray[32]</td>
                                                <td>The raw bytes of the Ed25519 address which is a BLAKE2b-256 hash of the Ed25519 public key.</td>
                                            </tr>
                                        </table>
                                    </details>
                                    <details>
                                        <summary>Alias Address</summary>
                                        <table>
                                            <tr>
                                                <td><b>Name</b></td>
                                                <td><b>Type</b></td>
                                                <td><b>Description</b></td>
                                            </tr>
                                            <tr>
                                                <td>Address Type</td>
                                                <td>uint8</td>
                                                <td>
                                                    Set to <strong>value 8</strong> to denote an <i>Alias Address</i>.
                                                </td>
                                            </tr>
                                            <tr>
                                                <td>Alias ID</td>
                                                <td>ByteArray[32]</td>
                                                <td>The raw bytes of the <i>Alias ID</i> which is the BLAKE2b-256 hash of the outputID that created it.</td>
                                            </tr>
                                        </table>
                                    </details>
                                    <details>
                                        <summary>NFT Address</summary>
                                        <table>
                                            <tr>
                                                <td><b>Name</b></td>
                                                <td><b>Type</b></td>
                                                <td><b>Description</b></td>
                                            </tr>
                                            <tr>
                                                <td>Address Type</td>
                                                <td>uint8</td>
                                                <td>
                                                    Set to <strong>value 16</strong> to denote an <i>NFT Address</i>.
                                                </td>
                                            </tr>
                                            <tr>
                                                <td>NFT ID</td>
                                                <td>ByteArray[32]</td>
                                                <td>The raw bytes of the <i>NFT ID</i> which is the BLAKE2b-256 hash of the outputID that created it.</td>
                                            </tr>
                                        </table>
                                    </details>
                                </td>
                            </tr>
                        </table>
                    </details>
                    <details>
                        <summary>Storage Deposit Return Unlock Condition</summary>
                        <blockquote>
                            Defines the amount of IOTAs used as storage deposit that have to be returned to <i>Return Address</i>.
                        </blockquote>
                        <table>
                            <tr>
                                <td><b>Name</b></td>
                                <td><b>Type</b></td>
                                <td><b>Description</b></td>
                            </tr>
                            <tr>
                                <td>Unlock Condition Type</td>
                                <td>uint8</td>
                                <td>
                                    Set to <strong>value 1</strong> to denote a <i>Storage Deposit Return Unlock Condition</i>.
                                </td>
                            </tr>
                            <tr>
                                <td valign="top">Return Address <code>oneOf</code></td>
                                <td colspan="2">
                                    <details>
                                        <summary>Ed25519 Address</summary>
                                        <table>
                                            <tr>
                                                <td><b>Name</b></td>
                                                <td><b>Type</b></td>
                                                <td><b>Description</b></td>
                                            </tr>
                                            <tr>
                                                <td>Address Type</td>
                                                <td>uint8</td>
                                                <td>
                                                    Set to <strong>value 0</strong> to denote an <i>Ed25519 Address</i>.
                                                </td>
                                            </tr>
                                            <tr>
                                                <td>PubKeyHash</td>
                                                <td>ByteArray[32]</td>
                                                <td>The raw bytes of the Ed25519 address which is a BLAKE2b-256 hash of the Ed25519 public key.</td>
                                            </tr>
                                        </table>
                                    </details>
                                    <details>
                                        <summary>Alias Address</summary>
                                        <table>
                                            <tr>
                                                <td><b>Name</b></td>
                                                <td><b>Type</b></td>
                                                <td><b>Description</b></td>
                                            </tr>
                                            <tr>
                                                <td>Address Type</td>
                                                <td>uint8</td>
                                                <td>
                                                    Set to <strong>value 8</strong> to denote an <i>Alias Address</i>.
                                                </td>
                                            </tr>
                                            <tr>
                                                <td>Alias ID</td>
                                                <td>ByteArray[32]</td>
                                                <td>The raw bytes of the <i>Alias ID</i> which is the BLAKE2b-256 hash of the outputID that created it.</td>
                                            </tr>
                                        </table>
                                    </details>
                                    <details>
                                        <summary>NFT Address</summary>
                                        <table>
                                            <tr>
                                                <td><b>Name</b></td>
                                                <td><b>Type</b></td>
                                                <td><b>Description</b></td>
                                            </tr>
                                            <tr>
                                                <td>Address Type</td>
                                                <td>uint8</td>
                                                <td>
                                                    Set to <strong>value 16</strong> to denote an <i>NFT Address</i>.
                                                </td>
                                            </tr>
                                            <tr>
                                                <td>NFT ID</td>
                                                <td>ByteArray[32]</td>
                                                <td>The raw bytes of the <i>NFT ID</i> which is the BLAKE2b-256 hash of the outputID that created it.</td>
                                            </tr>
                                        </table>
                                    </details>
                                </td>
                            </tr>
                            <tr>
                                <td>Return Amount</td>
                                <td>uint64</td>
                                <td>
                                    Amount of IOTA coins the consuming transaction should deposit to the address defined in <i>Return Address</i>.
                                </td>
                            </tr>
                        </table>
                    </details>
                    <details>
                        <summary>Timelock Unlock Condition</summary>
                        <blockquote>
                            Defines a unix timestamp until which the output can not be unlocked.
                        </blockquote>
                        <table>
                            <tr>
                                <td><b>Name</b></td>
                                <td><b>Type</b></td>
                                <td><b>Description</b></td>
                            </tr>
                            <tr>
                                <td>Unlock Condition Type</td>
                                <td>uint8</td>
                                <td>
                                    Set to <strong>value 2</strong> to denote a <i>Timelock Unlock Condition</i>.
                                </td>
                            </tr>
                            <tr>
                                <td>Unix Time</td>
                                <td>uint32</td>
                                <td>
                                    Unix time (seconds since Unix epoch) starting from which the output can be consumed.
                                </td>
                            </tr>
                        </table>
                    </details>
                    <details>
                        <summary>Expiration Unlock Condition</summary>
                        <blockquote>
                            Defines a unix time until which only <i>Address</i>, defined in <i>Address Unlock Condition</i>, is allowed to
                            unlock the output. After the unix time is reached or passed, only <i>Return Address</i> can unlock it.
                        </blockquote>
                        <table>
                            <tr>
                                <td><b>Name</b></td>
                                <td><b>Type</b></td>
                                <td><b>Description</b></td>
                            </tr>
                            <tr>
                                <td>Unlock Condition Type</td>
                                <td>uint8</td>
                                <td>
                                    Set to <strong>value 3</strong> to denote a <i>Expiration Unlock Condition</i>.
                                </td>
                            </tr>
                            <tr>
                                <td valign="top">Return Address <code>oneOf</code></td>
                                <td colspan="2">
                                    <details>
                                        <summary>Ed25519 Address</summary>
                                        <table>
                                            <tr>
                                                <td><b>Name</b></td>
                                                <td><b>Type</b></td>
                                                <td><b>Description</b></td>
                                            </tr>
                                            <tr>
                                                <td>Address Type</td>
                                                <td>uint8</td>
                                                <td>
                                                    Set to <strong>value 0</strong> to denote an <i>Ed25519 Address</i>.
                                                </td>
                                            </tr>
                                            <tr>
                                                <td>PubKeyHash</td>
                                                <td>ByteArray[32]</td>
                                                <td>The raw bytes of the Ed25519 address which is a BLAKE2b-256 hash of the Ed25519 public key.</td>
                                            </tr>
                                        </table>
                                    </details>
                                    <details>
                                        <summary>Alias Address</summary>
                                        <table>
                                            <tr>
                                                <td><b>Name</b></td>
                                                <td><b>Type</b></td>
                                                <td><b>Description</b></td>
                                            </tr>
                                            <tr>
                                                <td>Address Type</td>
                                                <td>uint8</td>
                                                <td>
                                                    Set to <strong>value 8</strong> to denote an <i>Alias Address</i>.
                                                </td>
                                            </tr>
                                            <tr>
                                                <td>Alias ID</td>
                                                <td>ByteArray[32]</td>
                                                <td>The raw bytes of the <i>Alias ID</i> which is the BLAKE2b-256 hash of the outputID that created it.</td>
                                            </tr>
                                        </table>
                                    </details>
                                    <details>
                                        <summary>NFT Address</summary>
                                        <table>
                                            <tr>
                                                <td><b>Name</b></td>
                                                <td><b>Type</b></td>
                                                <td><b>Description</b></td>
                                            </tr>
                                            <tr>
                                                <td>Address Type</td>
                                                <td>uint8</td>
                                                <td>
                                                    Set to <strong>value 16</strong> to denote an <i>NFT Address</i>.
                                                </td>
                                            </tr>
                                            <tr>
                                                <td>NFT ID</td>
                                                <td>ByteArray[32]</td>
                                                <td>The raw bytes of the <i>NFT ID</i> which is the BLAKE2b-256 hash of the outputID that created it.</td>
                                            </tr>
                                        </table>
                                    </details>
                                </td>
                            </tr>
                            <tr>
                                <td>Unix Time</td>
                                <td>uint32</td>
                                <td>
                                    Before this unix time, <i>Address Unlock Condition</i> is allowed to unlock the output, after that only the address defined in <i>Return Address</i>.
                                </td>
                            </tr>
                        </table>
                    </details>
                </td>
            </tr>
            <tr>
                <td>Features Count</td>
                <td>uint8</td>
                <td>The number of features following.</td>
            </tr>
            <tr>
                <td valign="top">Features <code>atMostOneOfEach</code></td>
                <td colspan="2">
                    <details>
                        <summary>Sender Feature</summary>
                        <blockquote>
                            Identifies the validated sender of the output.
                        </blockquote>
                        <table>
                            <tr>
                                <td><b>Name</b></td>
                                <td><b>Type</b></td>
                                <td><b>Description</b></td>
                            </tr>
                            <tr>
                                <td>Feature Type</td>
                                <td>uint8</td>
                                <td>
                                    Set to <strong>value 0</strong> to denote a <i>Sender Feature</i>.
                                </td>
                            </tr>
                            <tr>
                                <td valign="top">Address <code>oneOf</code></td>
                                <td colspan="2">
                                    <details>
                                        <summary>Ed25519 Address</summary>
                                        <table>
                                            <tr>
                                                <td><b>Name</b></td>
                                                <td><b>Type</b></td>
                                                <td><b>Description</b></td>
                                            </tr>
                                            <tr>
                                                <td>Address Type</td>
                                                <td>uint8</td>
                                                <td>
                                                    Set to <strong>value 0</strong> to denote an <i>Ed25519 Address</i>.
                                                </td>
                                            </tr>
                                            <tr>
                                                <td>PubKeyHash</td>
                                                <td>ByteArray[32]</td>
                                                <td>The raw bytes of the Ed25519 address which is a BLAKE2b-256 hash of the Ed25519 public key.</td>
                                            </tr>
                                        </table>
                                    </details>
                                    <details>
                                        <summary>Alias Address</summary>
                                        <table>
                                            <tr>
                                                <td><b>Name</b></td>
                                                <td><b>Type</b></td>
                                                <td><b>Description</b></td>
                                            </tr>
                                            <tr>
                                                <td>Address Type</td>
                                                <td>uint8</td>
                                                <td>
                                                    Set to <strong>value 8</strong> to denote an <i>Alias Address</i>.
                                                </td>
                                            </tr>
                                            <tr>
                                                <td>Alias ID</td>
                                                <td>ByteArray[32]</td>
                                                <td>The raw bytes of the <i>Alias ID</i> which is the BLAKE2b-256 hash of the outputID that created it.</td>
                                            </tr>
                                        </table>
                                    </details>
                                    <details>
                                        <summary>NFT Address</summary>
                                        <table>
                                            <tr>
                                                <td><b>Name</b></td>
                                                <td><b>Type</b></td>
                                                <td><b>Description</b></td>
                                            </tr>
                                            <tr>
                                                <td>Address Type</td>
                                                <td>uint8</td>
                                                <td>
                                                    Set to <strong>value 16</strong> to denote an <i>NFT Address</i>.
                                                </td>
                                            </tr>
                                            <tr>
                                                <td>NFT ID</td>
                                                <td>ByteArray[32]</td>
                                                <td>The raw bytes of the <i>NFT ID</i> which is the BLAKE2b-256 hash of the outputID that created it.</td>
                                            </tr>
                                        </table>
                                    </details>
                                </td>
                            </tr>
                        </table>
                    </details>
                    <details>
                        <summary>Metadata Feature</summary>
                        <blockquote>
                            Defines metadata (arbitrary binary data) that will be stored in the output.
                        </blockquote>
                        <table>
                            <tr>
                                <td><b>Name</b></td>
                                <td><b>Type</b></td>
                                <td><b>Description</b></td>
                            </tr>
                            <tr>
                                <td>Feature Type</td>
                                <td>uint8</td>
                                <td>
                                    Set to <strong>value 2</strong> to denote a <i>Metadata Feature</i>.
                                </td>
                            </tr>
                            <tr>
                                <td>Data</td>
                                <td>(uint16)ByteArray</td>
                                <td>Binary data. A leading uint16 denotes its length.</td>
                            </tr>
                        </table>
                    </details>
                    <details>
                        <summary>Tag Feature</summary>
                        <blockquote>
                            Defines an indexation tag to which the output can be indexed by additional node plugins.
                        </blockquote>
                        <table>
                            <tr>
                                <td><b>Name</b></td>
                                <td><b>Type</b></td>
                                <td><b>Description</b></td>
                            </tr>
                            <tr>
                                <td>Feature Type</td>
                                <td>uint8</td>
                                <td>
                                    Set to <strong>value 3</strong> to denote a <i>Tag Feature</i>.
                                </td>
                            </tr>
                            <tr>
                                <td>Tag</td>
                                <td>(uint8)ByteArray</td>
                                <td>Binary indexation data. A leading uint8 denotes its length.</td>
                            </tr>
                        </table>
                    </details>
                </td>
            </tr>
            <tr>
                <td>Immutable Features Count</td>
                <td>uint8</td>
                <td>The number of immutable features following. Immutable features are defined upon deployment of the UTXO state machine and are not allowed to change in any future state transition.</td>
            </tr>
            <tr>
                <td valign="top">Immutable Features <code>atMostOneOfEach</code></td>
                <td colspan="2">
                    <details>
                        <summary>Issuer Feature</summary>
                        <blockquote>
                            Identifies the validated issuer of the UTXO state machine.
                        </blockquote>
                        <table>
                            <tr>
                                <td><b>Name</b></td>
                                <td><b>Type</b></td>
                                <td><b>Description</b></td>
                            </tr>
                            <tr>
                                <td>Feature Type</td>
                                <td>uint8</td>
                                <td>
                                    Set to <strong>value 1</strong> to denote an <i>Issuer Feature</i>.
                                </td>
                            </tr>
                            <tr>
                                <td valign="top">Address <code>oneOf</code></td>
                                <td colspan="2">
                                    <details>
                                        <summary>Ed25519 Address</summary>
                                        <table>
                                            <tr>
                                                <td><b>Name</b></td>
                                                <td><b>Type</b></td>
                                                <td><b>Description</b></td>
                                            </tr>
                                            <tr>
                                                <td>Address Type</td>
                                                <td>uint8</td>
                                                <td>
                                                    Set to <strong>value 0</strong> to denote an <i>Ed25519 Address</i>.
                                                </td>
                                            </tr>
                                            <tr>
                                                <td>PubKeyHash</td>
                                                <td>ByteArray[32]</td>
                                                <td>The raw bytes of the Ed25519 address which is a BLAKE2b-256 hash of the Ed25519 public key.</td>
                                            </tr>
                                        </table>
                                    </details>
                                    <details>
                                        <summary>Alias Address</summary>
                                        <table>
                                            <tr>
                                                <td><b>Name</b></td>
                                                <td><b>Type</b></td>
                                                <td><b>Description</b></td>
                                            </tr>
                                            <tr>
                                                <td>Address Type</td>
                                                <td>uint8</td>
                                                <td>
                                                    Set to <strong>value 8</strong> to denote an <i>Alias Address</i>.
                                                </td>
                                            </tr>
                                            <tr>
                                                <td>Alias ID</td>
                                                <td>ByteArray[32]</td>
                                                <td>The raw bytes of the <i>Alias ID</i> which is the BLAKE2b-256 hash of the outputID that created it.</td>
                                            </tr>
                                        </table>
                                    </details>
                                    <details>
                                        <summary>NFT Address</summary>
                                        <table>
                                            <tr>
                                                <td><b>Name</b></td>
                                                <td><b>Type</b></td>
                                                <td><b>Description</b></td>
                                            </tr>
                                            <tr>
                                                <td>Address Type</td>
                                                <td>uint8</td>
                                                <td>
                                                    Set to <strong>value 16</strong> to denote an <i>NFT Address</i>.
                                                </td>
                                            </tr>
                                            <tr>
                                                <td>NFT ID</td>
                                                <td>ByteArray[32]</td>
                                                <td>The raw bytes of the <i>NFT ID</i> which is the BLAKE2b-256 hash of the outputID that created it.</td>
                                            </tr>
                                        </table>
                                    </details>
                                </td>
                            </tr>
                        </table>
                    </details>
                    <details>
                        <summary>Metadata Feature</summary>
                        <blockquote>
                            Defines metadata (arbitrary binary data) that will be stored in the output.
                        </blockquote>
                        <table>
                            <tr>
                                <td><b>Name</b></td>
                                <td><b>Type</b></td>
                                <td><b>Description</b></td>
                            </tr>
                            <tr>
                                <td>Feature Type</td>
                                <td>uint8</td>
                                <td>
                                    Set to <strong>value 2</strong> to denote a <i>Metadata Feature</i>.
                                </td>
                            </tr>
                            <tr>
                                <td>Data</td>
                                <td>(uint16)ByteArray</td>
                                <td>Binary data. A leading uint16 denotes its length.</td>
                            </tr>
                        </table>
                    </details>
                </td>
            </tr>
        </table>
    </details>
</table>
<h3 id="additional-transaction-syntactic-validation-rules-3"><a class="header" href="#additional-transaction-syntactic-validation-rules-3">Additional Transaction Syntactic Validation Rules</a></h3>
<h4 id="output-syntactic-validation-2"><a class="header" href="#output-syntactic-validation-2">Output Syntactic Validation</a></h4>
<ul>
<li><code>Amount</code> field must fulfill the dust protection requirements and must not be <code>0</code>.</li>
<li><code>Amount</code> field must be ≤ <code>Max IOTA Supply</code>.</li>
<li><code>Native Tokens Count</code> must not be greater than <code>Max Native Tokens Count</code>.</li>
<li><code>Native Tokens</code> must be lexicographically sorted based on <code>Token ID</code>.</li>
<li>Each <i>Native Token</i> must be unique in the set of <code>Native Tokens</code> based on its <code>Token ID</code>. No duplicates are
allowed.</li>
<li><code>Amount</code> of any <i>Native Token</i> must not be <code>0</code>.</li>
<li>It must hold true that <code>1</code> ≤ <code>Unlock Conditions Count</code> ≤ <code>4</code>.</li>
<li><code>Unlock Condition Type</code> of an <i>Unlock Condition</i> must define one of the following types:
<ul>
<li><i>Address Unlock Condition</i></li>
<li><i>Storage Deposit Return Unlock Condition</i></li>
<li><i>Timelock Unlock Condition</i></li>
<li><i>Expiration Unlock Condition</i></li>
</ul>
</li>
<li><i>Unlock Conditions</i> must be sorted in ascending order based on their <code>Unlock Condition Type</code>.</li>
<li>Syntactic validation of all present unlock conditions must pass.</li>
<li><i>Address Unlock Condition</i> must be present.</li>
<li>It must hold true that <code>0</code> ≤ <code>Features Count</code> ≤ <code>3</code>.</li>
<li><code>Feature Type</code> of a <i>Feature</i> in <code>Features</code> must define one of the following types:
<ul>
<li><i>Sender Feature</i></li>
<li><i>Metadata Feature</i></li>
<li><i>Tag Feature</i></li>
</ul>
</li>
<li>It must hold true that <code>0</code> ≤ <code>Immutable Features Count</code> ≤ <code>2</code>.</li>
<li><code>Feature Type</code> of a <i>Feature</i> in <code>Immutable Features</code> must define one of the following types:
<ul>
<li><i>Issuer Feature</i></li>
<li><i>Metadata Feature</i></li>
</ul>
</li>
<li><i>Features</i> must be sorted in ascending order based on their <code>Feature Type</code> both in <code>Features</code> and <code>Immutable Features</code>
fields.</li>
<li>Syntactic validation of all present features must pass.</li>
<li><code>Address</code> field of the <i>Address Unlock Condition</i> must not be the same as the NFT address derived from <code>NFT ID</code>.</li>
</ul>
<h3 id="additional-transaction-semantic-validation-rules-3"><a class="header" href="#additional-transaction-semantic-validation-rules-3">Additional Transaction Semantic Validation Rules</a></h3>
<ul>
<li>Explicit <code>NFT ID</code>: <code>NFT ID</code> is taken as the value of the <code>NFT ID</code> field in the NFT output.</li>
<li>Implicit <code>NFT ID</code>: When an NFT output is consumed as an input in a transaction and <code>NFT ID</code> field is zeroed out, take
the BLAKE2b-256 hash of the <code>Output ID</code> of the input as <code>NFT ID</code>.</li>
<li>For every non-zero explicit <code>NFT ID</code> on the output side there must be a corresponding NFT on the input side. The
corresponding NFT has the explicit or implicit <code>NFT ID</code> equal to that of the NFT on the output side.</li>
</ul>
<h4 id="consumed-outputs-2"><a class="header" href="#consumed-outputs-2">Consumed Outputs</a></h4>
<ul>
<li>The unlock of the input corresponds to <code>Address</code> field of the <i>Address Unlock Condition</i> and the unlock is
valid.</li>
<li>The unlock is valid if and only if all unlock conditions and features present in the output validate.</li>
<li>When a consumed NFT output has a corresponding NFT output on the output side, <code>Immutable Features</code> field must not
change.</li>
<li>When a consumed NFT output has no corresponding NFT output on the output side, the NFT it is being burned. Funds
and assets inside the burned NFT output must be redistributed to other outputs in the burning transaction.</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th>:bangbang:  Careful with NFT burning :bangbang:</th></tr></thead><tbody>
</tbody></table>
</div>
<p><em>Other outputs in the ledger that are locked to the address of the NFT can only be unlocked by including the NFT itself
in the transaction. If the NFT is burned, such funds are locked forever. It is strongly advised to always check and
sweep what the NFT owns in the ledger before burning it.</em></p>
<h4 id="created-outputs-2"><a class="header" href="#created-outputs-2">Created Outputs</a></h4>
<ul>
<li>When <code>Issuer Feature</code> is present in an output and explicit <code>NFT ID</code> is zeroed out, an input with <code>Address</code> field that
corresponds to <code>Issuer</code> must be unlocked in the transaction. If <code>Address</code> is either <i>Alias Address</i> or
<i>NFT Address</i>, their corresponding outputs (defined by <code>Alias ID</code> and <code>NFT ID</code>) must be unlocked in the transaction.</li>
<li>All <i>Unlock Condition</i> imposed transaction validation criteria must be fulfilled.</li>
<li>All <i>Feature</i> imposed transaction validation criteria must be fulfilled.</li>
</ul>
<h3 id="notes-2"><a class="header" href="#notes-2">Notes</a></h3>
<ul>
<li>It would be possible to have two-step issuer verification: First NFT is minted, and then metadata can be immutably
locked into the output. The metadata contains an issuer public key plus a signature of the unique <code>NFT ID</code>. This way
a smart contract chain can mint on behalf of the user, and then push the issuer signature in a next step.</li>
</ul>
<h2 id="unlocking-chain-script-locked-outputs"><a class="header" href="#unlocking-chain-script-locked-outputs">Unlocking Chain Script Locked Outputs</a></h2>
<p>Two of the introduced output types (<a href="tips/TIP-0018/tip-0018.html#alias-output">Alias</a>, <a href="tips/TIP-0018/tip-0018.html#nft-output">NFT</a>) implement the so-called UTXO chain
constraint. These outputs receive their unique identifiers upon creation, generated by the protocol, and carry it
forward with them through transactions until they are destroyed. These unique identifiers (<code>Alias ID</code>, <code>NFT ID</code>) also
function as global addresses for the state machines, but unlike <i>Ed25519 Addresses</i>, they are not backed by private
keys that could be used for signing. The rightful owners who can unlock these addresses are defined in the outputs
themselves.</p>
<p>Since such addresses are accounts in the ledger, it is possible to send funds to these addresses. The unlock mechanism
of such funds is designed in a way that <strong>proving ownership of the address is reduced to the ability to unlock the
corresponding output that defines the address.</strong></p>
<h3 id="alias-locking--unlocking"><a class="header" href="#alias-locking--unlocking">Alias Locking &amp; Unlocking</a></h3>
<p>A transaction may consume a (non-alias) output that belongs to an <i>Alias Address</i> by state transitioning the alias output with the matching <code>Alias ID</code>. This serves the exact same purpose as providing a signature
to unlock an output locked under a private key backed address, such as <i>Ed25519 Addresses</i>.</p>
<p>On protocol level, alias unlocking is done using a new unlock type, called <strong>Alias Unlock</strong>.</p>
<details>
    <summary>Alias Unlock</summary>
    <blockquote>
            Points to the unlock of a consumed alias output.
    </blockquote>
</details>
<table>
    <tr>
        <td><b>Name</b></td>
        <td><b>Type</b></td>
        <td><b>Description</b></td>
    </tr>
    <tr>
        <td>Unlock Type</td>
        <td>uint8</td>
        <td>
            Set to <strong>value 2</strong> to denote a <i>Alias Unlock</i>.
        </td>
    </tr>
    <tr>
        <td>Alias Reference Unlock Index</td>
        <td>uint16</td>
        <td>
            Index of input and unlock corresponding to an alias output.
        </td>
    </tr>
</table>
<p>This unlock is similar to the <i>Reference Unlock</i>. However, it is valid if and only if the input of the
transaction at index <code>Alias Reference Unlock Index</code> is an alias output with the same <code>Alias ID</code> as the one derived from
the <code>Address</code> field of the to-be unlocked output.</p>
<p>Additionally, the <i>Alias Unlocks</i> must also be ordered to prevent circular dependencies:</p>
<p>If the i-th <em>Unlock</em> of a transaction is an <em>Alias Unlock</em> and has <code>Alias Reference Unlock Index</code> set to k,
it must hold that i &gt; k. Hence, an <i>Alias Unlock</i> can only reference an <em>Unlock</em> (unlocking the
corresponding alias) at a smaller index.</p>
<p>For example the scenario where <code>Alias A</code> is locked to the address of <code>Alias B</code> while <code>Alias B</code> is in locked to the
address of <code>Alias A</code> introduces a circular dependency and is not well-defined. By requiring the <em>Unlocks</em> to be
ordered as described above, a transaction consuming <code>Alias A</code> as well as <code>Alias B</code> can never be valid as there would
always need to be one <em>Alias Unlock</em> referencing a greater index.</p>
<h4 id="alias-unlock-syntactic-validation"><a class="header" href="#alias-unlock-syntactic-validation">Alias Unlock Syntactic Validation</a></h4>
<ul>
<li>It must hold that 0 ≤ <code>Alias Reference Unlock Index</code> &lt; <code>Max Inputs Count</code>.</li>
</ul>
<h4 id="alias-unlock-semantic-validation"><a class="header" href="#alias-unlock-semantic-validation">Alias Unlock Semantic Validation</a></h4>
<ul>
<li>The address of the unlocking condition of the input being unlocked must be an <i>Alias Address</i>.</li>
<li>The index <code>i</code> of the <i>Alias Unlock</i> is the index of the input in the transaction that it unlocks.
<code>Alias Reference Unlock Index</code> must be &lt; <code>i</code>.</li>
<li><code>Alias Reference Unlock Index</code> defines a previous input of the transaction and its unlock. This input must
be an <i>Alias Output</i> with <code>Alias ID</code> that refers to the <i>Alias Address</i> being unlocked.</li>
<li>The referenced <i>Alias Output</i> must be unlocked for state transition.</li>
</ul>
<h3 id="nft-locking--unlocking"><a class="header" href="#nft-locking--unlocking">NFT Locking &amp; Unlocking</a></h3>
<p><code>NFT ID</code> field is functionally equivalent to <code>Alias ID</code> of an alias output. It is generated the same way, but it can
only exist in NFT outputs. Following the same analogy as for alias addresses, NFT addresses are iota addresses that are
controlled by whoever owns the NFT output itself.</p>
<p>Outputs that are locked under <code>NFT Address</code> can be unlocked by unlocking the NFT output in the same transaction that
defines <code>NFT Address</code>, that is, the NFT output where <code>NFT Address Type Byte || NFT ID = NFT Address</code>.</p>
<p>An <i>NFT Unlock</i> looks and behaves like an <i>Alias Unlock</i>, but the referenced input at the index must
be an NFT output with the matching <code>NFT ID</code>.</p>
<details>
    <summary>NFT Unlock</summary>
    <blockquote>
            Points to the unlock of a consumed NFT output.
    </blockquote>
</details>
<table>
    <tr>
        <td><b>Name</b></td>
        <td><b>Type</b></td>
        <td><b>Description</b></td>
    </tr>
    <tr>
        <td>Unlock Type</td>
        <td>uint8</td>
        <td>
            Set to <strong>value 3</strong> to denote a <i>NFT Unlock</i>.
        </td>
    </tr>
    <tr>
        <td>NFT Reference Unlock Index</td>
        <td>uint16</td>
        <td>
            Index of input and unlock corresponding to an NFT output.
        </td>
    </tr>
</table>
<p>An <em>NFT Unlock</em> is only valid if the input in the transaction at index <code>NFT Reference Unlock Index</code> is the NFT
output with the same <code>NFT ID</code> as the one derived from the <code>Address</code> field of the to-be unlocked output.</p>
<p>If the i-th <em>Unlock</em> of a transaction is an <em>NFT Unlock</em> and has <code>NFT Reference Unlock Index</code> set to k, it
must hold that i &gt; k. Hence, an <i>NFT Unlock</i> can only reference an <em>Unlock</em> at a smaller index.</p>
<h4 id="nft-unlock-syntactic-validation"><a class="header" href="#nft-unlock-syntactic-validation">NFT Unlock Syntactic Validation</a></h4>
<ul>
<li>It must hold that 0 ≤ <code>NFT Reference Unlock Index</code> &lt; <code>Max Inputs Count</code>.</li>
</ul>
<h4 id="nft-unlock-semantic-validation"><a class="header" href="#nft-unlock-semantic-validation">NFT Unlock Semantic Validation</a></h4>
<ul>
<li>The address of the input being unlocked must be an <i>NFT Address</i>.</li>
<li>The index <code>i</code> of the <i>NFT Unlock</i> is the index of the input in the transaction that it unlocks.
<code>NFT Reference Unlock Index</code> must be &lt; <code>i</code>.</li>
<li><code>NFT Reference Unlock Index</code> defines a previous input of the transaction and its unlock. This input must
be an <i>NFT Output</i> with <code>NFT ID</code> that refers to the <i>NFT Address</i> being unlocked.</li>
</ul>
<h1 id="drawbacks-11"><a class="header" href="#drawbacks-11">Drawbacks</a></h1>
<ul>
<li>New output types increase transaction validation complexity, however it is still bounded.</li>
<li>Outputs take up more space in the ledger, UTXO database size might increase.</li>
<li>It is possible to intentionally deadlock aliases and NFTs, however client side software can notify users when they
perform such action. Deadlocked aliases and NFTs can not be unlocked, but this is true for any funds locked into
unspendable addresses.</li>
<li>Time based output locking conditions can only be evaluated after attachment to the Tangle, during milestone
confirmation.</li>
<li>IOTA ledger can only support hard-coded scripts. Users can not write their own scripts because there is no way
currently to charge them based on resource usage, all IOTA transactions are feeless by nature.</li>
<li>Aliases can be destroyed even if there are foundries alive that they control. Since only the controlling alias can
unlock the foundry, such foundries and the supply of the tokens remain forever locked in the Tangle.</li>
<li>Token schemes and needed supply control rules are unclear.</li>
</ul>
<h1 id="rationale-and-alternatives-13"><a class="header" href="#rationale-and-alternatives-13">Rationale and alternatives</a></h1>
<p>The feeless nature of IOTA makes it inherently impossible to implement smart contracts on layer 1. A smart contract
platform shall not only be capable of executing smart contracts, but also to limit their resource usage and make users
pay validators for the used resources. IOTA has no concept of validators, neither fees. While it would technically be
possible to run EUTXO smart contracts on the layer 1 Tangle, it is not possible to properly charge users for executing
them.</p>
<p>The current design aims to combine the best of both worlds: Scalable and feeless layer 1 and  Turing-complete smart
contracts on layer 2. Layer 1 remains scalable because of parallel transaction validation, feeless because the bounded
hard-coded script execution time, and layer 2 can offer support for all kinds of virtual machines, smart contracts and
advanced tokenization use cases.</p>
<h1 id="unresolved-questions-4"><a class="header" href="#unresolved-questions-4">Unresolved questions</a></h1>
<ul>
<li>List of supported <i>Token Schemes</i> is not complete.
<ul>
<li>Deflationary token scheme</li>
<li>Inflationary token scheme with scheduled minting</li>
<li>etc.</li>
</ul>
</li>
<li>Adapt the current congestion control, i.e. <em>Block PoW</em>, to better match the validation complexity of the different
outputs and types.</li>
</ul>
<h2 id="copyright-17"><a class="header" href="#copyright-17">Copyright</a></h2>
<p>Copyright and related rights waived via <a href="https://creativecommons.org/publicdomain/zero/1.0/">CC0</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><pre>
tip: 19
title: Dust Protection Based on Byte Costs (Storage Deposit)
description: Prevent bloating the ledger size with dust outputs
author: Max Hase (@muXxer) <maximilian.hase@iota.org>
discussions-to: https://github.com/iotaledger/tips/pull/39
status: Active
type: Standards
layer: Core
created: 2021-11-04
requires: TIP-18, TIP-20, TIP-21 and TIP-22
replaces: TIP-15
</pre>
<h2 id="summary-17"><a class="header" href="#summary-17">Summary</a></h2>
<p>The current <code>dust protection</code> in <code>chrysalis-pt2</code> is only an intermediate solution to prevent attacks or misbehavior that could bloat the ledger database. The design has several drawbacks, e.g. it does not scale, relies on a total ordering of the tangle and it is rather complicated to use from a user point of view.</p>
<p>This document describes a new <code>dust protection</code> concept, called <code>storage deposit</code>, which solves the mentioned drawbacks and creates a monetary incentive to keep the ledger state small. It focuses on the underlying problem, the increase in database size, instead of artificially limiting the number of UTXOs. This is achieved by enforcing a minimum IOTA coin deposit in every output based on the actually used disc space of the output itself.</p>
<h2 id="motivation-16"><a class="header" href="#motivation-16">Motivation</a></h2>
<p>In a distributed ledger network, every participant, a so-called node, needs to keep track of the current ledger state. Since <code>chrysalis-pt2</code>, the IOTA ledger state is based on the UTXO model, where every node keeps track of all the currently unspent outputs. Without <code>dust protection</code>, even outputs containing only one single IOTA coin are valid and therefore stored in the database.</p>
<p>Misusage by honest users or intentionally bad behavior by malicious actors can lead to growing database and snapshot sizes and increasing computational costs (database lookups, balance calculations). Due to these increasing hardware requirements, the entry barrier to participate in the network becomes unaffordable and less nodes would operate the network.</p>
<p>Especially in a fee-less system like IOTA, this is a serious issue, since an attacker can create a lot of damage with low effort. Other DLTs do not yet face this problem, as such an attack would be much more expensive due to the high transaction fees.
However, in order to solve scalability issues more and more transactions need to be handled. Therefore, other DLT projects will also eventually run into the same dust limitations. This document proposes to introduce <code>storage deposit</code> to address this.</p>
<h2 id="requirements"><a class="header" href="#requirements">Requirements</a></h2>
<ul>
<li>The maximum possible ledger database size must be limited to a reasonable and manageable size.</li>
<li>The <code>dust protection</code> must not depend on a global shared state of the ledger, so that transaction validation can happen in parallel.</li>
<li>The <code>dust protection</code> should work for outputs with arbitrary data and size.</li>
<li>The ledger database size should be fairly allocated to users based on the scarce resource, IOTA coins.</li>
</ul>
<h2 id="detailed-design-15"><a class="header" href="#detailed-design-15">Detailed Design</a></h2>
<p>The current <code>dust protection</code> solution in <code>chrysalis-pt2</code> does not satisfy the mentioned requirements for the following reasons:</p>
<ul>
<li>The enforced maximum limit of disc space is ~6.5 TB.</li>
<li>The dust allowance mechanism depends on the total amount of funds in <code>DustAllowanceOutput</code> per address, which is a global shared state.</li>
<li>It is designed for one fixed output size.</li>
</ul>
<p>Therefore, a new transaction validation rule is introduced which replaces the former <code>dust protection</code> solution completely.</p>
<p>Blocks including payloads, even transaction payloads, are considered to be pruned by the nodes, but unspent transaction outputs must be kept until they are spent. Therefore the <code>dust protection</code> is based on the unspent outputs only.</p>
<p><strong>Every output created by a transaction needs to have at least a minimum amount of IOTA coins deposited in the output itself, otherwise the output is syntactically invalid.</strong></p>
<p>min_deposit_of_output = ⌊v_byte_cost · v_byte⌋<br />
v_byte = ∑(weight<sub>𝑖</sub> · byte_size<sub>𝑖</sub>) + offset</p>
<p>where:</p>
<ul>
<li>v_byte_cost: costs in IOTA coins per virtual byte</li>
<li>weight<sub>𝑖</sub>: factor of field 𝑖 that takes computational and storage costs into account</li>
<li>byte_size<sub>𝑖</sub>: size of field 𝑖 in bytes</li>
<li>offset: additional v_bytes that are caused by additional data that has to be stored in the database but is not part of the output itself</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th>:warning: <code>min_deposit_of_output</code> is rounded down</th></tr></thead><tbody>
</tbody></table>
</div>
<p>Starting with the tokenization and smart contracts mainnet upgrade, new <a href="tips/TIP-0019/../TIP-0018/tip-0018.html">output types are introduced by TIP-18</a> that contain mandatory and optional fields with variable length. Each of these fields result in different computational and storage costs, which will be considered by the positive <code>weight_i</code>. The size of the field itself is expressed with <code>byte_size_i</code>. <code>offset</code> is used to take the overhead of the specific output itself into account.</p>
<p>The <code>v_byte_cost</code> is a protocol value, which has to be defined based on reasonable calculations and estimates.</p>
<p><strong>In simple words, the more data you write to the global ledger database, the more IOTA you need to deposit in the output.</strong>
This is not a fee, because the deposited coins can be reclaimed by consuming the output in a new transaction.</p>
<h3 id="advantages"><a class="header" href="#advantages">Advantages</a></h3>
<p>The proposed solution has several advantages over the former solution.</p>
<p>First of all, the database size is limited to an absolute maximum size. Since the total supply of IOTA coins stays constant, also the maximum amount of <code>v_bytes</code> that can ever be written to the database remains constant.</p>
<p>Total ordering of the tangle is not necessary because there is no shared global ledger state for transaction validation anymore. The node can determine if the transaction is valid and the dust protection rules are fulfilled, just by looking at the transaction itself. Therefore this solution is also suitable for IOTA 2.0.</p>
<p>By introducing a certain cost for every byte stored in the ledger, it is possible to store arbitrary data in the outputs, as long as enough IOTA coins are deposited in the output itself to keep the information retained. This enables permanent storage of data in a distributed and decentralized way, without the need of a permanode.</p>
<p>Users have an economic incentive to clean up the database. By consuming old unused outputs, users can reclaim their deposited IOTA coins.</p>
<h3 id="drawbacks-12"><a class="header" href="#drawbacks-12">Drawbacks</a></h3>
<p>This solution prevents seamless microtransactions, which are a unique selling point for IOTA, because the issuer of the transaction always needs to deposit <code>min_deposit_of_output</code> IOTA coins in the output created by the transaction. This minimum deposit will have a higher value than the microtransaction itself, which basically makes microtransactions impossible. Two different solutions to circumvent this obstacle are introduced <a href="tips/TIP-0019/tip-0019.html#Microtransactions">here</a>.</p>
<h3 id="how-does-it-affect-other-parts-of-the-protocol"><a class="header" href="#how-does-it-affect-other-parts-of-the-protocol">How does it affect other parts of the protocol?</a></h3>
<p>The <code>dust protection</code> only affects &quot;value-transactions&quot;. Since blocks containing other payloads are not stored in the ledger state and are subject to pruning, they cannot cause permanent &quot;dust&quot; and do not need to be considered for <code>dust protection</code>.
However, all output types like e.g. smart contract requests are affected and must comply with the <code>min_deposit_of_output</code> criteria. Therefore, these requests could get quite expensive for the user, but the same mechanism introduced for <a href="tips/TIP-0019/tip-0019.html#Microtransactions-on-Layer-1">Microtransactions on Layer 1</a> can be utilized for smart contract requests as well.</p>
<h3 id="byte-cost-calculations"><a class="header" href="#byte-cost-calculations">Byte cost calculations</a></h3>
<p>To limit the maximum database size, the total IOTA supply needs to be divided by the target database size in bytes to get the worst case scenario regarding the byte costs.</p>
<p>However, in this scenario no outputs hold more IOTA coins than required for the <code>dust protection</code>. This does not represent the real distribution of funds over the UTXOs. We could assume that these output amounts follow Zipf's law. Unfortunately, fitting a Zipf distribution to the current ledger state will not match the future distribution of the funds for several reasons:</p>
<ul>
<li>There is already another <code>dust protection</code> in place, which distorts the distribution.</li>
<li>With new use cases enabled by the new <code>dust protection</code> (e.g. tokenization, storing arbitrary data in the ledger), the distribution will dramatically change.</li>
<li>Fittings for other DLT projects do not match because there are transaction fees in place, which decrease the amount of dust outputs in the distribution.</li>
</ul>
<p>Another possibility would be to estimate how much percentage of the database will be used for outputs with minimum required deposit (<code>fund sparsitiy percentage</code>) in the future. The remaining IOTA coins can be ignored in that case to simplify the calculation. Since a fund sparsity percentage of less than 20% would already be bad for other upcoming protocol features like the mana calculation, we could take this value for our calculation instead of the worst case.</p>
<h3 id="weights-for-different-outputs"><a class="header" href="#weights-for-different-outputs">Weights for different outputs</a></h3>
<p>The different output types mentioned in the <a href="tips/TIP-0019/../TIP-0018/tip-0018.html">Output Types TIP-18</a> contain several mandatory and optional fields. Every field itself creates individual computational and storage requirements for the node, which is considered by having different weights for every field.</p>
<h5 id="field-types"><a class="header" href="#field-types">Field types</a></h5>
<p>The following table describes different field types in an output:</p>
<table>
    <tr>
        <th>Name</th>
        <th>Description</th>
        <th>Weight</th>
        <th>Reasoning</th>
    </tr>
    <tr>
        <td><code>key</code></td>
        <td>Creates a key lookup in the database.</td>
        <td>10.0</td>
        <td>Keys need to be stored in the LSM tree of the key-value database engine and need to be merged and leveled, which is computational-, memory- and read/write IO-wise a heavy task.</td>
    </tr>
    <tr>
        <td><code>data</code></td>
        <td>Plain binary data on disk.</td>
        <td>1.0</td>
        <td>Data is stored as the value in the key-value database, and therefore only consumes disc space.</td>
    </tr>
</table>
<div class="table-wrapper"><table><thead><tr><th>:warning:  Protocol parameters are not set yet</th></tr></thead><tbody>
</tbody></table>
</div>
<p>Protocol parameters presented in this document are design parameters that will change in the future based on simulation results, benchmarking and security assumptions. The reader should not take these values as definitive.</p>
<p>An example of such parameter for example is the <code>weight</code> assigned to different output field types.</p>
<h4 id="outputs-1"><a class="header" href="#outputs-1">Outputs</a></h4>
<p>The following tables show the different outputs including the possible fields and their specific weight.</p>
<table>
    <details>
        <summary>Basic Output</summary>
        <blockquote>
            Describes a basic output with optional features.
        </blockquote>
        <table>
            <tr>
                <td>Offset</td>
                <td>
                    <table>
                        <tr>
                            <td><b>Field</b></td>
                            <td><b>Field type</b></td>
                            <td><b>Length Minimum</b></td>
                            <td><b>Length Maximum</b></td>
                            <td><b>Description</b></td>
                        </tr>
                        <tr>
                            <td>OutputID</td>
                            <td><code>key</code></td>
                            <td>34</td>
                            <td>34</td>
                            <td>The ID of the output.</td>
                        </tr>
                        <tr>
                            <td>Block ID (included)</td>
                            <td><code>data</code></td>
                            <td>32</td>
                            <td>32</td>
                            <td>The ID of the block in which the transaction payload that created this output was included.</td>
                        </tr>
                        <tr>
                            <td>Confirmation Milestone Index</td>
                            <td><code>data</code></td>
                            <td>4</td>
                            <td>4</td>
                            <td>The index of the milestone which confirmed the transaction that created the output.</td>
                        </tr>
                        <tr>
                            <td>Confirmation Unix Timestamp</td>
                            <td><code>data</code></td>
                            <td>4</td>
                            <td>4</td>
                            <td>The unix timestamp of the milestone which confirmed the transaction that created the output.</td>
                        </tr>
                    </table>
                </td>
            </tr>
            <tr>
                <td>Fields</td>
                <td>
                    <table>
                        <tr>
                            <td><b>Name</b></td>
                            <td><b>Field type</b></td>
                            <td><b>Length Minimum</b></td>
                            <td><b>Length Maximum</b></td>
                            <td><b>Description</b></td>
                        </tr>
                        <tr>
                            <td>Output Type</td>
                            <td><code>data</code></td>
                            <td>1</td>
                            <td>1</td>
                            <td>
                                Set to <strong>value 3</strong> to denote an <i>Basic Output</i>.
                            </td>
                        </tr>
                        <tr>
                            <td>Amount</td>
                            <td><code>data</code></td>
                            <td>8</td>
                            <td>8</td>
                            <td>The amount of IOTA coins held by the output.</td>
                        </tr>
                        <tr>
                            <td>Native Tokens Count</td>
                            <td><code>data</code></td>
                            <td>1</td>
                            <td>1</td>
                            <td>The number of native tokens held by the output.</td>
                        </tr>
                        <tr>
                            <td valign="top">Native Tokens <code>optAnyOf</code></td>
                            <td colspan="2">
                                <details>
                                    <summary>Native Token</summary>
                                    <table>
                                        <tr>
                                            <td><b>Name</b></td>
                                            <td><b>Field type</b></td>
                                            <td><b>Length Minimum</b></td>
                                            <td><b>Length Maximum</b></td>
                                            <td><b>Description</b></td>
                                        </tr>
                                        <tr>
                                            <td>Token ID</td>
                                            <td><code>data</code></td>
                                            <td>38</td>
                                            <td>38</td>
                                            <td>
                                                Identifier of the native token.
                                            </td>
                                        </tr>
                                        <tr>
                                            <td>Amount</td>
                                            <td><code>data</code></td>
                                            <td>32</td>
                                            <td>32</td>
                                            <td>
                                                Amount of native tokens of the given <i>Token ID</i>.
                                            </td>
                                        </tr>
                                    </table>
                                </details>
                            </td>
                        </tr>
                        <tr>
                            <td>Unlock Conditions Count</td>
                            <td><code>data</code></td>
                            <td>1</td>
                            <td>1</td>
                            <td>The number of unlock conditions following.</td>
                        </tr>
                        <tr>
                            <td valign="top">Unlock Conditions <code>atMostOneOfEach</code></td>
                            <td colspan="2">
                                <details>
                                    <summary>Address Unlock Condition</summary>
                                    <table>
                                        <tr>
                                            <td><b>Name</b></td>
                                            <td><b>Field type</b></td>
                                            <td><b>Length Minimum</b></td>
                                            <td><b>Length Maximum</b></td>
                                            <td><b>Description</b></td>
                                        </tr>
                                        <tr>
                                            <td>Unlock Condition Type</td>
                                            <td><code>data</code></td>
                                            <td>1</td>
                                            <td>1</td>
                                            <td>
                                                Set to <strong>value 0</strong> to denote an <i>Address Unlock Condition</i>.
                                            </td>
                                        </tr>
                                        <tr>
                                            <td>Address</td>
                                            <td colspan="2">
                                                <details>
                                                    <summary>Ed25519 Address</summary>
                                                    <table>
                                                        <tr>
                                                            <td><b>Name</b></td>
                                                            <td><b>Field type</b></td>
                                                            <td><b>Length Minimum</b></td>
                                                            <td><b>Length Maximum</b></td>
                                                            <td><b>Description</b></td>
                                                        </tr>
                                                        <tr>
                                                            <td>Address Type</td>
                                                            <td><code>data</code></td>
                                                            <td>1</td>
                                                            <td>1</td>
                                                            <td>
                                                                Set to <strong>value 0</strong> to denote an <i>Ed25519 Address</i>.
                                                            </td>
                                                        </tr>
                                                        <tr>
                                                            <td>PubKeyHash</td>
                                                            <td><code>data</code></td>
                                                            <td>32</td>
                                                            <td>32</td>
                                                            <td>The raw bytes of the Ed25519 address which is a BLAKE2b-256 hash of the Ed25519 public key.</td>
                                                        </tr>
                                                    </table>
                                                </details>
                                                <details>
                                                    <summary>Alias Address</summary>
                                                    <table>
                                                        <tr>
                                                            <td><b>Name</b></td>
                                                            <td><b>Field type</b></td>
                                                            <td><b>Length Minimum</b></td>
                                                            <td><b>Length Maximum</b></td>
                                                            <td><b>Description</b></td>
                                                        </tr>
                                                        <tr>
                                                            <td>Address Type</td>
                                                            <td><code>data</code></td>
                                                            <td>1</td>
                                                            <td>1</td>
                                                            <td>
                                                                Set to <strong>value 8</strong> to denote an <i>Alias Address</i>.
                                                            </td>
                                                        </tr>
                                                        <tr>
                                                            <td>Alias ID</td>
                                                            <td><code>data</code></td>
                                                            <td>32</td>
                                                            <td>32</td>
                                                            <td>The raw bytes of the <i>Alias ID</i> which is the BLAKE2b-256 hash of the outputID that created it.</td>
                                                        </tr>
                                                    </table>
                                                </details>
                                                <details>
                                                    <summary>NFT Address</summary>
                                                    <table>
                                                        <tr>
                                                            <td><b>Name</b></td>
                                                            <td><b>Field type</b></td>
                                                            <td><b>Length Minimum</b></td>
                                                            <td><b>Length Maximum</b></td>
                                                            <td><b>Description</b></td>
                                                        </tr>
                                                        <tr>
                                                            <td>Address Type</td>
                                                            <td><code>data</code></td>
                                                            <td>1</td>
                                                            <td>1</td>
                                                            <td>
                                                                Set to <strong>value 16</strong> to denote an <i>NFT Address</i>.
                                                            </td>
                                                        </tr>
                                                        <tr>
                                                            <td>NFT ID</td>
                                                            <td><code>data</code></td>
                                                            <td>32</td>
                                                            <td>32</td>
                                                            <td>The raw bytes of the <i>NFT ID</i> which is the BLAKE2b-256 hash of the outputID that created it.</td>
                                                        </tr>
                                                    </table>
                                                </details>
                                            </td>
                                        </tr>
                                    </table>
                                </details>
                                <details>
                                    <summary>Storage Deposit Return Unlock Condition</summary>
                                    <blockquote>
                                        Defines the amount of IOTAs used as storage deposit that have to be returned to <i>Return Address</i>.
                                    </blockquote>
                                    <table>
                                        <tr>
                                            <td><b>Name</b></td>
                                            <td><b>Field type</b></td>
                                            <td><b>Length Minimum</b></td>
                                            <td><b>Length Maximum</b></td>
                                            <td><b>Description</b></td>
                                        </tr>
                                        <tr>
                                            <td>Unlock Condition Type</td>
                                            <td><code>data</code></td>
                                            <td>1</td>
                                            <td>1</td>
                                            <td>
                                                Set to <strong>value 1</strong> to denote a <i>Storage Deposit Return Unlock Condition</i>.
                                            </td>
                                        </tr>
                                        <tr>
                                            <td valign="top">Return Address <code>oneOf</code></td>
                                            <td colspan="2">
                                                <details>
                                                    <summary>Ed25519 Address</summary>
                                                    <table>
                                                        <tr>
                                                            <td><b>Name</b></td>
                                                            <td><b>Field type</b></td>
                                                            <td><b>Length Minimum</b></td>
                                                            <td><b>Length Maximum</b></td>
                                                            <td><b>Description</b></td>
                                                        </tr>
                                                        <tr>
                                                            <td>Address Type</td>
                                                            <td><code>data</code></td>
                                                            <td>1</td>
                                                            <td>1</td>
                                                            <td>
                                                                Set to <strong>value 0</strong> to denote an <i>Ed25519 Address</i>.
                                                            </td>
                                                        </tr>
                                                        <tr>
                                                            <td>PubKeyHash</td>
                                                            <td><code>data</code></td>
                                                            <td>32</td>
                                                            <td>32</td>
                                                            <td>The raw bytes of the Ed25519 address which is a BLAKE2b-256 hash of the Ed25519 public key.</td>
                                                        </tr>
                                                    </table>
                                                </details>
                                                <details>
                                                    <summary>Alias Address</summary>
                                                    <table>
                                                        <tr>
                                                            <td><b>Name</b></td>
                                                            <td><b>Field type</b></td>
                                                            <td><b>Length Minimum</b></td>
                                                            <td><b>Length Maximum</b></td>
                                                            <td><b>Description</b></td>
                                                        </tr>
                                                        <tr>
                                                            <td>Address Type</td>
                                                            <td><code>data</code></td>
                                                            <td>1</td>
                                                            <td>1</td>
                                                            <td>
                                                                Set to <strong>value 8</strong> to denote an <i>Alias Address</i>.
                                                            </td>
                                                        </tr>
                                                        <tr>
                                                            <td>Alias ID</td>
                                                            <td><code>data</code></td>
                                                            <td>32</td>
                                                            <td>32</td>
                                                            <td>The raw bytes of the <i>Alias ID</i> which is the BLAKE2b-256 hash of the outputID that created it.</td>
                                                        </tr>
                                                    </table>
                                                </details>
                                                <details>
                                                    <summary>NFT Address</summary>
                                                    <table>
                                                        <tr>
                                                            <td><b>Name</b></td>
                                                            <td><b>Field type</b></td>
                                                            <td><b>Length Minimum</b></td>
                                                            <td><b>Length Maximum</b></td>
                                                            <td><b>Description</b></td>
                                                        </tr>
                                                        <tr>
                                                            <td>Address Type</td>
                                                            <td><code>data</code></td>
                                                            <td>1</td>
                                                            <td>1</td>
                                                            <td>
                                                                Set to <strong>value 16</strong> to denote an <i>NFT Address</i>.
                                                            </td>
                                                        </tr>
                                                        <tr>
                                                            <td>NFT ID</td>
                                                            <td><code>data</code></td>
                                                            <td>32</td>
                                                            <td>32</td>
                                                            <td>The raw bytes of the <i>NFT ID</i> which is the BLAKE2b-256 hash of the outputID that created it.</td>
                                                        </tr>
                                                    </table>
                                                </details>
                                            </td>
                                        </tr>
                                        <tr>
                                            <td>Return Amount</td>
                                            <td><code>data</code></td>
                                            <td>8</td>
                                            <td>8</td>
                                            <td>
                                                Amount of IOTA coins the consuming transaction should deposit to the address defined in <i>Return Address</i>.
                                            </td>
                                        </tr>
                                    </table>
                                </details>
                                <details>
                                    <summary>Timelock Unlock Condition</summary>
                                    <blockquote>
                                        Defines a unix timestamp until which the output can not be unlocked.
                                    </blockquote>
                                    <table>
                                        <tr>
                                            <td><b>Name</b></td>
                                            <td><b>Field type</b></td>
                                            <td><b>Length Minimum</b></td>
                                            <td><b>Length Maximum</b></td>
                                            <td><b>Description</b></td>
                                        </tr>
                                        <tr>
                                            <td>Unlock Condition Type</td>
                                            <td><code>data</code></td>
                                            <td>1</td>
                                            <td>1</td>
                                            <td>
                                                Set to <strong>value 2</strong> to denote a <i>Timelock Unlock Condition</i>.
                                            </td>
                                        </tr>
                                        <tr>
                                            <td>Unix Time</td>
                                            <td><code>data</code></td>
                                            <td>4</td>
                                            <td>4</td>
                                            <td>
                                                Unix time (seconds since Unix epoch) starting from which the output can be consumed.
                                            </td>
                                        </tr>
                                    </table>
                                </details>
                                <details>
                                    <summary>Expiration Unlock Condition</summary>
                                    <blockquote>
                                        Defines a unix time until which only <i>Address</i>, defined in <i>Address Unlock Condition</i>, is allowed to 
                                        unlock the output. After the unix time is reached/passed, only <i>Return Address</i> can unlock it.
                                    </blockquote>
                                    <table>
                                        <tr>
                                            <td><b>Name</b></td>
                                            <td><b>Field type</b></td>
                                            <td><b>Length Minimum</b></td>
                                            <td><b>Length Maximum</b></td>
                                            <td><b>Description</b></td>
                                        </tr>
                                        <tr>
                                            <td>Unlock Condition Type</td>
                                            <td><code>data</code></td>
                                            <td>1</td>
                                            <td>1</td>
                                            <td>
                                                Set to <strong>value 3</strong> to denote a <i>Expiration Unlock Condition</i>.
                                            </td>
                                        </tr>
                                        <tr>
                                            <td valign="top">Return Address <code>oneOf</code></td>
                                            <td colspan="2">
                                                <details>
                                                    <summary>Ed25519 Address</summary>
                                                    <table>
                                                        <tr>
                                                            <td><b>Name</b></td>
                                                            <td><b>Field type</b></td>
                                                            <td><b>Length Minimum</b></td>
                                                            <td><b>Length Maximum</b></td>
                                                            <td><b>Description</b></td>
                                                        </tr>
                                                        <tr>
                                                            <td>Address Type</td>
                                                            <td><code>data</code></td>
                                                            <td>1</td>
                                                            <td>1</td>
                                                            <td>
                                                                Set to <strong>value 0</strong> to denote an <i>Ed25519 Address</i>.
                                                            </td>
                                                        </tr>
                                                        <tr>
                                                            <td>PubKeyHash</td>
                                                            <td><code>data</code></td>
                                                            <td>32</td>
                                                            <td>32</td>
                                                            <td>The raw bytes of the Ed25519 address which is a BLAKE2b-256 hash of the Ed25519 public key.</td>
                                                        </tr>
                                                    </table>
                                                </details>
                                                <details>
                                                    <summary>Alias Address</summary>
                                                    <table>
                                                        <tr>
                                                            <td><b>Name</b></td>
                                                            <td><b>Field type</b></td>
                                                            <td><b>Length Minimum</b></td>
                                                            <td><b>Length Maximum</b></td>
                                                            <td><b>Description</b></td>
                                                        </tr>
                                                        <tr>
                                                            <td>Address Type</td>
                                                            <td><code>data</code></td>
                                                            <td>1</td>
                                                            <td>1</td>
                                                            <td>
                                                                Set to <strong>value 8</strong> to denote an <i>Alias Address</i>.
                                                            </td>
                                                        </tr>
                                                        <tr>
                                                            <td>Alias ID</td>
                                                            <td><code>data</code></td>
                                                            <td>32</td>
                                                            <td>32</td>
                                                            <td>The raw bytes of the <i>Alias ID</i> which is the BLAKE2b-256 hash of the outputID that created it.</td>
                                                        </tr>
                                                    </table>
                                                </details>
                                                <details>
                                                    <summary>NFT Address</summary>
                                                    <table>
                                                        <tr>
                                                            <td><b>Name</b></td>
                                                            <td><b>Field type</b></td>
                                                            <td><b>Length Minimum</b></td>
                                                            <td><b>Length Maximum</b></td>
                                                            <td><b>Description</b></td>
                                                        </tr>
                                                        <tr>
                                                            <td>Address Type</td>
                                                            <td><code>data</code></td>
                                                            <td>1</td>
                                                            <td>1</td>
                                                            <td>
                                                                Set to <strong>value 16</strong> to denote an <i>NFT Address</i>.
                                                            </td>
                                                        </tr>
                                                        <tr>
                                                            <td>NFT ID</td>
                                                            <td><code>data</code></td>
                                                            <td>32</td>
                                                            <td>32</td>
                                                            <td>The raw bytes of the <i>NFT ID</i> which is the BLAKE2b-256 hash of the outputID that created it.</td>
                                                        </tr>
                                                    </table>
                                                </details>
                                            </td>
                                        </tr>
                                        <tr>
                                            <td>Unix Time</td>
                                            <td><code>data</code></td>
                                            <td>4</td>
                                            <td>4</td>
                                            <td>
                                                Before this unix time, <i>Address Unlock Condition</i> is allowed to unlock the output, after that only the address defined in <i>Return Address</i>.
                                            </td>
                                        </tr>
                                    </table>
                                </details>
                            </td>
                        </tr>
                        <tr>
                            <td>Features Count</td>
                            <td><code>data</code></td>
                            <td>1</td>
                            <td>1</td>
                            <td>The number of features following.</td>
                        </tr>
                        <tr>
                            <td valign="top">Features <code>atMostOneOfEach</code></td>
                            <td colspan="2">
                                <details>
                                    <summary>Sender Feature</summary>
                                    <blockquote>
                                        Identifies the validated sender of the output.
                                    </blockquote>
                                    <table>
                                        <tr>
                                            <td><b>Name</b></td>
                                            <td><b>Field type</b></td>
                                            <td><b>Length Minimum</b></td>
                                            <td><b>Length Maximum</b></td>
                                            <td><b>Description</b></td>
                                        </tr>
                                        <tr>
                                            <td>Feature Type</td>
                                            <td><code>data</code></td>
                                            <td>1</td>
                                            <td>1</td>
                                            <td>
                                                Set to <strong>value 0</strong> to denote a <i>Sender Feature</i>.
                                            </td>
                                        </tr>
                                        <tr>
                                            <td valign="top">Sender <code>oneOf</code></td>
                                            <td colspan="2">
                                                <details>
                                                    <summary>Ed25519 Address</summary>
                                                    <table>
                                                        <tr>
                                                            <td><b>Name</b></td>
                                                            <td><b>Field type</b></td>
                                                            <td><b>Length Minimum</b></td>
                                                            <td><b>Length Maximum</b></td>
                                                            <td><b>Description</b></td>
                                                        </tr>
                                                        <tr>
                                                            <td>Address Type</td>
                                                            <td><code>data</code></td>
                                                            <td>1</td>
                                                            <td>1</td>
                                                            <td>
                                                                Set to <strong>value 0</strong> to denote an <i>Ed25519 Address</i>.
                                                            </td>
                                                        </tr>
                                                        <tr>
                                                            <td>PubKeyHash</td>
                                                            <td><code>data</code></td>
                                                            <td>32</td>
                                                            <td>32</td>
                                                            <td>The raw bytes of the Ed25519 address which is a BLAKE2b-256 hash of the Ed25519 public key.</td>
                                                        </tr>
                                                    </table>
                                                </details>
                                                <details>
                                                    <summary>Alias Address</summary>
                                                    <table>
                                                        <tr>
                                                            <td><b>Name</b></td>
                                                            <td><b>Field type</b></td>
                                                            <td><b>Length Minimum</b></td>
                                                            <td><b>Length Maximum</b></td>
                                                            <td><b>Description</b></td>
                                                        </tr>
                                                        <tr>
                                                            <td>Address Type</td>
                                                            <td><code>data</code></td>
                                                            <td>1</td>
                                                            <td>1</td>
                                                            <td>
                                                                Set to <strong>value 8</strong> to denote an <i>Alias Address</i>.
                                                            </td>
                                                        </tr>
                                                        <tr>
                                                            <td>Alias ID</td>
                                                            <td><code>data</code></td>
                                                            <td>32</td>
                                                            <td>32</td>
                                                            <td>The raw bytes of the <i>Alias ID</i> which is the BLAKE2b-256 hash of the outputID that created it.</td>
                                                        </tr>
                                                    </table>
                                                </details>
                                                <details>
                                                    <summary>NFT Address</summary>
                                                    <table>
                                                        <tr>
                                                            <td><b>Name</b></td>
                                                            <td><b>Field type</b></td>
                                                            <td><b>Length Minimum</b></td>
                                                            <td><b>Length Maximum</b></td>
                                                            <td><b>Description</b></td>
                                                        </tr>
                                                        <tr>
                                                            <td>Address Type</td>
                                                            <td><code>data</code></td>
                                                            <td>1</td>
                                                            <td>1</td>
                                                            <td>
                                                                Set to <strong>value 16</strong> to denote an <i>NFT Address</i>.
                                                            </td>
                                                        </tr>
                                                        <tr>
                                                            <td>NFT ID</td>
                                                            <td><code>data</code></td>
                                                            <td>32</td>
                                                            <td>32</td>
                                                            <td>The raw bytes of the <i>NFT ID</i> which is the BLAKE2b-256 hash of the outputID that created it.</td>
                                                        </tr>
                                                    </table>
                                                </details>
                                            </td>
                                        </tr>
                                    </table>
                                </details>
                                <details>
                                    <summary>Metadata Feature</summary>
                                    <blockquote>
                                        Defines metadata (arbitrary binary data) that will be stored in the output.
                                    </blockquote>
                                    <table>
                                        <tr>
                                            <td><b>Name</b></td>
                                            <td><b>Field type</b></td>
                                            <td><b>Length Minimum</b></td>
                                            <td><b>Length Maximum</b></td>
                                            <td><b>Description</b></td>
                                        </tr>
                                        <tr>
                                            <td>Feature Type</td>
                                            <td><code>data</code></td>
                                            <td>1</td>
                                            <td>1</td>
                                            <td>
                                                Set to <strong>value 2</strong> to denote a <i>Metadata Feature</i>.
                                            </td>
                                        </tr>
                                        <tr>
                                            <td>Data Length</td>
                                            <td><code>data</code></td>
                                            <td>2</td>
                                            <td>2</td>
                                            <td>
                                                Length of the following data field in bytes.
                                            </td>
                                        </tr>
                                        <tr>
                                            <td>Data</td>
                                            <td><code>data</code></td>
                                            <td>1</td>
                                            <td>8192</td>
                                            <td>Binary data.</td>
                                        </tr>
                                    </table>
                                </details>
                                <details>
                                    <summary>Tag Feature</summary>
                                    <blockquote>
                                        Defines an indexation tag to which the output can be indexed by additional node plugins.
                                    </blockquote>
                                    <table>
                                        <tr>
                                            <td><b>Name</b></td>
                                            <td><b>Field type</b></td>
                                            <td><b>Length Minimum</b></td>
                                            <td><b>Length Maximum</b></td>
                                            <td><b>Description</b></td>
                                        </tr>
                                        <tr>
                                            <td>Feature Type</td>
                                            <td><code>data</code></td>
                                            <td>1</td>
                                            <td>1</td>
                                            <td>
                                                Set to <strong>value 3</strong> to denote a <i>Tag Feature</i>.
                                            </td>
                                        </tr>
                                        <tr>
                                            <td>Tag Length</td>
                                            <td><code>data</code></td>
                                            <td>1</td>
                                            <td>1</td>
                                            <td>
                                                Length of the following tag field in bytes.
                                            </td>
                                        </tr>
                                        <tr>
                                            <td>Tag</td>
                                            <td><code>data</code></td>
                                            <td>1</td>
                                            <td>255</td>
                                            <td>Binary indexation data.</td>
                                        </tr>
                                    </table>
                                </details>
                            </td>
                        </tr>
                    </table>
                </td>
            </tr>
            <tr>
                <td>v_byte Minimum</td>
                <td>426</td>
            </tr>
            <tr>
                <td>v_byte Maximum</td>
                <td>13477</td>
            </tr>
        </table>
    </details>
</table>
<p><img src="tips/TIP-0019/assets/deposit_miota_BasicOutput_(min_functionality).jpg" alt="" /></p>
<p><img src="tips/TIP-0019/assets/deposit_miota_BasicOutput_(max_functionality).jpg" alt="" /></p>
<table>
    <details>
        <summary>Alias Output</summary>
        <blockquote>
            Describes an alias account in the ledger that can be controlled by the state and governance controllers.
        </blockquote>
        <table>
            <tr>
                <td>Offset</td>
                <td>
                    <table>
                        <tr>
                            <td><b>Field</b></td>
                            <td><b>Field type</b></td>
                            <td><b>Length Minimum</b></td>
                            <td><b>Length Maximum</b></td>
                            <td><b>Description</b></td>
                        </tr>
                        <tr>
                            <td>OutputID</td>
                            <td><code>key</code></td>
                            <td>34</td>
                            <td>34</td>
                            <td>The ID of the output.</td>
                        </tr>
                        <tr>
                            <td>Block ID (included)</td>
                            <td><code>data</code></td>
                            <td>32</td>
                            <td>32</td>
                            <td>The ID of the block in which the transaction payload that created this output was included.</td>
                        </tr>
                        <tr>
                            <td>Confirmation Milestone Index</td>
                            <td><code>data</code></td>
                            <td>4</td>
                            <td>4</td>
                            <td>The index of the milestone which confirmed the transaction that created the output.</td>
                        </tr>
                        <tr>
                            <td>Confirmation Unix Timestamp</td>
                            <td><code>data</code></td>
                            <td>4</td>
                            <td>4</td>
                            <td>The unix timestamp of the milestone which confirmed the transaction that created the output.</td>
                        </tr>
                    </table>
                </td>
            </tr>
            <tr>
                <td>Fields</td>
                <td>
                    <table>
                        <tr>
                            <td><b>Name</b></td>
                            <td><b>Field type</b></td>
                            <td><b>Length Minimum</b></td>
                            <td><b>Length Maximum</b></td>
                            <td><b>Description</b></td>
                        </tr>
                        <tr>
                            <td>Output Type</td>
                            <td><code>data</code></td>
                            <td>1</td>
                            <td>1</td>
                            <td>
                                Set to <strong>value 4</strong> to denote a <i>Alias Output</i>.
                            </td>
                        </tr>
                        <tr>
                            <td>Amount</td>
                            <td><code>data</code></td>
                            <td>8</td>
                            <td>8</td>
                            <td>The amount of IOTA coins held by the output.</td>
                        </tr>
                        <tr>
                            <td>Native Tokens Count</td>
                            <td><code>data</code></td>
                            <td>1</td>
                            <td>1</td>
                            <td>The number of native tokens held by the output.</td>
                        </tr>
                        <tr>
                            <td valign="top">Native Tokens <code>optAnyOf</code></td>
                            <td colspan="2">
                                <details>
                                    <summary>Native Token</summary>
                                    <table>
                                        <tr>
                                            <td><b>Name</b></td>
                                            <td><b>Field type</b></td>
                                            <td><b>Length Minimum</b></td>
                                            <td><b>Length Maximum</b></td>
                                            <td><b>Description</b></td>
                                        </tr>
                                        <tr>
                                            <td>Token ID</td>
                                            <td><code>data</code></td>
                                            <td>38</td>
                                            <td>38</td>
                                            <td>
                                                Identifier of the native token.
                                            </td>
                                        </tr>
                                        <tr>
                                            <td>Amount</td>
                                            <td><code>data</code></td>
                                            <td>32</td>
                                            <td>32</td>
                                            <td>
                                                Amount of native tokens of the given <i>Token ID</i>.
                                            </td>
                                        </tr>
                                    </table>
                                </details>
                            </td>
                        </tr>
                        <tr>
                            <td>Alias ID</td>
                            <td><code>data</code></td>
                            <td>32</td>
                            <td>32</td>
                            <td>Unique identifier of the alias, which is the BLAKE2b-256 hash of the <i>Output ID</i> that created it.<i> Alias Address = Alias Address Type || Alias ID</i></td>
                        </tr>
                        <tr>
                            <td>State Index</td>
                            <td><code>data</code></td>
                            <td>4</td>
                            <td>4</td>
                            <td>A counter that must increase by 1 every time the alias is state transitioned.</td>
                        </tr>
                        <tr>
                            <td>State Metadata Length</td>
                            <td><code>data</code></td>
                            <td>2</td>
                            <td>2</td>
                            <td>Length of the following State Metadata field.</td>
                        </tr>
                        <tr>
                            <td>State Metadata</td>
                            <td><code>data</code></td>
                            <td>0</td>
                            <td>8192</td>
                            <td>Metadata that can only be changed by the state controller.</td>
                        </tr>
                        <tr>
                            <td>Foundry Counter</td>
                            <td><code>data</code></td>
                            <td>4</td>
                            <td>4</td>
                            <td>A counter that denotes the number of foundries created by this alias account.</td>
                        </tr>
                        <tr>
                            <td>Unlock Conditions Count</td>
                            <td><code>data</code></td>
                            <td>1</td>
                            <td>1</td>
                            <td>The number of unlock conditions following.</td>
                        </tr>
                        <tr>
                            <td valign="top">Unlock Conditions <code>atMostOneOfEach</code></td>
                            <td colspan="2">
                                <details>
                                    <summary>State Controller Address Unlock Condition</summary>
                                    <table>
                                        <tr>
                                            <td><b>Name</b></td>
                                            <td><b>Field type</b></td>
                                            <td><b>Length Minimum</b></td>
                                            <td><b>Length Maximum</b></td>
                                            <td><b>Description</b></td>
                                        </tr>
                                        <tr>
                                            <td>Unlock Condition Type</td>
                                            <td><code>data</code></td>
                                            <td>1</td>
                                            <td>1</td>
                                            <td>
                                                Set to <strong>value 4</strong> to denote an <i>State Controller Address Unlock Condition</i>.
                                            </td>
                                        </tr>
                                        <tr>
                                            <td>Address</td>
                                            <td colspan="2">
                                                <details>
                                                    <summary>Ed25519 Address</summary>
                                                    <table>
                                                        <tr>
                                                            <td><b>Name</b></td>
                                                            <td><b>Field type</b></td>
                                                            <td><b>Length Minimum</b></td>
                                                            <td><b>Length Maximum</b></td>
                                                            <td><b>Description</b></td>
                                                        </tr>
                                                        <tr>
                                                            <td>Address Type</td>
                                                            <td><code>data</code></td>
                                                            <td>1</td>
                                                            <td>1</td>
                                                            <td>
                                                                Set to <strong>value 0</strong> to denote an <i>Ed25519 Address</i>.
                                                            </td>
                                                        </tr>
                                                        <tr>
                                                            <td>PubKeyHash</td>
                                                            <td><code>data</code></td>
                                                            <td>32</td>
                                                            <td>32</td>
                                                            <td>The raw bytes of the Ed25519 address which is a BLAKE2b-256 hash of the Ed25519 public key.</td>
                                                        </tr>
                                                    </table>
                                                </details>
                                                <details>
                                                    <summary>Alias Address</summary>
                                                    <table>
                                                        <tr>
                                                            <td><b>Name</b></td>
                                                            <td><b>Field type</b></td>
                                                            <td><b>Length Minimum</b></td>
                                                            <td><b>Length Maximum</b></td>
                                                            <td><b>Description</b></td>
                                                        </tr>
                                                        <tr>
                                                            <td>Address Type</td>
                                                            <td><code>data</code></td>
                                                            <td>1</td>
                                                            <td>1</td>
                                                            <td>
                                                                Set to <strong>value 8</strong> to denote an <i>Alias Address</i>.
                                                            </td>
                                                        </tr>
                                                        <tr>
                                                            <td>Alias ID</td>
                                                            <td><code>data</code></td>
                                                            <td>32</td>
                                                            <td>32</td>
                                                            <td>The raw bytes of the <i>Alias ID</i> which is the BLAKE2b-256 hash of the outputID that created it.</td>
                                                        </tr>
                                                    </table>
                                                </details>
                                                <details>
                                                    <summary>NFT Address</summary>
                                                    <table>
                                                        <tr>
                                                            <td><b>Name</b></td>
                                                            <td><b>Field type</b></td>
                                                            <td><b>Length Minimum</b></td>
                                                            <td><b>Length Maximum</b></td>
                                                            <td><b>Description</b></td>
                                                        </tr>
                                                        <tr>
                                                            <td>Address Type</td>
                                                            <td><code>data</code></td>
                                                            <td>1</td>
                                                            <td>1</td>
                                                            <td>
                                                                Set to <strong>value 16</strong> to denote an <i>NFT Address</i>.
                                                            </td>
                                                        </tr>
                                                        <tr>
                                                            <td>NFT ID</td>
                                                            <td><code>data</code></td>
                                                            <td>32</td>
                                                            <td>32</td>
                                                            <td>The raw bytes of the <i>NFT ID</i> which is the BLAKE2b-256 hash of the outputID that created it.</td>
                                                        </tr>
                                                    </table>
                                                </details>
                                            </td>
                                        </tr>
                                    </table>
                                </details>
                                <details>
                                    <summary>Governor Address Unlock Condition</summary>
                                    <table>
                                        <tr>
                                            <td><b>Name</b></td>
                                            <td><b>Field type</b></td>
                                            <td><b>Length Minimum</b></td>
                                            <td><b>Length Maximum</b></td>
                                            <td><b>Description</b></td>
                                        </tr>
                                        <tr>
                                            <td>Unlock Condition Type</td>
                                            <td><code>data</code></td>
                                            <td>1</td>
                                            <td>1</td>
                                            <td>
                                                Set to <strong>value 5</strong> to denote an <i>Governor Address Unlock Condition</i>.
                                            </td>
                                        </tr>
                                        <tr>
                                            <td>Address</td>
                                            <td colspan="2">
                                                <details>
                                                    <summary>Ed25519 Address</summary>
                                                    <table>
                                                        <tr>
                                                            <td><b>Name</b></td>
                                                            <td><b>Field type</b></td>
                                                            <td><b>Length Minimum</b></td>
                                                            <td><b>Length Maximum</b></td>
                                                            <td><b>Description</b></td>
                                                        </tr>
                                                        <tr>
                                                            <td>Address Type</td>
                                                            <td><code>data</code></td>
                                                            <td>1</td>
                                                            <td>1</td>
                                                            <td>
                                                                Set to <strong>value 0</strong> to denote an <i>Ed25519 Address</i>.
                                                            </td>
                                                        </tr>
                                                        <tr>
                                                            <td>PubKeyHash</td>
                                                            <td><code>data</code></td>
                                                            <td>32</td>
                                                            <td>32</td>
                                                            <td>The raw bytes of the Ed25519 address which is a BLAKE2b-256 hash of the Ed25519 public key.</td>
                                                        </tr>
                                                    </table>
                                                </details>
                                                <details>
                                                    <summary>Alias Address</summary>
                                                    <table>
                                                        <tr>
                                                            <td><b>Name</b></td>
                                                            <td><b>Field type</b></td>
                                                            <td><b>Length Minimum</b></td>
                                                            <td><b>Length Maximum</b></td>
                                                            <td><b>Description</b></td>
                                                        </tr>
                                                        <tr>
                                                            <td>Address Type</td>
                                                            <td><code>data</code></td>
                                                            <td>1</td>
                                                            <td>1</td>
                                                            <td>
                                                                Set to <strong>value 8</strong> to denote an <i>Alias Address</i>.
                                                            </td>
                                                        </tr>
                                                        <tr>
                                                            <td>Alias ID</td>
                                                            <td><code>data</code></td>
                                                            <td>32</td>
                                                            <td>32</td>
                                                            <td>The raw bytes of the <i>Alias ID</i> which is the BLAKE2b-256 hash of the outputID that created it.</td>
                                                        </tr>
                                                    </table>
                                                </details>
                                                <details>
                                                    <summary>NFT Address</summary>
                                                    <table>
                                                        <tr>
                                                            <td><b>Name</b></td>
                                                            <td><b>Field type</b></td>
                                                            <td><b>Length Minimum</b></td>
                                                            <td><b>Length Maximum</b></td>
                                                            <td><b>Description</b></td>
                                                        </tr>
                                                        <tr>
                                                            <td>Address Type</td>
                                                            <td><code>data</code></td>
                                                            <td>1</td>
                                                            <td>1</td>
                                                            <td>
                                                                Set to <strong>value 16</strong> to denote an <i>NFT Address</i>.
                                                            </td>
                                                        </tr>
                                                        <tr>
                                                            <td>NFT ID</td>
                                                            <td><code>data</code></td>
                                                            <td>32</td>
                                                            <td>32</td>
                                                            <td>The raw bytes of the <i>NFT ID</i> which is the BLAKE2b-256 hash of the outputID that created it.</td>
                                                        </tr>
                                                    </table>
                                                </details>
                                            </td>
                                        </tr>
                                    </table>
                                </details>
                            </td>
                        </tr>
                        <tr>
                            <td>Features Count</td>
                            <td><code>data</code></td>
                            <td>1</td>
                            <td>1</td>
                            <td>The number of features following.</td>
                        </tr>
                        <tr>
                            <td valign="top">Features <code>atMostOneOfEach</code></td>
                            <td colspan="2">
                                <details>
                                    <summary>Sender Feature</summary>
                                    <blockquote>
                                        Identifies the validated sender of the output.
                                    </blockquote>
                                    <table>
                                        <tr>
                                            <td><b>Name</b></td>
                                            <td><b>Field type</b></td>
                                            <td><b>Length Minimum</b></td>
                                            <td><b>Length Maximum</b></td>
                                            <td><b>Description</b></td>
                                        </tr>
                                        <tr>
                                            <td>Feature Type</td>
                                            <td><code>data</code></td>
                                            <td>1</td>
                                            <td>1</td>
                                            <td>
                                                Set to <strong>value 0</strong> to denote a <i>Sender Feature</i>.
                                            </td>
                                        </tr>
                                        <tr>
                                            <td valign="top">Sender <code>oneOf</code></td>
                                            <td colspan="2">
                                                <details>
                                                    <summary>Ed25519 Address</summary>
                                                    <table>
                                                        <tr>
                                                            <td><b>Name</b></td>
                                                            <td><b>Field type</b></td>
                                                            <td><b>Length Minimum</b></td>
                                                            <td><b>Length Maximum</b></td>
                                                            <td><b>Description</b></td>
                                                        </tr>
                                                        <tr>
                                                            <td>Address Type</td>
                                                            <td><code>data</code></td>
                                                            <td>1</td>
                                                            <td>1</td>
                                                            <td>
                                                                Set to <strong>value 0</strong> to denote an <i>Ed25519 Address</i>.
                                                            </td>
                                                        </tr>
                                                        <tr>
                                                            <td>PubKeyHash</td>
                                                            <td><code>data</code></td>
                                                            <td>32</td>
                                                            <td>32</td>
                                                            <td>The raw bytes of the Ed25519 address which is a BLAKE2b-256 hash of the Ed25519 public key.</td>
                                                        </tr>
                                                    </table>
                                                </details>
                                                <details>
                                                    <summary>Alias Address</summary>
                                                    <table>
                                                        <tr>
                                                            <td><b>Name</b></td>
                                                            <td><b>Field type</b></td>
                                                            <td><b>Length Minimum</b></td>
                                                            <td><b>Length Maximum</b></td>
                                                            <td><b>Description</b></td>
                                                        </tr>
                                                        <tr>
                                                            <td>Address Type</td>
                                                            <td><code>data</code></td>
                                                            <td>1</td>
                                                            <td>1</td>
                                                            <td>
                                                                Set to <strong>value 8</strong> to denote an <i>Alias Address</i>.
                                                            </td>
                                                        </tr>
                                                        <tr>
                                                            <td>Alias ID</td>
                                                            <td><code>data</code></td>
                                                            <td>32</td>
                                                            <td>32</td>
                                                            <td>The raw bytes of the <i>Alias ID</i> which is the BLAKE2b-256 hash of the outputID that created it.</td>
                                                        </tr>
                                                    </table>
                                                </details>
                                                <details>
                                                    <summary>NFT Address</summary>
                                                    <table>
                                                        <tr>
                                                            <td><b>Name</b></td>
                                                            <td><b>Field type</b></td>
                                                            <td><b>Length Minimum</b></td>
                                                            <td><b>Length Maximum</b></td>
                                                            <td><b>Description</b></td>
                                                        </tr>
                                                        <tr>
                                                            <td>Address Type</td>
                                                            <td><code>data</code></td>
                                                            <td>1</td>
                                                            <td>1</td>
                                                            <td>
                                                                Set to <strong>value 16</strong> to denote an <i>NFT Address</i>.
                                                            </td>
                                                        </tr>
                                                        <tr>
                                                            <td>NFT ID</td>
                                                            <td><code>data</code></td>
                                                            <td>32</td>
                                                            <td>32</td>
                                                            <td>The raw bytes of the <i>NFT ID</i> which is the BLAKE2b-256 hash of the outputID that created it.</td>
                                                        </tr>
                                                    </table>
                                                </details>
                                            </td>
                                        </tr>
                                    </table>
                                </details>
                                <details>
                                    <summary>Metadata Feature</summary>
                                    <blockquote>
                                        Defines metadata (arbitrary binary data) that will be stored in the output.
                                    </blockquote>
                                    <table>
                                        <tr>
                                            <td><b>Name</b></td>
                                            <td><b>Field type</b></td>
                                            <td><b>Length Minimum</b></td>
                                            <td><b>Length Maximum</b></td>
                                            <td><b>Description</b></td>
                                        </tr>
                                        <tr>
                                            <td>Feature Type</td>
                                            <td><code>data</code></td>
                                            <td>1</td>
                                            <td>1</td>
                                            <td>
                                                Set to <strong>value 2</strong> to denote a <i>Metadata Feature</i>.
                                            </td>
                                        </tr>
                                        <tr>
                                            <td>Data Length</td>
                                            <td><code>data</code></td>
                                            <td>2</td>
                                            <td>2</td>
                                            <td>
                                                Length of the following data field in bytes.
                                            </td>
                                        </tr>
                                        <tr>
                                            <td>Data</td>
                                            <td><code>data</code></td>
                                            <td>1</td>
                                            <td>8192</td>
                                            <td>Binary data.</td>
                                        </tr>
                                    </table>
                                </details>
                            </td>
                        </tr>
                        <tr>
                            <td>Immutable Features Count</td>
                            <td><code>data</code></td>
                            <td>1</td>
                            <td>1</td>
                            <td>The number of immutable features following. Immutable features are defined upon deployment of the UTXO state machine and are not allowed to change in any future state transition.</td>
                        </tr>
                        <tr>
                            <td valign="top">Immutable Features <code>atMostOneOfEach</code></td>
                            <td colspan="2">
                                <details>
                                    <summary>Issuer Feature</summary>
                                    <blockquote>
                                        Identifies the validated issuer of the UTXO state machine.
                                    </blockquote>
                                    <table>
                                        <tr>
                                            <td><b>Name</b></td>
                                            <td><b>Field type</b></td>
                                            <td><b>Length Minimum</b></td>
                                            <td><b>Length Maximum</b></td>
                                            <td><b>Description</b></td>
                                        </tr>
                                        <tr>
                                            <td>Feature Type</td>
                                            <td><code>data</code></td>
                                            <td>1</td>
                                            <td>1</td>
                                            <td>
                                                Set to <strong>value 1</strong> to denote an <i>Issuer Feature</i>.
                                            </td>
                                        </tr>
                                        <tr>
                                            <td valign="top">Issuer <code>oneOf</code></td>
                                            <td colspan="2">
                                                <details>
                                                    <summary>Ed25519 Address</summary>
                                                    <table>
                                                        <tr>
                                                            <td><b>Name</b></td>
                                                            <td><b>Field type</b></td>
                                                            <td><b>Length Minimum</b></td>
                                                            <td><b>Length Maximum</b></td>
                                                            <td><b>Description</b></td>
                                                        </tr>
                                                        <tr>
                                                            <td>Address Type</td>
                                                            <td><code>data</code></td>
                                                            <td>1</td>
                                                            <td>1</td>
                                                            <td>
                                                                Set to <strong>value 0</strong> to denote an <i>Ed25519 Address</i>.
                                                            </td>
                                                        </tr>
                                                        <tr>
                                                            <td>PubKeyHash</td>
                                                            <td><code>data</code></td>
                                                            <td>32</td>
                                                            <td>32</td>
                                                            <td>The raw bytes of the Ed25519 address which is a BLAKE2b-256 hash of the Ed25519 public key.</td>
                                                        </tr>
                                                    </table>
                                                </details>
                                                <details>
                                                    <summary>Alias Address</summary>
                                                    <table>
                                                        <tr>
                                                            <td><b>Name</b></td>
                                                            <td><b>Field type</b></td>
                                                            <td><b>Length Minimum</b></td>
                                                            <td><b>Length Maximum</b></td>
                                                            <td><b>Description</b></td>
                                                        </tr>
                                                        <tr>
                                                            <td>Address Type</td>
                                                            <td><code>data</code></td>
                                                            <td>1</td>
                                                            <td>1</td>
                                                            <td>
                                                                Set to <strong>value 8</strong> to denote an <i>Alias Address</i>.
                                                            </td>
                                                        </tr>
                                                        <tr>
                                                            <td>Alias ID</td>
                                                            <td><code>data</code></td>
                                                            <td>32</td>
                                                            <td>32</td>
                                                            <td>The raw bytes of the <i>Alias ID</i> which is the BLAKE2b-256 hash of the outputID that created it.</td>
                                                        </tr>
                                                    </table>
                                                </details>
                                                <details>
                                                    <summary>NFT Address</summary>
                                                    <table>
                                                        <tr>
                                                            <td><b>Name</b></td>
                                                            <td><b>Field type</b></td>
                                                            <td><b>Length Minimum</b></td>
                                                            <td><b>Length Maximum</b></td>
                                                            <td><b>Description</b></td>
                                                        </tr>
                                                        <tr>
                                                            <td>Address Type</td>
                                                            <td><code>data</code></td>
                                                            <td>1</td>
                                                            <td>1</td>
                                                            <td>
                                                                Set to <strong>value 16</strong> to denote an <i>NFT Address</i>.
                                                            </td>
                                                        </tr>
                                                        <tr>
                                                            <td>NFT ID</td>
                                                            <td><code>data</code></td>
                                                            <td>32</td>
                                                            <td>32</td>
                                                            <td>The raw bytes of the <i>NFT ID</i> which is the BLAKE2b-256 hash of the outputID that created it.</td>
                                                        </tr>
                                                    </table>
                                                </details>
                                            </td>
                                        </tr>
                                    </table>
                                </details>
                                <details>
                                    <summary>Metadata Feature</summary>
                                    <blockquote>
                                        Defines metadata (arbitrary binary data) that will be stored in the output.
                                    </blockquote>
                                    <table>
                                        <tr>
                                            <td><b>Name</b></td>
                                            <td><b>Field type</b></td>
                                            <td><b>Length Minimum</b></td>
                                            <td><b>Length Maximum</b></td>
                                            <td><b>Description</b></td>
                                        </tr>
                                        <tr>
                                            <td>Feature Type</td>
                                            <td><code>data</code></td>
                                            <td>1</td>
                                            <td>1</td>
                                            <td>
                                                Set to <strong>value 2</strong> to denote a <i>Metadata Feature</i>.
                                            </td>
                                        </tr>
                                        <tr>
                                            <td>Data Length</td>
                                            <td><code>data</code></td>
                                            <td>2</td>
                                            <td>2</td>
                                            <td>
                                                Length of the following data field in bytes.
                                            </td>
                                        </tr>
                                        <tr>
                                            <td>Data</td>
                                            <td><code>data</code></td>
                                            <td>1</td>
                                            <td>8192</td>
                                            <td>Binary data.</td>
                                        </tr>
                                    </table>
                                </details>
                            </td>
                        </tr>
                    </table>
                </td>
            </tr>
            <tr>
                <td>v_byte Minimum</td>
                <td>469</td>
            </tr>
            <tr>
                <td>v_byte Maximum</td>
                <td>29633</td>
            </tr>
        </table>
    </details>
</table>
<p><img src="tips/TIP-0019/assets/deposit_miota_AliasOutput_(min_functionality).jpg" alt="" /></p>
<p><img src="tips/TIP-0019/assets/deposit_miota_AliasOutput_(max_functionality).jpg" alt="" /></p>
<table>
    <details>
        <summary>Foundry Output</summary>
        <blockquote>
            Describes a foundry output that is controlled by an alias.
        </blockquote>
        <table>
            <tr>
                <td>Offset</td>
                <td>
                    <table>
                        <tr>
                            <td><b>Field</b></td>
                            <td><b>Field type</b></td>
                            <td><b>Length Minimum</b></td>
                            <td><b>Length Maximum</b></td>
                            <td><b>Description</b></td>
                        </tr>
                        <tr>
                            <td>OutputID</td>
                            <td><code>key</code></td>
                            <td>34</td>
                            <td>34</td>
                            <td>The ID of the output.</td>
                        </tr>
                        <tr>
                            <td>Block ID (included)</td>
                            <td><code>data</code></td>
                            <td>32</td>
                            <td>32</td>
                            <td>The ID of the block in which the transaction payload that created this output was included.</td>
                        </tr>
                        <tr>
                            <td>Confirmation Milestone Index</td>
                            <td><code>data</code></td>
                            <td>4</td>
                            <td>4</td>
                            <td>The index of the milestone which confirmed the transaction that created the output.</td>
                        </tr>
                        <tr>
                            <td>Confirmation Unix Timestamp</td>
                            <td><code>data</code></td>
                            <td>4</td>
                            <td>4</td>
                            <td>The unix timestamp of the milestone which confirmed the transaction that created the output.</td>
                        </tr>
                    </table>
                </td>
            </tr>
            <tr>
                <td>Fields</td>
                <td>
                    <table>
                        <tr>
                            <td><b>Name</b></td>
                            <td><b>Field type</b></td>
                            <td><b>Length Minimum</b></td>
                            <td><b>Length Maximum</b></td>
                            <td><b>Description</b></td>
                        </tr>
                        <tr>
                            <td>Output Type</td>
                            <td><code>data</code></td>
                            <td>1</td>
                            <td>1</td>
                            <td>
                                Set to <strong>value 5</strong> to denote a <i>Foundry Output</i>.
                            </td>
                        </tr>
                        <tr>
                            <td>Amount</td>
                            <td><code>data</code></td>
                            <td>8</td>
                            <td>8</td>
                            <td>The amount of IOTA coins held by the output.</td>
                        </tr>
                        <tr>
                            <td>Native Tokens Count</td>
                            <td><code>data</code></td>
                            <td>1</td>
                            <td>1</td>
                            <td>The number of different native tokens held by the output.</td>
                        </tr>
                        <tr>
                            <td valign="top">Native Tokens <code>optAnyOf</code></td>
                            <td colspan="2">
                                <details>
                                    <summary>Native Token</summary>
                                    <table>
                                        <tr>
                                            <td><b>Name</b></td>
                                            <td><b>Field type</b></td>
                                            <td><b>Length Minimum</b></td>
                                            <td><b>Length Maximum</b></td>
                                            <td><b>Description</b></td>
                                        </tr>
                                        <tr>
                                            <td>Token ID</td>
                                            <td><code>data</code></td>
                                            <td>38</td>
                                            <td>38</td>
                                            <td>
                                                Identifier of the native token.
                                            </td>
                                        </tr>
                                        <tr>
                                            <td>Amount</td>
                                            <td><code>data</code></td>
                                            <td>32</td>
                                            <td>32</td>
                                            <td>
                                                Amount of native tokens of the given <i>Token ID</i>.
                                            </td>
                                        </tr>
                                    </table>
                                </details>
                            </td>
                        </tr>
                        <tr>
                            <td>Serial Number</td>
                            <td><code>data</code></td>
                            <td>4</td>
                            <td>4</td>
                            <td>The serial number of the foundry with respect to the controlling alias.</td>
                        </tr>
                        <tr>
                            <td valign="top">Token Scheme <code>oneOf</code></td>
                            <td colspan="2">
                                <details>
                                    <summary>Simple Token Scheme</summary>
                                    <table>
                                        <tr>
                                            <td><b>Name</b></td>
                                            <td><b>Field type</b></td>
                                            <td><b>Length Minimum</b></td>
                                            <td><b>Length Maximum</b></td>
                                            <td><b>Description</b></td>
                                        </tr>
                                        <tr>
                                            <td>Token Scheme Type</td>
                                            <td><code>data</code></td>
                                            <td>1</td>
                                            <td>1</td>
                                            <td>
                                                Set to <strong>value 0</strong> to denote an <i>Simple Token Scheme</i>.
                                            </td>
                                        </tr>
                                        <tr>
                                            <td>Minted Tokens</td>
                                            <td><code>data</code></td>
                                            <td>32</td>
                                            <td>32</td>
                                            <td>Amount of tokens minted by this foundry.</td>
                                        </tr>
                                        <tr>
                                            <td>Melted Tokens</td>
                                            <td><code>data</code></td>
                                            <td>32</td>
                                            <td>32</td>
                                            <td>Amount of tokens melted by this foundry.</td>
                                        </tr>
                                        <tr>
                                            <td>Maximum Supply</td>
                                            <td><code>data</code></td>
                                            <td>32</td>
                                            <td>32</td>
                                            <td>Maximum supply of tokens controlled by this foundry.</td>
                                        </tr>
                                    </table>
                                </details>
                            </td>
                        </tr>
                        <tr>
                            <td>Unlock Conditions Count</td>
                            <td><code>data</code></td>
                            <td>1</td>
                            <td>1</td>
                            <td>The number of unlock conditions following.</td>
                        </tr>
                        <tr>
                            <td valign="top">Unlock Conditions <code>atMostOneOfEach</code></td>
                            <td colspan="2">
                                <details>
                                    <summary>Immutable Alias Address Unlock Condition</summary>
                                    <table>
                                        <tr>
                                            <td><b>Name</b></td>
                                            <td><b>Field type</b></td>
                                            <td><b>Length Minimum</b></td>
                                            <td><b>Length Maximum</b></td>
                                            <td><b>Description</b></td>
                                        </tr>
                                        <tr>
                                            <td>Unlock Condition Type</td>
                                            <td><code>data</code></td>
                                            <td>1</td>
                                            <td>1</td>
                                            <td>
                                                Set to <strong>value 6</strong> to denote an <i>Immutable Alias Address Unlock Condition</i>.
                                            </td>
                                        </tr>
                                        <tr>
                                            <td>Address</td>
                                            <td colspan="2">
                                                <details>
                                                    <summary>Alias Address</summary>
                                                    <table>
                                                        <tr>
                                                            <td><b>Name</b></td>
                                                            <td><b>Field type</b></td>
                                                            <td><b>Length Minimum</b></td>
                                                            <td><b>Length Maximum</b></td>
                                                            <td><b>Description</b></td>
                                                        </tr>
                                                        <tr>
                                                            <td>Address Type</td>
                                                            <td><code>data</code></td>
                                                            <td>1</td>
                                                            <td>1</td>
                                                            <td>
                                                                Set to <strong>value 8</strong> to denote an <i>Alias Address</i>.
                                                            </td>
                                                        </tr>
                                                        <tr>
                                                            <td>Alias ID</td>
                                                            <td><code>data</code></td>
                                                            <td>32</td>
                                                            <td>32</td>
                                                            <td>The raw bytes of the <i>Alias ID</i> which is the BLAKE2b-256 hash of the outputID that created it.</td>
                                                        </tr>
                                                    </table>
                                                </details>
                                            </td>
                                        </tr>
                                    </table>
                                </details>
                            </td>
                        </tr>
                        <tr>
                            <td>Features Count</td>
                            <td><code>data</code></td>
                            <td>1</td>
                            <td>1</td>
                            <td>The number of features following.</td>
                        </tr>
                        <tr>
                            <td valign="top">Features <code>atMostOneOfEach</code></td>
                            <td colspan="2">
                                <details>
                                    <summary>Metadata Feature</summary>
                                    <blockquote>
                                        Defines metadata (arbitrary binary data) that will be stored in the output.
                                    </blockquote>
                                    <table>
                                        <tr>
                                            <td><b>Name</b></td>
                                            <td><b>Field type</b></td>
                                            <td><b>Length Minimum</b></td>
                                            <td><b>Length Maximum</b></td>
                                            <td><b>Description</b></td>
                                        </tr>
                                        <tr>
                                            <td>Feature Type</td>
                                            <td><code>data</code></td>
                                            <td>1</td>
                                            <td>1</td>
                                            <td>
                                                Set to <strong>value 2</strong> to denote a <i>Metadata Feature</i>.
                                            </td>
                                        </tr>
                                        <tr>
                                            <td>Data Length</td>
                                            <td><code>data</code></td>
                                            <td>2</td>
                                            <td>2</td>
                                            <td>
                                                Length of the following data field in bytes.
                                            </td>
                                        </tr>
                                        <tr>
                                            <td>Data</td>
                                            <td><code>data</code></td>
                                            <td>1</td>
                                            <td>8192</td>
                                            <td>Binary data.</td>
                                        </tr>
                                    </table>
                                </details>
                            </td>
                        </tr>
                        <tr>
                            <td>Immutable Features Count</td>
                            <td><code>data</code></td>
                            <td>1</td>
                            <td>1</td>
                            <td>The number of immutable features following. Immutable features are defined upon deployment of the UTXO state machine and are not allowed to change in any future state transition.</td>
                        </tr>
                        <tr>
                            <td valign="top">Immutable Features <code>atMostOneOfEach</code></td>
                            <td colspan="2">
                                <details>
                                    <summary>Metadata Feature</summary>
                                    <blockquote>
                                        Defines metadata (arbitrary binary data) that will be stored in the output.
                                    </blockquote>
                                    <table>
                                        <tr>
                                            <td><b>Name</b></td>
                                            <td><b>Field type</b></td>
                                            <td><b>Length Minimum</b></td>
                                            <td><b>Length Maximum</b></td>
                                            <td><b>Description</b></td>
                                        </tr>
                                        <tr>
                                            <td>Feature Type</td>
                                            <td><code>data</code></td>
                                            <td>1</td>
                                            <td>1</td>
                                            <td>
                                                Set to <strong>value 2</strong> to denote a <i>Metadata Feature</i>.
                                            </td>
                                        </tr>
                                        <tr>
                                            <td>Data Length</td>
                                            <td><code>data</code></td>
                                            <td>2</td>
                                            <td>2</td>
                                            <td>
                                                Length of the following data field in bytes.
                                            </td>
                                        </tr>
                                        <tr>
                                            <td>Data</td>
                                            <td><code>data</code></td>
                                            <td>1</td>
                                            <td>8192</td>
                                            <td>Binary data.</td>
                                        </tr>
                                    </table>
                                </details>
                            </td>
                        </tr>
                    </table>
                </td>
            </tr>
            <tr>
                <td>v_byte Minimum</td>
                <td>528</td>
            </tr>
            <tr>
                <td>v_byte Maximum</td>
                <td>21398</td>
            </tr>
        </table>
    </details>
</table>
<p><img src="tips/TIP-0019/assets/deposit_miota_FoundryOutput_(min_functionality).jpg" alt="" /></p>
<p><img src="tips/TIP-0019/assets/deposit_miota_FoundryOutput_(max_functionality).jpg" alt="" /></p>
<table>
    <details>
        <summary>NFT Output</summary>
        <blockquote>
            Describes an NFT output, a globally unique token with metadata attached.
        </blockquote>
        <table>
            <tr>
                <td>Offset</td>
                <td>
                    <table>
                        <tr>
                            <td><b>Field</b></td>
                            <td><b>Field type</b></td>
                            <td><b>Length Minimum</b></td>
                            <td><b>Length Maximum</b></td>
                            <td><b>Description</b></td>
                        </tr>
                        <tr>
                            <td>OutputID</td>
                            <td><code>key</code></td>
                            <td>34</td>
                            <td>34</td>
                            <td>The ID of the output.</td>
                        </tr>
                        <tr>
                            <td>Block ID (included)</td>
                            <td><code>data</code></td>
                            <td>32</td>
                            <td>32</td>
                            <td>The ID of the block in which the transaction payload that created this output was included.</td>
                        </tr>
                        <tr>
                            <td>Confirmation Milestone Index</td>
                            <td><code>data</code></td>
                            <td>4</td>
                            <td>4</td>
                            <td>The index of the milestone which confirmed the transaction that created the output.</td>
                        </tr>
                        <tr>
                            <td>Confirmation Unix Timestamp</td>
                            <td><code>data</code></td>
                            <td>4</td>
                            <td>4</td>
                            <td>The unix timestamp of the milestone which confirmed the transaction that created the output.</td>
                        </tr>
                    </table>
                </td>
            </tr>
            <tr>
                <td>Fields</td>
                <td>
                    <table>
                        <tr>
                            <td><b>Name</b></td>
                            <td><b>Field type</b></td>
                            <td><b>Length Minimum</b></td>
                            <td><b>Length Maximum</b></td>
                            <td><b>Description</b></td>
                        </tr>
                        <tr>
                            <td>Output Type</td>
                            <td><code>data</code></td>
                            <td>1</td>
                            <td>1</td>
                            <td>
                                Set to <strong>value 6</strong> to denote a <i>NFT Output</i>.
                            </td>
                        </tr>
                        <tr>
                            <td>Amount</td>
                            <td><code>data</code></td>
                            <td>8</td>
                            <td>8</td>
                            <td>The amount of IOTA coins held by the output.</td>
                        </tr>
                        <tr>
                            <td>Native Tokens Count</td>
                            <td><code>data</code></td>
                            <td>1</td>
                            <td>1</td>
                            <td>The number of native tokens held by the output.</td>
                        </tr>
                        <tr>
                            <td valign="top">Native Tokens <code>optAnyOf</code></td>
                            <td colspan="2">
                                <details>
                                    <summary>Native Token</summary>
                                    <table>
                                        <tr>
                                            <td><b>Name</b></td>
                                            <td><b>Field type</b></td>
                                            <td><b>Length Minimum</b></td>
                                            <td><b>Length Maximum</b></td>
                                            <td><b>Description</b></td>
                                        </tr>
                                        <tr>
                                            <td>Token ID</td>
                                            <td><code>data</code></td>
                                            <td>38</td>
                                            <td>38</td>
                                            <td>
                                                Identifier of the native token.
                                            </td>
                                        </tr>
                                        <tr>
                                            <td>Amount</td>
                                            <td><code>data</code></td>
                                            <td>32</td>
                                            <td>32</td>
                                            <td>
                                                Amount of native tokens of the given <i>Token ID</i>.
                                            </td>
                                        </tr>
                                    </table>
                                </details>
                            </td>
                        </tr>
                        <tr>
                            <td>NFT ID</td>
                            <td><code>data</code></td>
                            <td>32</td>
                            <td>32</td>
                            <td>Unique identifier of the NFT, which is the BLAKE2b-256 hash of the <i>Output ID</i> that created it.<i> NFT Address = NFT Address Type || NFT ID</i></td>
                        </tr>
                        <tr>
                            <td>Unlock Conditions Count</td>
                            <td><code>data</code></td>
                            <td>1</td>
                            <td>1</td>
                            <td>The number of unlock conditions following.</td>
                        </tr>
                        <tr>
                            <td valign="top">Unlock Conditions <code>atMostOneOfEach</code></td>
                            <td colspan="2">
                                <details>
                                    <summary>Address Unlock Condition</summary>
                                    <table>
                                        <tr>
                                            <td><b>Name</b></td>
                                            <td><b>Field type</b></td>
                                            <td><b>Length Minimum</b></td>
                                            <td><b>Length Maximum</b></td>
                                            <td><b>Description</b></td>
                                        </tr>
                                        <tr>
                                            <td>Unlock Condition Type</td>
                                            <td><code>data</code></td>
                                            <td>1</td>
                                            <td>1</td>
                                            <td>
                                                Set to <strong>value 0</strong> to denote an <i>Address Unlock Condition</i>.
                                            </td>
                                        </tr>
                                        <tr>
                                            <td>Address</td>
                                            <td colspan="2">
                                                <details>
                                                    <summary>Ed25519 Address</summary>
                                                    <table>
                                                        <tr>
                                                            <td><b>Name</b></td>
                                                            <td><b>Field type</b></td>
                                                            <td><b>Length Minimum</b></td>
                                                            <td><b>Length Maximum</b></td>
                                                            <td><b>Description</b></td>
                                                        </tr>
                                                        <tr>
                                                            <td>Address Type</td>
                                                            <td><code>data</code></td>
                                                            <td>1</td>
                                                            <td>1</td>
                                                            <td>
                                                                Set to <strong>value 0</strong> to denote an <i>Ed25519 Address</i>.
                                                            </td>
                                                        </tr>
                                                        <tr>
                                                            <td>PubKeyHash</td>
                                                            <td><code>data</code></td>
                                                            <td>32</td>
                                                            <td>32</td>
                                                            <td>The raw bytes of the Ed25519 address which is a BLAKE2b-256 hash of the Ed25519 public key.</td>
                                                        </tr>
                                                    </table>
                                                </details>
                                                <details>
                                                    <summary>Alias Address</summary>
                                                    <table>
                                                        <tr>
                                                            <td><b>Name</b></td>
                                                            <td><b>Field type</b></td>
                                                            <td><b>Length Minimum</b></td>
                                                            <td><b>Length Maximum</b></td>
                                                            <td><b>Description</b></td>
                                                        </tr>
                                                        <tr>
                                                            <td>Address Type</td>
                                                            <td><code>data</code></td>
                                                            <td>1</td>
                                                            <td>1</td>
                                                            <td>
                                                                Set to <strong>value 8</strong> to denote an <i>Alias Address</i>.
                                                            </td>
                                                        </tr>
                                                        <tr>
                                                            <td>Alias ID</td>
                                                            <td><code>data</code></td>
                                                            <td>32</td>
                                                            <td>32</td>
                                                            <td>The raw bytes of the <i>Alias ID</i> which is the BLAKE2b-256 hash of the outputID that created it.</td>
                                                        </tr>
                                                    </table>
                                                </details>
                                                <details>
                                                    <summary>NFT Address</summary>
                                                    <table>
                                                        <tr>
                                                            <td><b>Name</b></td>
                                                            <td><b>Field type</b></td>
                                                            <td><b>Length Minimum</b></td>
                                                            <td><b>Length Maximum</b></td>
                                                            <td><b>Description</b></td>
                                                        </tr>
                                                        <tr>
                                                            <td>Address Type</td>
                                                            <td><code>data</code></td>
                                                            <td>1</td>
                                                            <td>1</td>
                                                            <td>
                                                                Set to <strong>value 16</strong> to denote an <i>NFT Address</i>.
                                                            </td>
                                                        </tr>
                                                        <tr>
                                                            <td>NFT ID</td>
                                                            <td><code>data</code></td>
                                                            <td>32</td>
                                                            <td>32</td>
                                                            <td>The raw bytes of the <i>NFT ID</i> which is the BLAKE2b-256 hash of the outputID that created it.</td>
                                                        </tr>
                                                    </table>
                                                </details>
                                            </td>
                                        </tr>
                                    </table>
                                </details>
                                <details>
                                    <summary>Storage Deposit Return Unlock Condition</summary>
                                    <blockquote>
                                        Defines the amount of IOTAs used as storage deposit that have to be returned to <i>Return Address</i>.
                                    </blockquote>
                                    <table>
                                        <tr>
                                            <td><b>Name</b></td>
                                            <td><b>Field type</b></td>
                                            <td><b>Length Minimum</b></td>
                                            <td><b>Length Maximum</b></td>
                                            <td><b>Description</b></td>
                                        </tr>
                                        <tr>
                                            <td>Unlock Condition Type</td>
                                            <td><code>data</code></td>
                                            <td>1</td>
                                            <td>1</td>
                                            <td>
                                                Set to <strong>value 1</strong> to denote a <i>Storage Deposit Return Unlock Condition</i>.
                                            </td>
                                        </tr>
                                        <tr>
                                            <td valign="top">Return Address <code>oneOf</code></td>
                                            <td colspan="2">
                                                <details>
                                                    <summary>Ed25519 Address</summary>
                                                    <table>
                                                        <tr>
                                                            <td><b>Name</b></td>
                                                            <td><b>Field type</b></td>
                                                            <td><b>Length Minimum</b></td>
                                                            <td><b>Length Maximum</b></td>
                                                            <td><b>Description</b></td>
                                                        </tr>
                                                        <tr>
                                                            <td>Address Type</td>
                                                            <td><code>data</code></td>
                                                            <td>1</td>
                                                            <td>1</td>
                                                            <td>
                                                                Set to <strong>value 0</strong> to denote an <i>Ed25519 Address</i>.
                                                            </td>
                                                        </tr>
                                                        <tr>
                                                            <td>PubKeyHash</td>
                                                            <td><code>data</code></td>
                                                            <td>32</td>
                                                            <td>32</td>
                                                            <td>The raw bytes of the Ed25519 address which is a BLAKE2b-256 hash of the Ed25519 public key.</td>
                                                        </tr>
                                                    </table>
                                                </details>
                                                <details>
                                                    <summary>Alias Address</summary>
                                                    <table>
                                                        <tr>
                                                            <td><b>Name</b></td>
                                                            <td><b>Field type</b></td>
                                                            <td><b>Length Minimum</b></td>
                                                            <td><b>Length Maximum</b></td>
                                                            <td><b>Description</b></td>
                                                        </tr>
                                                        <tr>
                                                            <td>Address Type</td>
                                                            <td><code>data</code></td>
                                                            <td>1</td>
                                                            <td>1</td>
                                                            <td>
                                                                Set to <strong>value 8</strong> to denote an <i>Alias Address</i>.
                                                            </td>
                                                        </tr>
                                                        <tr>
                                                            <td>Alias ID</td>
                                                            <td><code>data</code></td>
                                                            <td>32</td>
                                                            <td>32</td>
                                                            <td>The raw bytes of the <i>Alias ID</i> which is the BLAKE2b-256 hash of the outputID that created it.</td>
                                                        </tr>
                                                    </table>
                                                </details>
                                                <details>
                                                    <summary>NFT Address</summary>
                                                    <table>
                                                        <tr>
                                                            <td><b>Name</b></td>
                                                            <td><b>Field type</b></td>
                                                            <td><b>Length Minimum</b></td>
                                                            <td><b>Length Maximum</b></td>
                                                            <td><b>Description</b></td>
                                                        </tr>
                                                        <tr>
                                                            <td>Address Type</td>
                                                            <td><code>data</code></td>
                                                            <td>1</td>
                                                            <td>1</td>
                                                            <td>
                                                                Set to <strong>value 16</strong> to denote an <i>NFT Address</i>.
                                                            </td>
                                                        </tr>
                                                        <tr>
                                                            <td>NFT ID</td>
                                                            <td><code>data</code></td>
                                                            <td>32</td>
                                                            <td>32</td>
                                                            <td>The raw bytes of the <i>NFT ID</i> which is the BLAKE2b-256 hash of the outputID that created it.</td>
                                                        </tr>
                                                    </table>
                                                </details>
                                            </td>
                                        </tr>
                                        <tr>
                                            <td>Return Amount</td>
                                            <td><code>data</code></td>
                                            <td>8</td>
                                            <td>8</td>
                                            <td>
                                                Amount of IOTA coins the consuming transaction should deposit to the address defined in <i>Return Address</i>.
                                            </td>
                                        </tr>
                                    </table>
                                </details>
                                <details>
                                    <summary>Timelock Unlock Condition</summary>
                                    <blockquote>
                                        Defines a unix timestamp until which the output can not be unlocked.
                                    </blockquote>
                                    <table>
                                        <tr>
                                            <td><b>Name</b></td>
                                            <td><b>Field type</b></td>
                                            <td><b>Length Minimum</b></td>
                                            <td><b>Length Maximum</b></td>
                                            <td><b>Description</b></td>
                                        </tr>
                                        <tr>
                                            <td>Unlock Condition Type</td>
                                            <td><code>data</code></td>
                                            <td>1</td>
                                            <td>1</td>
                                            <td>
                                                Set to <strong>value 2</strong> to denote a <i>Timelock Unlock Condition</i>.
                                            </td>
                                        </tr>
                                        <tr>
                                            <td>Unix Time</td>
                                            <td><code>data</code></td>
                                            <td>4</td>
                                            <td>4</td>
                                            <td>
                                                Unix time (seconds since Unix epoch) starting from which the output can be consumed.
                                            </td>
                                        </tr>
                                    </table>
                                </details>
                                <details>
                                    <summary>Expiration Unlock Condition</summary>
                                    <blockquote>
                                        Defines a unix time until which only <i>Address</i>, defined in <i>Address Unlock Condition</i>, is allowed to
                                        unlock the output. After the unix time is reached/passed, only <i>Return Address</i> can unlock it.
                                    </blockquote>
                                    <table>
                                        <tr>
                                            <td><b>Name</b></td>
                                            <td><b>Field type</b></td>
                                            <td><b>Length Minimum</b></td>
                                            <td><b>Length Maximum</b></td>
                                            <td><b>Description</b></td>
                                        </tr>
                                        <tr>
                                            <td>Unlock Condition Type</td>
                                            <td><code>data</code></td>
                                            <td>1</td>
                                            <td>1</td>
                                            <td>
                                                Set to <strong>value 3</strong> to denote a <i>Expiration Unlock Condition</i>.
                                            </td>
                                        </tr>
                                        <tr>
                                            <td valign="top">Return Address <code>oneOf</code></td>
                                            <td colspan="2">
                                                <details>
                                                    <summary>Ed25519 Address</summary>
                                                    <table>
                                                        <tr>
                                                            <td><b>Name</b></td>
                                                            <td><b>Field type</b></td>
                                                            <td><b>Length Minimum</b></td>
                                                            <td><b>Length Maximum</b></td>
                                                            <td><b>Description</b></td>
                                                        </tr>
                                                        <tr>
                                                            <td>Address Type</td>
                                                            <td><code>data</code></td>
                                                            <td>1</td>
                                                            <td>1</td>
                                                            <td>
                                                                Set to <strong>value 0</strong> to denote an <i>Ed25519 Address</i>.
                                                            </td>
                                                        </tr>
                                                        <tr>
                                                            <td>PubKeyHash</td>
                                                            <td><code>data</code></td>
                                                            <td>32</td>
                                                            <td>32</td>
                                                            <td>The raw bytes of the Ed25519 address which is a BLAKE2b-256 hash of the Ed25519 public key.</td>
                                                        </tr>
                                                    </table>
                                                </details>
                                                <details>
                                                    <summary>Alias Address</summary>
                                                    <table>
                                                        <tr>
                                                            <td><b>Name</b></td>
                                                            <td><b>Field type</b></td>
                                                            <td><b>Length Minimum</b></td>
                                                            <td><b>Length Maximum</b></td>
                                                            <td><b>Description</b></td>
                                                        </tr>
                                                        <tr>
                                                            <td>Address Type</td>
                                                            <td><code>data</code></td>
                                                            <td>1</td>
                                                            <td>1</td>
                                                            <td>
                                                                Set to <strong>value 8</strong> to denote an <i>Alias Address</i>.
                                                            </td>
                                                        </tr>
                                                        <tr>
                                                            <td>Alias ID</td>
                                                            <td><code>data</code></td>
                                                            <td>32</td>
                                                            <td>32</td>
                                                            <td>The raw bytes of the <i>Alias ID</i> which is the BLAKE2b-256 hash of the outputID that created it.</td>
                                                        </tr>
                                                    </table>
                                                </details>
                                                <details>
                                                    <summary>NFT Address</summary>
                                                    <table>
                                                        <tr>
                                                            <td><b>Name</b></td>
                                                            <td><b>Field type</b></td>
                                                            <td><b>Length Minimum</b></td>
                                                            <td><b>Length Maximum</b></td>
                                                            <td><b>Description</b></td>
                                                        </tr>
                                                        <tr>
                                                            <td>Address Type</td>
                                                            <td><code>data</code></td>
                                                            <td>1</td>
                                                            <td>1</td>
                                                            <td>
                                                                Set to <strong>value 16</strong> to denote an <i>NFT Address</i>.
                                                            </td>
                                                        </tr>
                                                        <tr>
                                                            <td>NFT ID</td>
                                                            <td><code>data</code></td>
                                                            <td>32</td>
                                                            <td>32</td>
                                                            <td>The raw bytes of the <i>NFT ID</i> which is the BLAKE2b-256 hash of the outputID that created it.</td>
                                                        </tr>
                                                    </table>
                                                </details>
                                            </td>
                                        </tr>
                                        <tr>
                                            <td>Unix Time</td>
                                            <td><code>data</code></td>
                                            <td>4</td>
                                            <td>4</td>
                                            <td>
                                                Before this unix time, <i>Address Unlock Condition</i> is allowed to unlock the output, after that only the address defined in <i>Return Address</i>.
                                            </td>
                                        </tr>
                                    </table>
                                </details>
                            </td>
                        </tr>
                        <tr>
                            <td>Features Count</td>
                            <td><code>data</code></td>
                            <td>1</td>
                            <td>1</td>
                            <td>The number of features following.</td>
                        </tr>
                        <tr>
                            <td valign="top">Features <code>atMostOneOfEach</code></td>
                            <td colspan="2">
                                <details>
                                    <summary>Sender Feature</summary>
                                    <blockquote>
                                        Identifies the validated sender of the output.
                                    </blockquote>
                                    <table>
                                        <tr>
                                            <td><b>Name</b></td>
                                            <td><b>Field type</b></td>
                                            <td><b>Length Minimum</b></td>
                                            <td><b>Length Maximum</b></td>
                                            <td><b>Description</b></td>
                                        </tr>
                                        <tr>
                                            <td>Feature Type</td>
                                            <td><code>data</code></td>
                                            <td>1</td>
                                            <td>1</td>
                                            <td>
                                                Set to <strong>value 0</strong> to denote a <i>Sender Feature</i>.
                                            </td>
                                        </tr>
                                        <tr>
                                            <td valign="top">Sender <code>oneOf</code></td>
                                            <td colspan="2">
                                                <details>
                                                    <summary>Ed25519 Address</summary>
                                                    <table>
                                                        <tr>
                                                            <td><b>Name</b></td>
                                                            <td><b>Field type</b></td>
                                                            <td><b>Length Minimum</b></td>
                                                            <td><b>Length Maximum</b></td>
                                                            <td><b>Description</b></td>
                                                        </tr>
                                                        <tr>
                                                            <td>Address Type</td>
                                                            <td><code>data</code></td>
                                                            <td>1</td>
                                                            <td>1</td>
                                                            <td>
                                                                Set to <strong>value 0</strong> to denote an <i>Ed25519 Address</i>.
                                                            </td>
                                                        </tr>
                                                        <tr>
                                                            <td>PubKeyHash</td>
                                                            <td><code>data</code></td>
                                                            <td>32</td>
                                                            <td>32</td>
                                                            <td>The raw bytes of the Ed25519 address which is a BLAKE2b-256 hash of the Ed25519 public key.</td>
                                                        </tr>
                                                    </table>
                                                </details>
                                                <details>
                                                    <summary>Alias Address</summary>
                                                    <table>
                                                        <tr>
                                                            <td><b>Name</b></td>
                                                            <td><b>Field type</b></td>
                                                            <td><b>Length Minimum</b></td>
                                                            <td><b>Length Maximum</b></td>
                                                            <td><b>Description</b></td>
                                                        </tr>
                                                        <tr>
                                                            <td>Address Type</td>
                                                            <td><code>data</code></td>
                                                            <td>1</td>
                                                            <td>1</td>
                                                            <td>
                                                                Set to <strong>value 8</strong> to denote an <i>Alias Address</i>.
                                                            </td>
                                                        </tr>
                                                        <tr>
                                                            <td>Alias ID</td>
                                                            <td><code>data</code></td>
                                                            <td>32</td>
                                                            <td>32</td>
                                                            <td>The raw bytes of the <i>Alias ID</i> which is the BLAKE2b-256 hash of the outputID that created it.</td>
                                                        </tr>
                                                    </table>
                                                </details>
                                                <details>
                                                    <summary>NFT Address</summary>
                                                    <table>
                                                        <tr>
                                                            <td><b>Name</b></td>
                                                            <td><b>Field type</b></td>
                                                            <td><b>Length Minimum</b></td>
                                                            <td><b>Length Maximum</b></td>
                                                            <td><b>Description</b></td>
                                                        </tr>
                                                        <tr>
                                                            <td>Address Type</td>
                                                            <td><code>data</code></td>
                                                            <td>1</td>
                                                            <td>1</td>
                                                            <td>
                                                                Set to <strong>value 16</strong> to denote an <i>NFT Address</i>.
                                                            </td>
                                                        </tr>
                                                        <tr>
                                                            <td>NFT ID</td>
                                                            <td><code>data</code></td>
                                                            <td>32</td>
                                                            <td>32</td>
                                                            <td>The raw bytes of the <i>NFT ID</i> which is the BLAKE2b-256 hash of the outputID that created it.</td>
                                                        </tr>
                                                    </table>
                                                </details>
                                            </td>
                                        </tr>
                                    </table>
                                </details>
                                <details>
                                    <summary>Metadata Feature</summary>
                                    <blockquote>
                                        Defines metadata (arbitrary binary data) that will be stored in the output.
                                    </blockquote>
                                    <table>
                                        <tr>
                                            <td><b>Name</b></td>
                                            <td><b>Field type</b></td>
                                            <td><b>Length Minimum</b></td>
                                            <td><b>Length Maximum</b></td>
                                            <td><b>Description</b></td>
                                        </tr>
                                        <tr>
                                            <td>Feature Type</td>
                                            <td><code>data</code></td>
                                            <td>1</td>
                                            <td>1</td>
                                            <td>
                                                Set to <strong>value 2</strong> to denote a <i>Metadata Feature</i>.
                                            </td>
                                        </tr>
                                        <tr>
                                            <td>Data Length</td>
                                            <td><code>data</code></td>
                                            <td>2</td>
                                            <td>2</td>
                                            <td>
                                                Length of the following data field in bytes.
                                            </td>
                                        </tr>
                                        <tr>
                                            <td>Data</td>
                                            <td><code>data</code></td>
                                            <td>1</td>
                                            <td>8192</td>
                                            <td>Binary data.</td>
                                        </tr>
                                    </table>
                                </details>
                                <details>
                                    <summary>Tag Feature</summary>
                                    <blockquote>
                                        Defines an indexation tag to which the output can be indexed by additional node plugins.
                                    </blockquote>
                                    <table>
                                        <tr>
                                            <td><b>Name</b></td>
                                            <td><b>Field type</b></td>
                                            <td><b>Length Minimum</b></td>
                                            <td><b>Length Maximum</b></td>
                                            <td><b>Description</b></td>
                                        </tr>
                                        <tr>
                                            <td>Feature Type</td>
                                            <td><code>data</code></td>
                                            <td>1</td>
                                            <td>1</td>
                                            <td>
                                                Set to <strong>value 3</strong> to denote a <i>Tag Feature</i>.
                                            </td>
                                        </tr>
                                        <tr>
                                            <td>Tag Length</td>
                                            <td><code>data</code></td>
                                            <td>1</td>
                                            <td>1</td>
                                            <td>
                                                Length of the following tag field in bytes.
                                            </td>
                                        </tr>
                                        <tr>
                                            <td>Tag</td>
                                            <td><code>data</code></td>
                                            <td>1</td>
                                            <td>255</td>
                                            <td>Binary indexation data.</td>
                                        </tr>
                                    </table>
                                </details>
                            </td>
                        </tr>
                        <tr>
                            <td>Immutable Features Count</td>
                            <td><code>data</code></td>
                            <td>1</td>
                            <td>1</td>
                            <td>The number of immutable features following. Immutable features are defined upon deployment of the UTXO state machine and are not allowed to change in any future state transition.</td>
                        </tr>
                        <tr>
                            <td valign="top">Immutable Features <code>atMostOneOfEach</code></td>
                            <td colspan="2">
                                <details>
                                    <summary>Issuer Feature</summary>
                                    <blockquote>
                                        Identifies the validated issuer of the UTXO state machine.
                                    </blockquote>
                                    <table>
                                        <tr>
                                            <td><b>Name</b></td>
                                            <td><b>Field type</b></td>
                                            <td><b>Length Minimum</b></td>
                                            <td><b>Length Maximum</b></td>
                                            <td><b>Description</b></td>
                                        </tr>
                                        <tr>
                                            <td>Feature Type</td>
                                            <td><code>data</code></td>
                                            <td>1</td>
                                            <td>1</td>
                                            <td>
                                                Set to <strong>value 1</strong> to denote an <i>Issuer Feature</i>.
                                            </td>
                                        </tr>
                                        <tr>
                                            <td valign="top">Issuer <code>oneOf</code></td>
                                            <td colspan="2">
                                                <details>
                                                    <summary>Ed25519 Address</summary>
                                                    <table>
                                                        <tr>
                                                            <td><b>Name</b></td>
                                                            <td><b>Field type</b></td>
                                                            <td><b>Length Minimum</b></td>
                                                            <td><b>Length Maximum</b></td>
                                                            <td><b>Description</b></td>
                                                        </tr>
                                                        <tr>
                                                            <td>Address Type</td>
                                                            <td><code>data</code></td>
                                                            <td>1</td>
                                                            <td>1</td>
                                                            <td>
                                                                Set to <strong>value 0</strong> to denote an <i>Ed25519 Address</i>.
                                                            </td>
                                                        </tr>
                                                        <tr>
                                                            <td>PubKeyHash</td>
                                                            <td><code>data</code></td>
                                                            <td>32</td>
                                                            <td>32</td>
                                                            <td>The raw bytes of the Ed25519 address which is a BLAKE2b-256 hash of the Ed25519 public key.</td>
                                                        </tr>
                                                    </table>
                                                </details>
                                                <details>
                                                    <summary>Alias Address</summary>
                                                    <table>
                                                        <tr>
                                                            <td><b>Name</b></td>
                                                            <td><b>Field type</b></td>
                                                            <td><b>Length Minimum</b></td>
                                                            <td><b>Length Maximum</b></td>
                                                            <td><b>Description</b></td>
                                                        </tr>
                                                        <tr>
                                                            <td>Address Type</td>
                                                            <td><code>data</code></td>
                                                            <td>1</td>
                                                            <td>1</td>
                                                            <td>
                                                                Set to <strong>value 8</strong> to denote an <i>Alias Address</i>.
                                                            </td>
                                                        </tr>
                                                        <tr>
                                                            <td>Alias ID</td>
                                                            <td><code>data</code></td>
                                                            <td>32</td>
                                                            <td>32</td>
                                                            <td>The raw bytes of the <i>Alias ID</i> which is the BLAKE2b-256 hash of the outputID that created it.</td>
                                                        </tr>
                                                    </table>
                                                </details>
                                                <details>
                                                    <summary>NFT Address</summary>
                                                    <table>
                                                        <tr>
                                                            <td><b>Name</b></td>
                                                            <td><b>Field type</b></td>
                                                            <td><b>Length Minimum</b></td>
                                                            <td><b>Length Maximum</b></td>
                                                            <td><b>Description</b></td>
                                                        </tr>
                                                        <tr>
                                                            <td>Address Type</td>
                                                            <td><code>data</code></td>
                                                            <td>1</td>
                                                            <td>1</td>
                                                            <td>
                                                                Set to <strong>value 16</strong> to denote an <i>NFT Address</i>.
                                                            </td>
                                                        </tr>
                                                        <tr>
                                                            <td>NFT ID</td>
                                                            <td><code>data</code></td>
                                                            <td>32</td>
                                                            <td>32</td>
                                                            <td>The raw bytes of the <i>NFT ID</i> which is the BLAKE2b-256 hash of the outputID that created it.</td>
                                                        </tr>
                                                    </table>
                                                </details>
                                            </td>
                                        </tr>
                                    </table>
                                </details>
                                <details>
                                    <summary>Metadata Feature</summary>
                                    <blockquote>
                                        Defines metadata (arbitrary binary data) that will be stored in the output.
                                    </blockquote>
                                    <table>
                                        <tr>
                                            <td><b>Name</b></td>
                                            <td><b>Field type</b></td>
                                            <td><b>Length Minimum</b></td>
                                            <td><b>Length Maximum</b></td>
                                            <td><b>Description</b></td>
                                        </tr>
                                        <tr>
                                            <td>Feature Type</td>
                                            <td><code>data</code></td>
                                            <td>1</td>
                                            <td>1</td>
                                            <td>
                                                Set to <strong>value 2</strong> to denote a <i>Metadata Feature</i>.
                                            </td>
                                        </tr>
                                        <tr>
                                            <td>Data Length</td>
                                            <td><code>data</code></td>
                                            <td>2</td>
                                            <td>2</td>
                                            <td>
                                                Length of the following data field in bytes.
                                            </td>
                                        </tr>
                                        <tr>
                                            <td>Data</td>
                                            <td><code>data</code></td>
                                            <td>1</td>
                                            <td>8192</td>
                                            <td>Binary data.</td>
                                        </tr>
                                    </table>
                                </details>
                            </td>
                        </tr>
                    </table>
                </td>
            </tr>
            <tr>
                <td>v_byte Minimum</td>
                <td>459</td>
            </tr>
            <tr>
                <td>v_byte Maximum</td>
                <td>21739</td>
            </tr>
        </table>
    </details>
</table>
<p><img src="tips/TIP-0019/assets/deposit_miota_NFTOutput_(min_functionality).jpg" alt="" /></p>
<p><img src="tips/TIP-0019/assets/deposit_miota_NFTOutput_(max_functionality).jpg" alt="" /></p>
<h3 id="microtransactions"><a class="header" href="#microtransactions">Microtransactions</a></h3>
<h4 id="microtransactions-on-layer-1"><a class="header" href="#microtransactions-on-layer-1">Microtransactions on Layer 1</a></h4>
<p>To enable microtransactions on Layer 1 and still satisfy the <code>min_deposit_of_output</code> requirement, a new mechanism called <code>conditional sending</code> is introduced with the new <a href="tips/TIP-0019/../TIP-0018/tip-0018.html">Output Types TIP-18</a>.</p>
<p><img src="tips/TIP-0019/assets/microtransactions_pt3_layer1.png" alt="Microtransactions on Layer 1" /></p>
<p>The preceding picture shows the process of the <code>conditional sending</code> mechanism. Alice uses the <code>Basic Output</code> to send a microtransaction of 1 IOTA to Bob's <code>Address</code>. To fulfill the <code>min_deposit_of_output</code> requirement, the <code>Amount</code> is increased by <code>min_deposit_of_output</code> IOTA, which is 1 MIOTA in the above example. To prevent Bob from accessing these additional funds called the <code>storage deposit</code>, Alice adds the optional <code>Storage Deposit Return Unlock Condition</code>  to the <code>Basic Output</code>. Now Bob can only consume the newly created output, if the unlocking transaction deposits the specified <code>Return Amount</code> IOTA coins, in this case 1 MIOTA, to the <code>Return Address</code> value defined by Alice. By consuming another UTXO and adding its amount to the received 1 IOTA, Bob takes care to create a valid output according to the dust protection rules.</p>
<p>To prevent Bob from blocking access to the <code>storage deposit</code> forever, Alice specifies the additional <code>Expiration Unlock Condition</code> in the <code>Basic Output</code>. If Bob does not consume the output before the time window defined by Alice expires, Alice regains total control over the output.</p>
<p>This means that there is no risk for Alice to lose the <code>storage deposit</code>, because either Bob needs to return the specified <code>Return Amount</code>, or the ownership of the created output switches back to Alice after the specified time-window has expired.</p>
<p>This mechanism can also be used to transfer native tokens or on-chain requests to ISCP chains without losing control over the required <code>storage deposit</code>.</p>
<h4 id="microtransactions-on-layer-2"><a class="header" href="#microtransactions-on-layer-2">Microtransactions on Layer 2</a></h4>
<p>Another solution is to outsource microtransactions to Layer 2 applications like smart contracts. In Layer 2 there are no restrictions regarding the minimum balance of an output.</p>
<p><img src="tips/TIP-0019/assets/microtransactions_pt3_layer2.png" alt="Microtransactions on Layer 2" /></p>
<p>In this example, Alice sends funds to a smart contract chain on Layer 1 with an output that covers at least <code>min_deposit_of_output</code>. From this point on, Alice can send any number of off-chain requests to the smart contract chain, causing the smart contract to send microtransactions from Alice' on-chain account to Bob's on-chain account. Bob can now request his on-chain account balances to be withdrawn to his Layer 1 address. The last step can also be combined with the formerly introduced <code>conditional sending</code> mechanism, in case Bob wants to withdraw less than <code>min_deposit_of_output</code> IOTA coins or native assets.</p>
<div class="table-wrapper"><table><thead><tr><th>:information_source: Potential additional mechanisms for microtransactions are currently being discussed.</th></tr></thead><tbody>
</tbody></table>
</div>
<h3 id="migration-from-old-to-new-dust-protection"><a class="header" href="#migration-from-old-to-new-dust-protection">Migration from old to new dust protection</a></h3>
<p>All <code>SigLockedSingleOutput</code> below 1 MIOTA and <code>SigLockedDustAllowanceOutput</code> of an address could be collected and migrated to a single new <code>BasicOutput</code> with the smallest <code>Output ID</code> (byte-wise) of all these collected outputs as the new identifier.</p>
<p>This could probably be done in the form of a global snapshot and would represent a hard-fork.</p>
<p>Another solution is to convert all <code>SigLockedDustAllowanceOutput</code> into <code>BasicOutputs</code> and leave the <code>SigLockedSingleOutput</code> below 1 MIOTA untouched.</p>
<h2 id="copyright-18"><a class="header" href="#copyright-18">Copyright</a></h2>
<p>Copyright and related rights waived via <a href="https://creativecommons.org/publicdomain/zero/1.0/">CC0</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><pre>
tip: 20
title: Transaction Payload with TIP-18 Output Types
description: Add output types, unlocks, and output features from TIP-18 into Transaction Payload
author: Levente Pap (@lzpap) <levente.pap@iota.org>
discussions-to: https://github.com/iotaledger/tips/pull/40
status: Active
type: Standards
layer: Core
created: 2021-11-18
requires: 18
replaces: 7
</pre>
<h1 id="summary-18"><a class="header" href="#summary-18">Summary</a></h1>
<p>This TIP proposes a UTXO-based transaction structure consisting of all the inputs and outputs of a transfer. Specifically, this TIP defines a transaction payload for <em>blocks</em> described in <a href="tips/TIP-0020/../TIP-0024/tip-0024.html">TIP-24</a> and extends the transaction payload described in <a href="tips/TIP-0020/../TIP-0007/tip-0007.html">TIP-7</a>.</p>
<h1 id="motivation-17"><a class="header" href="#motivation-17">Motivation</a></h1>
<p><a href="tips/TIP-0020/../TIP-0007/tip-0007.html">TIP-7</a> describes the introduction of the UTXO ledger model for Chrysalis. This TIP extends the
transaction model of the UTXO ledger to:</p>
<ul>
<li>accommodate for the new output types introduced in <a href="tips/TIP-0020/../TIP-0018/tip-0018.html">TIP-18</a>,</li>
<li>include a <em>Network ID</em> field in the transaction for replay protection,</li>
<li>introduce <em>Inputs Commitment</em> field to prevent client <a href="https://github.com/iotaledger/tips/discussions/51">eclipse attacks that would result in loss of funds,</a></li>
<li>relax syntactic validation rules such that inputs and outputs of a transaction are no longer lexicographically ordered, furthermore
outputs do not have to be unique.</li>
</ul>
<p>The motivation for such changes is to provide a more flexible and secure framework for wallets and layer 2 applications. Chrysalis
focused solely on using the ledger as a payment application, while Stardust transforms the ledger into a settlement layer
for interconnected layer 2 blockchains and applications.</p>
<h1 id="detailed-design-16"><a class="header" href="#detailed-design-16">Detailed design</a></h1>
<h2 id="utxo-1"><a class="header" href="#utxo-1">UTXO</a></h2>
<p>The <em>unspent transaction output</em> (UTXO) model defines a ledger state where balances are not directly associated to addresses but to the outputs of transactions. In this model, transactions reference outputs of previous transactions as inputs, which are consumed (removed) to create new outputs. A transaction must consume all the funds of the referenced inputs.</p>
<p>Using a UTXO-based model provides several benefits:</p>
<ul>
<li>Parallel validation of transactions.</li>
<li>Easier double-spend detection, since conflicting transactions would reference the same UTXO.</li>
<li>Replay-protection which is important when having reusable addresses. Replaying the same transaction would manifest itself as already being applied or existent and thus not have any impact.</li>
<li>Balances are no longer strictly associated to addresses. This allows a higher level of abstraction and thus enables other types of outputs with particular unlock criteria.</li>
</ul>
<p>Within a transaction using UTXOs, inputs and outputs make up the to-be-signed data of the transaction. The section unlocking the inputs is called the <em>unlock</em>. An unlock may contain a signature proving ownership of a given input's address and/or other unlock criteria.</p>
<p>The following image depicts the flow of funds using UTXO:</p>
<p><img src="tips/TIP-0020/utxo.png" alt="UTXO flow" /></p>
<h2 id="structure-3"><a class="header" href="#structure-3">Structure</a></h2>
<h3 id="serialized-layout-2"><a class="header" href="#serialized-layout-2">Serialized layout</a></h3>
<p>A <em>Transaction Payload</em> is made up of two parts:</p>
<ol>
<li>The <em>Transaction Essence</em> part which contains the inputs, outputs and an optional embedded payload.</li>
<li>The <em>Unlocks</em> which unlock the inputs of the <em>Transaction Essence</em>.</li>
</ol>
<p>The serialized form of the transaction is deterministic, meaning the same logical transaction always results in the same serialized byte sequence. However, in contrast to Chrysalis Phase 2 <a href="tips/TIP-0020/../TIP-0007/tip-0007.html">TIP-7</a> the inputs and outputs are considered as lists. They can contain duplicates and their serialization order matches the order of the list; they do not need to be sorted.</p>
<p>The <em>Transaction Payload ID</em> is the <a href="https://tools.ietf.org/html/rfc7693">BLAKE2b-256</a> hash of the entire serialized payload data including unlocks.</p>
<p>The following table describes the entirety of a <em>Transaction Payload</em> in its serialized form following the notation from <a href="tips/TIP-0020/../TIP-0021/tip-0021.html">TIP-21</a>:</p>
<table>
  <tr>
    <th>Name</th>
    <th>Type</th>
    <th>Description</th>
  </tr>
  <tr>
    <td>Payload Type</td>
    <td>uint32</td>
    <td>
      Set to <strong>value 6</strong> to denote a <i>TIP-20 Transaction Payload</i>.
    </td>
  </tr>
  <tr>
    <td valign="top">Essence <code>oneOf</code></td>
    <td colspan="2">
      <details open="true">
        <summary>Transaction Essence</summary>
        <blockquote>
          Describes the essence data making up a transaction by defining its inputs, outputs and an optional payload.
        </blockquote>
        <table>
          <tr>
            <td><b>Name</b></td>
            <td><b>Type</b></td>
            <td><b>Description</b></td>
          </tr>
          <tr>
            <td>Transaction Type</td>
            <td>uint8</td>
            <td>
              Set to <strong>value 1</strong> to denote a <i>TIP-20 Transaction Essence</i>.
            </td>
          </tr>
          <tr>
            <td>Network ID</td>
            <td>uint64</td>
            <td>
              The unique value denoting whether the block was meant for mainnet, shimmer, testnet, or a private network. It consists of the first 8 bytes of the BLAKE2b-256 hash of the network name.
            </td>
          </tr>
          <tr>
            <td>Inputs Count</td>
            <td>uint16</td>
            <td>The number of input entries.</td>
          </tr>
          <tr>
            <td valign="top">Inputs <code>anyOf</code></td>
            <td colspan="2">
              <details>
                <summary>UTXO Input</summary>
                <blockquote>
                  Describes an input which references an unspent transaction output to consume.
                </blockquote>
                <table>
                  <tr>
                    <td><b>Name</b></td>
                    <td><b>Type</b></td>
                    <td><b>Description</b></td>
                  </tr>
                  <tr>
                    <td>Input Type</td>
                    <td>uint8</td>
                    <td>
                      Set to <strong>value 0</strong> to denote an <i>TIP-20 UTXO Input</i>.
                    </td>
                  </tr>
                  <tr>
                    <td>Transaction ID</td>
                    <td>ByteArray[32]</td>
                    <td>The BLAKE2b-256 hash of the transaction payload containing the referenced output.</td>
                  </tr>
                  <tr>
                    <td>Transaction Output Index</td>
                    <td>uint16</td>
                    <td>The output index of the referenced output.</td>
                  </tr>
                </table>
              </details>
            </td>
          </tr>
          <tr>
            <td>Inputs Commitment</td>
            <td>ByteArray[32]</td>
            <td>
              BLAKE2b-256 hash serving as a commitment to the serialized outputs referenced by <code>Inputs</code>.
            </td>
          </tr>
          <tr>
            <td>Outputs Count</td>
            <td>uint16</td>
            <td>The number of output entries.</td>
          </tr>
          <tr>
            <td valign="top">Outputs <code>anyOf</code></td>
            <td colspan="2">
              <details>
                <summary>Basic Output</summary>
                <blockquote>
                  Describes a deposit to a single address. The output might contain optional features and native tokens.
                </blockquote>
              </details>
              <details>
                <summary>Alias Output</summary>
                <blockquote>
                  Describes an alias account in the ledger.
                </blockquote>
              </details>
              <details>
                <summary>Foundry Output</summary>
                <blockquote>
                  Describes a foundry that controls supply of native tokens.
                </blockquote>
              </details>
              <details>
                <summary>NFT Output</summary>
                <blockquote>
                  Describes a unique, non-fungible token deposit to a single address.
                </blockquote>
              </details>
            </td>
          </tr>
          <tr>
            <td>Payload Length</td>
            <td>uint32</td>
            <td>The length in bytes of the optional payload.</td>
          </tr>
          <tr>
            <td valign="top">Payload <code>optOneOf</code></td>
            <td colspan="2">
              <details>
                <summary>Tagged Data Payload</summary>
                <blockquote>
                  Describes data with optional tag, defined in TIP-23.
                </blockquote>
              </details>
            </td>
          </tr>
        </table>
      </details>
    </td>
  </tr>
  <tr>
    <td>Unlocks Count</td>
    <td>uint16</td>
    <td>The number of unlock entries. It must match the field <code>Inputs Count</code>.</td>
  </tr>
  <tr>
    <td valign="top">Unlocks <code>anyOf</code></td>
    <td colspan="2">
      <details>
        <summary>Signature Unlock</summary>
        <blockquote>
          Defines an unlock containing a signature.
        </blockquote>
      </details>
      <details>
        <summary>Reference Unlock</summary>
        <blockquote>
          References a previous unlock, where the same unlock can be used for multiple inputs.
        </blockquote>
      </details>
      <details>
        <summary>Alias Unlock</summary>
        <blockquote>
          References a previous unlock of a consumed alias output.
        </blockquote>
      </details>
      <details>
        <summary>NFT Unlock</summary>
        <blockquote>
          References a previous unlock of a consumed NFT output.
        </blockquote>
      </details>
    </td>
  </tr>
</table>
<h3 id="transaction-essence"><a class="header" href="#transaction-essence">Transaction Essence</a></h3>
<p>The <i>Transaction Essence</i> of a <i>Transaction Payload</i> carries the inputs, outputs, and an optional payload. The <i>Transaction Essence</i> is an explicit type and therefore starts with its own <i>Transaction Essence Type</i> byte which is of value 1 for <i>TIP-20 Transaction Essence</i>.</p>
<h4 id="network-id"><a class="header" href="#network-id">Network ID</a></h4>
<p>The <code>Network ID</code> field of the transaction essence serves as a <a href="https://github.com/iotaledger/tips/discussions/56">replay protection mechanism</a>.
It is a unique value denoting whether the transaction was meant for the IOTA mainnet, shimmer, testnet-1, or a private network. It consists of the first 8 bytes of the BLAKE2b-256 hash of the <code>Network Name</code> protocol parameter, interpreted as an unsigned integer number.</p>
<div class="table-wrapper"><table><thead><tr><th>Network Name</th><th>Resulting <code>Network ID</code></th><th>Network Name defined in</th></tr></thead><tbody>
<tr><td><code>iota-mainnet</code></td><td><code>9374574019616453254</code></td><td><a href="tips/TIP-0020/../TIP-0022/tip-0022.html#detailed-design">TIP-22</a></td></tr>
<tr><td><code>shimmer</code></td><td><code>14364762045254553490</code></td><td><a href="tips/TIP-0020/../TIP-0032/tip-0032.html#global-parameters">TIP-32</a></td></tr>
<tr><td><code>testnet-1</code></td><td><code>1856588631910923207</code></td><td>-</td></tr>
<tr><td><code>example-mynetwork</code></td><td><code>1967754805504104511</code></td><td>-</td></tr>
</tbody></table>
</div>
<h4 id="inputs-1"><a class="header" href="#inputs-1">Inputs</a></h4>
<p>The <code>Inputs</code> field holds the inputs to consume in order to fund the outputs of the <i>Transaction Payload</i>. Currently, there is only one type of input, the <i>UTXO Input</i>. In the future, more types of inputs may be specified as part of protocol upgrades.</p>
<p>Each input must be accompanied by a corresponding <i>Unlock</i> at the same index in the <i>Unlocks</i> part of the <i>Transaction Payload</i>.</p>
<h5 id="utxo-input-1"><a class="header" href="#utxo-input-1">UTXO Input</a></h5>
<p>A <i>UTXO Input</i> is an input which references an unspent output of a previous transaction. This UTXO is uniquely identified by its <em>Output ID</em>, defined by the <em>Transaction ID</em> of the creating transaction together with corresponding output index. Each <i>UTXO Input</i> must be accompanied by an <i>Unlock</i> that is allowed to unlock the referenced output.</p>
<h4 id="inputs-commitment"><a class="header" href="#inputs-commitment">Inputs Commitment</a></h4>
<p>The <code>Inputs Commitment</code> field of the <em>Transaction Essence</em> is a cryptographic commitment to the content of the consumed outputs (inputs). It consists of the BLAKE2b-256 hash of the concatenated output hashes.</p>
<p>In the <code>Inputs</code> field, they are only referenced by  <em>Output ID</em>. While the <em>Output ID</em> technically depends on the content of the actual output, a client has no way of validating this without access to the original transaction. For the <code>Inputs Commitment</code>, the client has to be aware of the outputs’ content in order to produce a semantically valid transaction. This protects clients against <a href="https://github.com/iotaledger/tips/discussions/51">eclipse attacks that would result in loss of funds</a>.</p>
<h4 id="outputs-2"><a class="header" href="#outputs-2">Outputs</a></h4>
<p>The <code>Outputs</code> field holds the outputs that are created by the <i>Transaction Payload</i>. There are different output types, but they must all have an <code>Amount</code> field denoting the number of IOTA coins to deposit.</p>
<p>The following table lists all the output types that are currently supported as well as links to the corresponding specification. The <em>SigLockedSingleOutput</em> as well as the <em>SigLockedDustAllowanceOutput</em> introduced in Chrysalis Phase 2 <a href="tips/TIP-0020/../TIP-0007/tip-0007.html">TIP-7</a> have been removed and are no longer supported.</p>
<div class="table-wrapper"><table><thead><tr><th>Output Name</th><th>Type Value</th><th>TIP</th></tr></thead><tbody>
<tr><td>Basic</td><td>3</td><td><a href="tips/TIP-0020/../TIP-0018/tip-0018.html#basic-output">TIP-18</a></td></tr>
<tr><td>Alias</td><td>4</td><td><a href="tips/TIP-0020/../TIP-0018/tip-0018.html#alias-output">TIP-18</a></td></tr>
<tr><td>Foundry</td><td>5</td><td><a href="tips/TIP-0020/../TIP-0018/tip-0018.html#foundry-output">TIP-18</a></td></tr>
<tr><td>NFT</td><td>6</td><td><a href="tips/TIP-0020/../TIP-0018/tip-0018.html#nft-output">TIP-18</a></td></tr>
</tbody></table>
</div>
<h4 id="payload-1"><a class="header" href="#payload-1">Payload</a></h4>
<p>The  <em>Transaction Essence</em> itself can contain another payload as described in general in  <a href="tips/TIP-0020/../TIP-0024/tip-0024.html">TIP-24</a>. The <a href="tips/TIP-0020/tip-0020.html#semantic-validation">semantic validity</a> of the encapsulating <em>Transaction Payload</em> does not have any impact on the payload.</p>
<p>The following table lists all the payload types that can be nested inside a <em>Transaction Essence</em> as well as links to the corresponding specification:</p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type Value</th><th>TIP</th></tr></thead><tbody>
<tr><td>Tagged Data</td><td>5</td><td><a href="tips/TIP-0020/../TIP-0023/tip-0023.html">TIP-23</a></td></tr>
</tbody></table>
</div>
<h3 id="unlocks"><a class="header" href="#unlocks">Unlocks</a></h3>
<p>The <code>Unlocks</code> field holds the unlocks unlocking inputs within a <em>Transaction Essence</em>.</p>
<p>The following table lists all the output types that are currently supported as well as links to the corresponding specification. The <em>Signature Unlock</em> and the <em>Reference Unlock</em> are specified as part of this TIP.</p>
<div class="table-wrapper"><table><thead><tr><th>Unlock Name</th><th>Type Value</th><th>TIP</th></tr></thead><tbody>
<tr><td>Signature</td><td>0</td><td><a href="tips/TIP-0020/tip-0020.html#signature-unlock">TIP-20</a></td></tr>
<tr><td>Reference</td><td>1</td><td><a href="tips/TIP-0020/tip-0020.html#reference-unlock">TIP-20</a></td></tr>
<tr><td>Alias</td><td>2</td><td><a href="tips/TIP-0020/../TIP-0018/tip-0018.html#alias-locking--unlocking">TIP-18</a></td></tr>
<tr><td>NFT</td><td>3</td><td><a href="tips/TIP-0020/../TIP-0018/tip-0018.html#nft-locking--unlocking">TIP-18</a></td></tr>
</tbody></table>
</div>
<h4 id="signature-unlock"><a class="header" href="#signature-unlock">Signature Unlock</a></h4>
<p>The <i>Signature Unlock</i> defines an <i>Unlock</i> which holds a signature signing the BLAKE2b-256 hash of the <i>Transaction Essence</i> (including the optional payload). It is serialized as follows:</p>
<table>
  <tr>
    <th>Name</th>
    <th>Type</th>
    <th>Description</th>
  </tr>
  <tr>
    <td>Unlock Type</td>
    <td>uint8</td>
    <td>
      Set to <strong>value 0</strong> to denote a <i>Signature Unlock</i>.
    </td>
  </tr>
  <tr>
    <td valign="top">Signature <code>oneOf</code></td>
    <td colspan="2">
      <details>
        <summary>Ed25519 Signature</summary>
        <table>
          <tr>
            <th>Name</th>
            <th>Type</th>
            <th>Description</th>
          </tr>
          <tr>
            <td>Signature Type</td>
            <td>uint8</td>
            <td>
              Set to <strong>value 0</strong> to denote an <i>Ed25519 Signature</i>.
            </td>
          </tr>
          <tr>
            <td>Public key</td>
            <td>ByteArray[32]</td>
            <td>The Ed25519 public key of the signature.</td>
          </tr>
          <tr>
            <td>Signature</td>
            <td>ByteArray[64]</td>
            <td>The Ed25519 signature signing the Blake2b-256 hash of the serialized <i>Transaction Essence</i>.</td>
          </tr>
        </table>
      </details>
    </td>
  </tr>
</table>
<h5 id="unlock-syntactic-validation"><a class="header" href="#unlock-syntactic-validation">Unlock syntactic validation</a></h5>
<ul>
<li><code>Signature</code> must contain an <em>Ed25519 Signature</em>.</li>
<li>The <em>Signature Unlock</em> must be unique, i.e. there must not be any other <em>Signature Unlocks</em> in the <code>Unlocks</code> field of the transaction payload with the same signature.</li>
</ul>
<h4 id="reference-unlock"><a class="header" href="#reference-unlock">Reference Unlock</a></h4>
<p>The <i>Reference Unlock</i> defines an <i>Unlock</i> which references a previous <i>Unlock</i> (which must not be another <i>Reference Unlock</i>). It <strong>must</strong> be used if multiple inputs can be unlocked via the same <i>Unlock</i>. It is serialized as follows:</p>
<table>
  <tr>
    <th>Name</th>
    <th>Type</th>
    <th>Description</th>
  </tr>
  <tr>
    <td>Unlock Type</td>
    <td>uint8</td>
    <td>
      Set to <strong>value 1</strong> to denote a <i>Reference Unlock</i>.
    </td>
  </tr>
  <tr>
    <td>Reference</td>
    <td>uint16</td>
    <td>Represents the index of a previous unlock.</td>
  </tr>
</table>
<h5 id="unlock-syntactic-validation-1"><a class="header" href="#unlock-syntactic-validation-1">Unlock syntactic validation</a></h5>
<ul>
<li>The <em>Reference Unlock</em> at index i must have <code>Reference</code> &lt; i and the unlock at index <code>Reference</code> must be a <em>Signature Unlock</em>.</li>
</ul>
<p>Example:
Consider a <i>Transaction Essence</i> containing the <i>UTXO Inputs</i> 0, 1 and 2, where 0 and 2 are both spending outputs belonging to the same Ed25519 address A and 1 is spending from a different address B. This results in the following structure of the <i>Unlocks</i> part:</p>
<div class="table-wrapper"><table><thead><tr><th>Index</th><th>Unlock</th></tr></thead><tbody>
<tr><td>0</td><td>A <em>Signature Unlock</em> holding the Ed25519 signature for address A.</td></tr>
<tr><td>1</td><td>A <em>Signature Unlock</em> holding the Ed25519 signature for address B.</td></tr>
<tr><td>2</td><td>A <em>Reference Unlock</em> which references 0, as both require the same signature for A.</td></tr>
</tbody></table>
</div>
<h2 id="validation-4"><a class="header" href="#validation-4">Validation</a></h2>
<p>A <i>Transaction Payload</i> has different validation stages, since some validation steps can only be executed when certain information has (or has not) been received. We therefore distinguish between syntactic and semantic validation.</p>
<p>The different output types and optional output features introduced by <a href="tips/TIP-0020/../TIP-0018/tip-0018.html">TIP-18</a> add additional constraints to the transaction validation rules, but since these are specific to the given outputs and features, they are discussed for each <a href="tips/TIP-0020/../TIP-0018/tip-0018.html#output-design">output type</a> and <a href="tips/TIP-0020/../TIP-0018/tip-0018.html#features">feature type</a> separately.</p>
<h3 id="syntactic-validation-1"><a class="header" href="#syntactic-validation-1">Syntactic validation</a></h3>
<p>Syntactic validation is checked as soon as the transaction has been received. It validates the structure but not the signatures of the transaction. If the transaction does not pass this stage, it must not be broadcast further and can be discarded right away.</p>
<p>The following criteria defines whether a payload passes the syntactical validation:</p>
<ul>
<li>Essence:
<ul>
<li><code>Transaction Type</code> value must denote a <em>TIP-20 Transaction Essence</em>.</li>
<li><code>Network ID</code> must match the value of the current network.</li>
<li>Inputs:
<ul>
<li><code>Inputs Count</code> must be 0 &lt; x ≤ <code>Max Inputs Count</code>.</li>
<li>For each input the following must be true:
<ul>
<li><code>Input Type</code> must denote a <em>UTXO Input</em>.</li>
<li><code>Transaction Output Index</code> must be 0 ≤ x &lt; <code>Max Outputs Count</code>.</li>
</ul>
</li>
<li>Each pair of <code>Transaction ID</code> and <code>Transaction Output Index</code> must be unique in the list of inputs.</li>
</ul>
</li>
<li>Outputs:
<ul>
<li><code>Outputs Count</code> must be 0 &lt; x ≤ <code>Max Outputs Count</code>.</li>
<li>For each output the following must be true:
<ul>
<li><code>Output Type</code> must match one of the values described under <a href="tips/TIP-0020/tip-0020.html#outputs">Outputs</a>.</li>
<li>The output itself must pass syntactic validation.</li>
</ul>
</li>
<li>The sum of all <code>Amount</code> fields must not exceed <code>Max IOTA Supply</code>.</li>
<li>The count of all distinct native tokens present in outputs must not be larger than <code>Max Native Token Count</code>.</li>
</ul>
</li>
<li>Payload (if present):
<ul>
<li><code>Payload Type</code> must match one of the values described under <a href="tips/TIP-0020/tip-0020.html#payload">Payload</a>.</li>
<li>Payload fields must be correctly parsable in the context of the <code>Payload Type</code>.</li>
<li>The payload itself must pass syntactic validation.</li>
</ul>
</li>
</ul>
</li>
<li>Unlocks:
<ul>
<li><code>Unlocks Count</code> must match <code>Inputs Count</code> of the <em>Transaction Essence</em>.</li>
<li>For each unlock the following must be true:
<ul>
<li>Each <code>Unlock Type</code> must match one of the values described under <a href="tips/TIP-0020/tip-0020.html#unlocks">Unlocks</a>.</li>
<li>The unlock itself must pass syntactic validation.</li>
</ul>
</li>
</ul>
</li>
<li>Given the type and length information, the <em>Transaction Payload</em> must consume the entire byte array of the <code>Payload</code> field of the encapsulating object.</li>
</ul>
<h3 id="semantic-validation-1"><a class="header" href="#semantic-validation-1">Semantic validation</a></h3>
<p>The Semantic validation of a <em>Transaction Payload</em> is performed when its encapsulating block is confirmed by a milestone. The semantic validity of transactions depends on the order in which they are processed. Thus, it is necessary that all the nodes in the network perform the checks in the same order, no matter the order in which the transactions are received. This is assured by using the White-Flag ordering as described in  <a href="tips/TIP-0020/../TIP-0002/tip-0002.html#deterministically-ordering-the-tangle">TIP-2</a>.</p>
<p>Processing transactions according to the White-Flag ordering enables users to spend UTXOs which are created in the same milestone confirmation cone, as long as the spending transaction comes after the funding transaction in the aforementioned White-Flag order. In this case, it is recommended that users include the <em>Block ID</em> of the funding transaction as a parent of the block containing the spending transaction.</p>
<p>The following criteria defines whether a payload passes the semantic validation:</p>
<ul>
<li>Each input must reference a valid UTXO, i.e. the output referenced by the input's <code>Transaction ID</code> and <code>Transaction Output Index</code> is known (booked) and unspent.</li>
<li><code>Inputs Commitment</code> must equal BLAKE2( BLAKE2(O<sub>1</sub>) || … || BLAKE2(O<sub>n</sub>) ), where O<sub>1</sub>, ..., O<sub>n</sub> are the complete serialized outputs referenced by the <code>Inputs</code> field in that order.</li>
<li>The transaction must spend the entire coin balance, i.e. the sum of the <code>Amount</code> fields of all the UTXOs referenced by inputs must match the sum of the <code>Amount</code> fields of all outputs.</li>
<li>The count of all distinct native tokens present in the UTXOs referenced by inputs and in the transaction outputs must not be larger than <code>Max Native Token Count</code>. A native token that occurs several times in both inputs and outputs is counted as one.</li>
<li>The transaction is balanced in terms of native tokens, when the amount of native tokens present in all the UTXOs referenced by inputs equals to that of outputs. When the transaction is imbalanced, it must hold true that when there is a <strong>surplus of native tokens</strong> on the:
<ul>
<li><strong>output side of the transaction:</strong> the foundry outputs controlling outstanding native token balances must be present in the transaction. The validation of the foundry output(s) determines if the minting operations are valid.</li>
<li><strong>input side of the transaction:</strong> the transaction destroys tokens. The presence and validation of the foundry outputs of the native tokens determines whether the tokens are burned (removed from the ledger) or melted within the foundry. When the foundry output is not present in the transaction, outstanding token balances must be burned.</li>
</ul>
</li>
<li>Each output and all its <a href="tips/TIP-0020/../TIP-0018/tip-0018.html#features">output features</a> must pass semantic validation in the context of the following input:
<ol>
<li>The <em>Transaction Payload</em>,</li>
<li>the list of UTXOs referenced by inputs and</li>
<li>the Unix timestamp of the confirming milestone.</li>
</ol>
</li>
<li>Each unlock must be valid with respect to the UTXO referenced by the input of the same index:
<ul>
<li>If it is a <em>Signature Unlock</em>:
<ul>
<li>The <code>Signature Type</code> must match the <code>Address Type</code> of the UTXO, </li>
<li>the BLAKE2b-256 hash of <code>Public Key</code> must match the <code>Address</code> of the UTXO and</li>
<li>the <code>Signature</code> field must contain a valid signature for <code>Public Key</code>.</li>
</ul>
</li>
<li>If it is a <em>Reference Unlock</em>, the referenced <em>Signature Unlock</em> must be valid with respect to the UTXO.</li>
<li>If it is an <em>Alias Unlock</em>:
<ul>
<li>The address unlocking the UTXO must be an <em>Alias Address</em>.</li>
<li>The referenced <em>Unlock</em> unlocks the alias defined by the unlocking address of the UTXO.</li>
</ul>
</li>
<li>If it is an <em>NFT Unlock</em>:
<ul>
<li>The address unlocking the UTXO must be a <em>NFT Address</em>.</li>
<li>The referenced <em>Unlock</em> unlocks the NFT defined by the unlocking address of the UTXO.</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>If a <em>Transaction Payload</em> passes the semantic validation, its referenced UTXOs must be marked as spent and its new outputs must be created/booked in the ledger. The <em>Block ID</em> of the block encapsulating the processed payload then also becomes part of the input for the White-Flag Merkle tree hash of the confirming milestone (<a href="tips/TIP-0020/../TIP-0004/tip-0004.html">TIP-4</a>).</p>
<p>Transactions that do not pass semantic validation are ignored. Their UTXOs are not marked as spent and their outputs are not booked in the ledger.</p>
<h2 id="miscellaneous-1"><a class="header" href="#miscellaneous-1">Miscellaneous</a></h2>
<h3 id="transaction-timestamps-1"><a class="header" href="#transaction-timestamps-1">Transaction timestamps</a></h3>
<p>Since transaction timestamps – whether they are signed or not – do not provide any guarantee of correctness, they have been left out of the <em>Transaction Payload</em>. Instead, the global timestamp of the confirming milestone (<a href="tips/TIP-0020/../TIP-0008/tip-0008.html">TIP-8</a>) is used.</p>
<h3 id="address-reuse-1"><a class="header" href="#address-reuse-1">Address reuse</a></h3>
<p>While, in contrast to Winternitz one-time signatures (W-OTS), producing multiple Ed25519 signatures for the same private key and address does not decrease its security, it still drastically reduces the privacy of users. It is thus considered best practice that applications and services create a new address per deposit to circumvent these privacy issues.</p>
<p>In essence, Ed25519 support allows for smaller transaction sizes and to safely spend funds which were sent to an already used deposit address. Ed25519 addresses are not meant to be used like email addresses. See this <a href="https://en.bitcoin.it/wiki/Address_reuse">Bitcoin wiki article</a> for further information.</p>
<h1 id="drawbacks-13"><a class="header" href="#drawbacks-13">Drawbacks</a></h1>
<ul>
<li>The new transaction format is the core data type within the IOTA ecosystem. Changing it means that all projects need to accommodate it, including wallets, web services, client libraries and applications using IOTA in general. It is not possible to keep these changes backwards compatible, meaning that all nodes must upgrade to further participate in the network.</li>
<li>It is not possible to produce a valid transaction without having access to the content of the consumed outputs.</li>
</ul>
<h1 id="rationale-and-alternatives-14"><a class="header" href="#rationale-and-alternatives-14">Rationale and alternatives</a></h1>
<ul>
<li><em>Inputs Commitment</em> and <em>Network ID</em> are both explicit fields of the transaction, while they could be made configuration
parameters for the signature generating process. In this scenario the signature would be invalid if the parameters on client
and network side mismatch. While this would reduce the size of a transaction, it would make it impossible to debug the
reason for having an invalid signature and transaction. With the current solution we intend to optimize for ease of development.</li>
<li>Uniqueness of all inputs is kept as it prevents introducing double spends in the same transaction.</li>
</ul>
<h1 id="copyright-19"><a class="header" href="#copyright-19">Copyright</a></h1>
<p>Copyright and related rights waived via <a href="https://creativecommons.org/publicdomain/zero/1.0/">CC0</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><pre>
tip: 21
title: Serialization Primitives
description: Introduce primitives to describe the binary serialization of objects.
author: Wolfgang Welz (@Wollac) <wolfgang.welz@iota.org>
discussions-to: https://github.com/iotaledger/tips/pull/41
status: Active
type: Standards
layer: Core
created: 2021-11-22
</pre>
<h1 id="summary-19"><a class="header" href="#summary-19">Summary</a></h1>
<p>This document introduces the primitives and concepts that are used throughout the IOTA protocol RFCs to describe the binary serialization of objects.</p>
<h1 id="motivation-18"><a class="header" href="#motivation-18">Motivation</a></h1>
<p>Prior to this document, each RFC contained its own section and version describing the serialization of its objects. This RFC introduces consistent serialization concepts and avoids duplication in other RFCs.</p>
<h1 id="detailed-design-17"><a class="header" href="#detailed-design-17">Detailed design</a></h1>
<h2 id="schemas"><a class="header" href="#schemas">Schemas</a></h2>
<p>Serializable objects are represented by a <em>schema</em>. Each schema consists of a list of <em>fields</em>, which each have a name and a type. The type of a field can either be a simple data type or another schema, then called subschema.</p>
<h3 id="data-types"><a class="header" href="#data-types">Data types</a></h3>
<p>All the supported data types are described in the following table:</p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Description</th></tr></thead><tbody>
<tr><td>uint8</td><td>An unsigned 8-bit integer encoded in Little Endian.</td></tr>
<tr><td>uint16</td><td>An unsigned 16-bit integer encoded in Little Endian.</td></tr>
<tr><td>uint32</td><td>An unsigned 32-bit integer encoded in Little Endian.</td></tr>
<tr><td>uint64</td><td>An unsigned 64-bit integer encoded in Little Endian.</td></tr>
<tr><td>uint256</td><td>An unsigned 256 bits integer encoded in Little Endian.</td></tr>
<tr><td>ByteArray[N]</td><td>A static size byte array of N bytes.</td></tr>
<tr><td>(uint8)ByteArray</td><td>A dynamically sized byte array. A leading uint8 denotes its length in bytes.</td></tr>
<tr><td>(uint16)ByteArray</td><td>A dynamically sized byte array. A leading uint16 denotes its length in bytes.</td></tr>
<tr><td>(uint32)ByteArray</td><td>A dynamically sized byte array. A leading uint32 denotes its length in bytes.</td></tr>
</tbody></table>
</div>
<h3 id="subschemas"><a class="header" href="#subschemas">Subschemas</a></h3>
<p>In order to create complex schemas, one or multiple subschemas can be included into an outer schema. The keywords that describe the allowed combinations of such subschemas is described in the following table:</p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Description</th></tr></thead><tbody>
<tr><td><code>oneOf</code></td><td>One of the listed subschemas.</td></tr>
<tr><td><code>optOneOf</code></td><td>One of the listed subschemas or none.</td></tr>
<tr><td><code>anyOf</code></td><td>Any (one or more) of the listed subschemas.</td></tr>
<tr><td><code>optAnyOf</code></td><td>Any (one or more) of the listed subschemas or none.</td></tr>
<tr><td><code>atMostOneOfEach</code></td><td>At most one (none or one) of each of the listed subschemas.</td></tr>
</tbody></table>
</div>
<h1 id="copyright-20"><a class="header" href="#copyright-20">Copyright</a></h1>
<p>Copyright and related rights waived via <a href="https://creativecommons.org/publicdomain/zero/1.0/">CC0</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><pre>
tip: 22
title: IOTA Protocol Parameters
description: Describes the global protocol parameters for the IOTA protocol
author: Wolfgang Welz (@Wollac) <wolfgang.welz@iota.org>
discussions-to: https://github.com/iotaledger/tips/pull/43
status: Active
type: Standards
layer: Core
created: 2021-11-29
</pre>
<h1 id="summary-20"><a class="header" href="#summary-20">Summary</a></h1>
<p>This TIP describes the global protocol parameters for the IOTA protocol.</p>
<h1 id="motivation-19"><a class="header" href="#motivation-19">Motivation</a></h1>
<p>Various other protocol TIPs rely on certain constants that need to be defined for an actual implementations of nodes or other applications using the protocol. This TIP serves as a single document to provide these parameters. It also serves as a historical record of protocol parameter changes.</p>
<h1 id="detailed-design-18"><a class="header" href="#detailed-design-18">Detailed design</a></h1>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Value</th><th>Description</th></tr></thead><tbody>
<tr><td>Network Name</td><td>&quot;iota-mainnet&quot;</td><td>Identifier string of the network. Its hash it used for the <code>Network ID</code> field in transactions.</td></tr>
<tr><td>Protocol Version</td><td>2</td><td>Protocol version currently used by the network</td></tr>
<tr><td>Max Block Length</td><td>32768</td><td>Maximum length of a block in bytes. Limits Tangle storage size and communication costs.</td></tr>
<tr><td>Max Parents Count</td><td>8</td><td>Maximum number of parents of a block.</td></tr>
<tr><td>Min PoW Score</td><td>1500.0</td><td>Minimum PoW score for blocks to pass syntactic validation.</td></tr>
<tr><td>First Milestone Index</td><td>1</td><td>First valid milestone index.</td></tr>
<tr><td></td><td></td><td></td></tr>
<tr><td>Max IOTA Supply</td><td>4600000000000000</td><td>Total amount of IOTA coins in circulation.</td></tr>
<tr><td>Max Inputs Count</td><td>128</td><td>Maximum number of inputs in a transaction payload.</td></tr>
<tr><td>Max Outputs Count</td><td>128</td><td>Maximum number of outputs in a transaction payload.</td></tr>
<tr><td>Max Native Token Count</td><td>64</td><td>Maximum number of different native tokens that can be referenced in one transaction.</td></tr>
<tr><td></td><td></td><td></td></tr>
<tr><td>Max Tag Length</td><td>64</td><td>Maximum length of a <code>Tag</code> field in bytes.</td></tr>
<tr><td>Max Metadata Length</td><td>8192</td><td>Maximum length of a <code>Metadata</code> field in bytes.</td></tr>
<tr><td></td><td></td><td></td></tr>
<tr><td>VByte Cost</td><td>250</td><td>Minimum amount of IOTA that need to be deposited per vbyte of an output.</td></tr>
<tr><td></td><td></td><td></td></tr>
<tr><td>SLIP-44 Coin Type (decimal)</td><td>4218</td><td>Registered coin type (decimal) for usage in level 2 of <a href="https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki">BIP44</a> described in chapter &quot;Coin type&quot;.</td></tr>
<tr><td>SLIP-44 Path Component (<code>coin_type'</code>)</td><td>0x8000107a</td><td>Registered path component for usage in level 2 of <a href="https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki">BIP44</a> described in chapter &quot;Coin type&quot;.</td></tr>
<tr><td></td><td></td><td></td></tr>
<tr><td>Bech32 Human-Readable Part</td><td><code>iota</code></td><td>HRP prefix to use for Bech32 encoded IOTA addresses. (e.g. <code>iota1zzy3drvj6zugek60srqwhqctkjldx3qle5yuvapj</code>)</td></tr>
<tr><td>Bech32 Human-Readable Part (Test)</td><td><code>atoi</code></td><td>HRP prefix to use for Bech32 encoded IOTA addresses on test- or development networks. (e.g. <code>atoi1zzy3drvj6zugek60srqwhqctkjldx3qle5fhvhm6</code>)</td></tr>
</tbody></table>
</div>
<h1 id="rationale-for-parameter-choices"><a class="header" href="#rationale-for-parameter-choices">Rationale for parameter choices</a></h1>
<h2 id="transaction-and-block-limits"><a class="header" href="#transaction-and-block-limits">Transaction and block limits</a></h2>
<p>The block parameter <code>Max Block Length</code> and <code>Max Parent Count</code>, as well as the transaction parameters <code>Max Inputs Count</code>, <code>Max Outputs Count</code>, <code>Max Native Token Count</code>, <code>Max Tag Length</code> and <code>Max Metadata Length</code> govern the block and transaction validity. Their values have been chosen to ensure functionality of the protocol within constrained resource restrictions. Furthermore, choosing more conservatives values here is preferable as increasing such limits can always been done preserving backward compatibility.</p>
<h2 id="dust-protection"><a class="header" href="#dust-protection">Dust protection</a></h2>
<p>The <code>VByte Cost</code> is the core parameter of the dust protection. The reasoning behind its value is explained in <a href="tips/TIP-0022/../TIP-0019/tip-0019.html">TIP-19 Dust Protection</a>.</p>
<h1 id="copyright-21"><a class="header" href="#copyright-21">Copyright</a></h1>
<p>Copyright and related rights waived via <a href="https://creativecommons.org/publicdomain/zero/1.0/">CC0</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><pre>
tip: 23
title: Tagged Data Payload
description: Block payload for arbitrary data
author: Wolfgang Welz (@Wollac) <wolfgang.welz@iota.org>
discussions-to: https://github.com/iotaledger/tips/pull/54
status: Active
type: Standards
layer: Core
created: 2022-01-24
</pre>
<h1 id="abstract-1"><a class="header" href="#abstract-1">Abstract</a></h1>
<p>The payload concept offers a very flexible way to combine and encapsulate information in the IOTA protocol. This document proposes a basic payload type that allows the addition of arbitrary data.</p>
<h1 id="motivation-20"><a class="header" href="#motivation-20">Motivation</a></h1>
<p>The most flexible way to extend an existing object is by the addition of arbitrary data. This payload provides a way to do just that. An optional tag can be used to categorize the data.</p>
<h1 id="specification-1"><a class="header" href="#specification-1">Specification</a></h1>
<h2 id="serialized-layout-3"><a class="header" href="#serialized-layout-3">Serialized Layout</a></h2>
<p>The following table describes the serialization of a <em>Tagged Data Payload</em> following the notation from <a href="tips/TIP-0023/../TIP-0021/tip-0021.html">TIP-21</a>:</p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td>Payload Type</td><td>uint32</td><td>Set to <em>value 5</em> to denote an <em>Tagged Data Payload</em>.</td></tr>
<tr><td>Tag</td><td>(uint8)ByteArray</td><td>The tag of the data. A leading uint8 denotes its length.</td></tr>
<tr><td>Data</td><td>(uint32)ByteArray</td><td>Binary data. A leading uint32 denotes its length.</td></tr>
</tbody></table>
</div>
<p>It is important to note that <code>Tag</code> is not considered by the protocol, it just serves as a marker for second layer applications.</p>
<h2 id="syntactic-validation-2"><a class="header" href="#syntactic-validation-2">Syntactic Validation</a></h2>
<ul>
<li><code>length(Tag)</code> must not be larger than <a href="tips/TIP-0023/../TIP-0022/tip-0022.html"><code>Max Tag Length</code></a>.</li>
<li>Given the type and length information, the <em>Tagged Data Payload</em> must consume the entire byte array of the <code>Payload</code> field of the encapsulating object.</li>
</ul>
<h1 id="rationale-1"><a class="header" href="#rationale-1">Rationale</a></h1>
<p>As the tag is not considered by the protocol, it could also be removed completely. However, Legacy IOTA and Chrysalis supported sending of arbitrary data indexed with a tag. Thus, in order to simplify the migration of second layer applications using these protocols, the optional <code>Tag</code> has been added which can be used in a similar manner.</p>
<h1 id="copyright-22"><a class="header" href="#copyright-22">Copyright</a></h1>
<p>Copyright and related rights waived via <a href="https://creativecommons.org/publicdomain/zero/1.0/">CC0</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><pre>
tip: 24
title: Tangle Block
description: Generalization of the Tangle transaction concept
author: Wolfgang Welz (@Wollac) <wolfgang.welz@iota.org>
discussions-to: https://github.com/iotaledger/tips/pull/55
status: Active
type: Standards
layer: Core
replaces: 6
created: 2022-01-24
</pre>
<h1 id="abstract-2"><a class="header" href="#abstract-2">Abstract</a></h1>
<p>The Tangle is the graph data structure behind IOTA. In the legacy IOTA protocol, the vertices of the Tangle are represented by transactions. This document proposes an abstraction of this idea where the vertices are generalized <em>blocks</em>, which then contain the transactions or other structures that are processed by the IOTA protocol. Just as before, each block directly approves other blocks, which are known as <em>parents</em>.</p>
<p>The blocks can contain payloads. These are core payloads that will be processed by all nodes as part of the IOTA protocol. Some payloads may have other nested payloads embedded inside. Hence, parsing is done layer by layer.</p>
<h1 id="motivation-21"><a class="header" href="#motivation-21">Motivation</a></h1>
<p>To better understand this layered design, consider the Internet Protocol (IP), for example: There is an Ethernet frame that contains an IP payload. This in turn contains a TCP packet that encapsulates an HTTP payload. Each layer has a certain responsibility and once this responsibility is completed, we move on to the next layer.</p>
<p>The same is true with how blocks are parsed. The outer layer of the block enables the mapping of the block to a vertex in the Tangle and allows us to perform some basic validation. The next layer may be a transaction that mutates the ledger state, and one layer further may provide some extra functionality on the transactions to be used by applications.</p>
<p>By making it possible to add and exchange payloads, an architecture is being created that can easily be extended to accommodate future needs.</p>
<h1 id="specification-2"><a class="header" href="#specification-2">Specification</a></h1>
<h2 id="block-id"><a class="header" href="#block-id">Block ID</a></h2>
<p>The <em>Block ID</em> is the <a href="https://tools.ietf.org/html/rfc7693">BLAKE2b-256</a> hash of the entire serialized block.</p>
<h2 id="serialized-layout-4"><a class="header" href="#serialized-layout-4">Serialized Layout</a></h2>
<p>The following table describes the serialization of a <em>Block</em> following the notation from <a href="tips/TIP-0024/../TIP-0021/tip-0021.html">TIP-21</a>:</p>
<table>
  <tr>
    <th>Name</th>
    <th>Type</th>
    <th>Description</th>
  </tr>
  <tr>
    <td>Protocol Version</td>
    <td>uint8</td>
        <td> Protocol version number of the block.</td>
  </tr>
  <tr>
    <td>Parents Count</td>
    <td>uint8</td>
    <td>The number of blocks that are directly approved.</td>
  </tr>
  <tr>
    <td valign="top">Parents <code>anyOf</code></td>
    <td colspan="2">
      <details>
        <summary>Parent</summary>
        <blockquote>
          References another directly approved block.
        </blockquote>
        <table>
          <tr>
            <th>Name</th>
            <th>Type</th>
            <th>Description</th>
          </tr>
          <tr>
            <td>Block ID</td>
            <td>ByteArray[32]</td>
            <td>The Block ID of the parent.</td>
          </tr>
        </table>
      </details>
    </td>
  </tr>
  <tr>
    <td>Payload Length</td>
    <td>uint32</td>
    <td>The length of the following payload in bytes. A length of 0 means no payload will be attached.</td>
  </tr>
  <tr>
    <td valign="top">Payload <code>optOneOf</code></td>
    <td colspan="2">
      <details open="true">
        <summary>Generic Payload</summary>
        <blockquote>
          An outline of a generic payload
        </blockquote>
        <table>
          <tr>
            <th>Name</th>
            <th>Type</th>
            <th>Description</th>
          </tr>
          <tr>
            <td>Payload Type</td>
            <td>uint32</td>
            <td>
              The type of the payload. It will instruct the node how to parse the fields that follow.
            </td>
          </tr>
          <tr>
            <td>Data Fields</td>
            <td>ANY</td>
            <td>A sequence of fields, where the structure depends on <code>Payload Type</code>.</td>
          </tr>
        </table>
      </details>
    </td>
  </tr>
  <tr>
    <td>Nonce</td>
    <td>uint64</td>
    <td>The nonce which lets this block fulfill the PoW requirement.</td>
  </tr>
</table>
<h2 id="syntactic-validation-3"><a class="header" href="#syntactic-validation-3">Syntactic validation</a></h2>
<p>The Tangle can only contain syntactically valid blocks. Invalid blocks must be rejected by the node.
The following criteria defines whether the block passes the syntactic validation:</p>
<ul>
<li>The total length of the serialized block must not exceed <code>Max Block Length</code>.</li>
<li><code>Protocol Version</code> must match the <code>Protocol Version</code> config parameter of the node.</li>
<li>Parents:
<ul>
<li><code>Parents Count</code> must be at least 1 and not larger than <code>Max Parents Count</code>.</li>
<li><code>Parents</code> must be sorted in lexicographical order.</li>
<li>Each <code>Block ID</code> must be unique.</li>
</ul>
</li>
<li>Payload (if present):
<ul>
<li><code>Payload Type</code> must match one of the values described under <a href="tips/TIP-0024/tip-0024.html#payloads">Payloads</a>.</li>
<li><code>Data Fields</code> must be correctly parsable in the context of the <code>Payload Type</code>.</li>
<li>The payload itself must pass syntactic validation.</li>
</ul>
</li>
<li><code>Nonce</code> must be valid with respect to the PoW condition described under <a href="tips/TIP-0024/tip-0024.html#payloads">Payloads</a>. The PoW score itself is computed according to <a href="tips/TIP-0024/../TIP-0012/tip-0012.html">TIP-12</a>.</li>
<li>There must be no trailing bytes after all block fields have been parsed.</li>
</ul>
<h3 id="pow-validation"><a class="header" href="#pow-validation">PoW validation</a></h3>
<p>The PoW that needs to be performed for each block protects the network against denial-of-service attacks where in a short time too many blocks are issued for the nodes to process. As the processing time of a block heavily depends on the contained payload, the PoW check can also depend on the <code>Payload Type</code> and is described under <a href="tips/TIP-0024/tip-0024.html#payloads">Payloads</a>.
It is important to note, that the actual parsing and validating of a payload can be computationally expensive. Thus, it is recommended to first parse the block with all its fields including <code>Payload Type</code> (but not parsing or validating the actual payload <code>Data Fields</code>). Now, simple syntactic validation steps – including PoW validation – can be performed and invalid blocks already filtered out before the payload is validated. With this approach, payload-based PoW validation is not significantly more expensive than payload-agnostic validation.</p>
<h2 id="payloads-2"><a class="header" href="#payloads-2">Payloads</a></h2>
<p>While blocks without a payload, i.e. <code>Payload Length</code> set to zero, are valid, such blocks do not contain any information. As such, blocks usually contain a payload. The detailed specification of each payload type is out of scope of this TIP. The following table lists all currently specified payloads that can be part of a block and links to their specification:</p>
<div class="table-wrapper"><table><thead><tr><th>Payload Name</th><th>Type Value</th><th>TIP</th><th>PoW Condition</th></tr></thead><tbody>
<tr><td>No Payload</td><td>-</td><td>-</td><td>PoW score ≥ <code>Min PoW Score</code></td></tr>
<tr><td>Tagged Data</td><td>5</td><td><a href="tips/TIP-0024/../TIP-0023/tip-0023.html">TIP-23</a></td><td>PoW score ≥ <code>Min PoW Score</code></td></tr>
<tr><td>Transaction</td><td>6</td><td><a href="tips/TIP-0024/../TIP-0020/tip-0020.html">TIP-20</a></td><td>PoW score ≥ <code>Min PoW Score</code></td></tr>
<tr><td>Milestone</td><td>7</td><td><a href="tips/TIP-0024/../TIP-0029/tip-0029.html">TIP-29</a></td><td><code>nonce</code> = <code>0x0000000000000000</code></td></tr>
</tbody></table>
</div>
<h2 id="example-4"><a class="header" href="#example-4">Example</a></h2>
<p>Below is the full serialization of a valid block with a <em>Tagged Data Payload</em>. The tag is the &quot;IOTA&quot; ASCII string and the data is the &quot;hello world&quot; ASCII string. Bytes are expressed as hexadecimal numbers.</p>
<ul>
<li>Protocol Version (1-byte): <code>02</code> (2)</li>
<li>Parents Count (1-byte): <code>02</code> (2)</li>
<li>Parents (64-byte):
<ul>
<li><code>210fc7bb818639ac48a4c6afa2f1581a8b9525e20fda68927f2b2ff836f73578</code></li>
<li><code>db0fa54c29f7fd928d92ca43f193dee47f591549f597a811c8fa67ab031ebd9c</code></li>
</ul>
</li>
<li>Payload Length (4-byte): <code>18000000</code> (24)</li>
<li>Payload (24-byte):
<ul>
<li>Payload Type (4-byte): <code>05000000</code> (5)</li>
<li>Tag (5-byte):
<ul>
<li>Length (1-byte): <code>04</code> (4)</li>
<li>Tag (4-byte): <code>494f5441</code> (&quot;IOTA&quot;)</li>
</ul>
</li>
<li>Data (15-byte):
<ul>
<li>Length (4-byte): <code>0b000000</code> (11)</li>
<li>Data (11-byte): <code>68656c6c6f20776f726c64</code> (&quot;hello world&quot;)</li>
</ul>
</li>
</ul>
</li>
<li>Nonce (8-byte): <code>ce6d000000000000</code> (28110)</li>
</ul>
<h1 id="rationale-and-alternatives-15"><a class="header" href="#rationale-and-alternatives-15">Rationale and alternatives</a></h1>
<p>Instead of creating a layered approach, we could have simply created a flat transaction block that is tailored to mutate the ledger state, and try to fit all the use cases there. For example, with the tagged data use case, we could have filled some section of the transaction with that particular data. Then, this transaction would not correspond to a ledger mutation but instead only carry data.</p>
<p>This approach seems less extensible. It might have made sense if we had wanted to build a protocol that is just for ledger mutating transactions, but we want to be able to extend the protocol to do more than that.</p>
<h1 id="copyright-23"><a class="header" href="#copyright-23">Copyright</a></h1>
<p>Copyright and related rights waived via <a href="https://creativecommons.org/publicdomain/zero/1.0/">CC0</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><pre>
tip: 25
title: Core REST API
description: Node Core REST API routes and objects in OpenAPI Specification
author: Samuel Rufinatscha (@rufsam) <samuel.rufinatscha@iota.org>, Levente Pap (@lzpap) <levente.pap@iota.org>
discussions-to: https://github.com/iotaledger/tips/pull/27, https://github.com/iotaledger/tips/discussions/53, https://github.com/iotaledger/tips/pull/57
status: Active
type: Standards
layer: Interface
replaces: 13
created: 2022-01-26
</pre>
<h1 id="summary-21"><a class="header" href="#summary-21">Summary</a></h1>
<p>This document proposes the core REST API for nodes supporting the IOTA protocol.</p>
<h1 id="api-2"><a class="header" href="#api-2">API</a></h1>
<p>The API is described using the OpenAPI Specification:</p>
<p><a href="https://editor.swagger.io/?url=https://raw.githubusercontent.com/iotaledger/tips/main/tips/TIP-0025/core-rest-api.yaml">Swagger Editor</a></p>
<h1 id="copyright-24"><a class="header" href="#copyright-24">Copyright</a></h1>
<p>Copyright and related rights waived via <a href="https://creativecommons.org/publicdomain/zero/1.0/">CC0</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><pre>
tip: 26
title: UTXO Indexer API
description: UTXO Indexer REST API routes and objects in OpenAPI Specification
author: Levente Pap (@lzpap) <levente.pap@iota.org>
discussions-to: https://github.com/iotaledger/tips/pull/62, https://github.com/iotaledger/tips/discussions/53
status: Active
type: Standards
layer: Interface
created: 2022-01-27
</pre>
<h2 id="abstract-3"><a class="header" href="#abstract-3">Abstract</a></h2>
<p>The IOTA UTXO Indexer API defines the standard REST API interface that need to be fulfilled by indexer node plugins
or standalone indexer applications.</p>
<p>The purpose of the UTXO Indexer API is to:</p>
<ul>
<li>Provide access to structured, indexed records (outputs) of the UTXO ledger of the Tangle,</li>
<li>Support client queries on the structured data to fetch outputs of interest,</li>
<li>Offload network critical nodes from having to run the indexer application.</li>
</ul>
<h2 id="motivation-22"><a class="header" href="#motivation-22">Motivation</a></h2>
<p><a href="tips/TIP-0026/../TIP-0018/tip-0018.html">TIP-18</a> introduces new output types into the IOTA UTXO ledger. These new
outputs support a variety of new features such as different unlocking conditions and feature blocks.</p>
<p>The indexer API makes it possible for clients to retrieve outputs based on present features, furthermore to filter them
with more complex queries.</p>
<p>The main client application the API is designed for are wallets, but it does not mean that other applications could
not use or extend it.</p>
<h2 id="specification-3"><a class="header" href="#specification-3">Specification</a></h2>
<p>The API is described using the OpenAPI Specification:</p>
<p><a href="https://editor.swagger.io/?url=https://raw.githubusercontent.com/iotaledger/tips/main/tips/TIP-0026/indexer-rest-api.yaml">Swagger Editor</a></p>
<h2 id="rationale-2"><a class="header" href="#rationale-2">Rationale</a></h2>
<p><a href="https://github.com/iotaledger/tips/discussions/53">This discussion</a> gives a good overview of why the core and indexer
APIs are separated. In short, indexing the ledger is considered to be a L2 application, and as such, it is not a
mandatory part of IOTA core node implementations.</p>
<p>Alternatively, all indexing could be baked into the core software that would require us to factor in the &quot;cost&quot; of
indexing into byte cost of outputs, resulting in higher minimal dust deposit requirements. Network nodes that do not
interact with clients but are the backbone of the network would also have to perform indexing tasks for no reason.</p>
<p>The new architecture also opens up the door for developing more advanced indexing applications detached from node
implementations.</p>
<h2 id="backwards-compatibility-1"><a class="header" href="#backwards-compatibility-1">Backwards Compatibility</a></h2>
<p>Some routes from the previous REST API (<a href="tips/TIP-0026/../TIP-0013/tip-0013.html">TIP-13</a>) are removed and are supported in the new
indexer API. For more details, browse <a href="tips/TIP-0026/../TIP-0025/tip-0025.html">TIP-25</a>.</p>
<h2 id="reference-implementation-5"><a class="header" href="#reference-implementation-5">Reference Implementation</a></h2>
<p>Hornet reference implementation:</p>
<ul>
<li>https://github.com/gohornet/inx-indexer</li>
</ul>
<h2 id="copyright-25"><a class="header" href="#copyright-25">Copyright</a></h2>
<p>Copyright and related rights waived via <a href="https://creativecommons.org/publicdomain/zero/1.0/">CC0</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><pre>
tip: 27
title: IOTA NFT Standard IRC27
description: Define NFT standard and creator royalties
author: Adam Eunson (@AdamCroply) <adam@tanglelabs.io>, Merul Dhiman (@coodos) <merul@tanglelabs.io>
discussions-to: https://github.com/iotaledger/tips/discussions/59
status: Active
type: Standards
layer: IRC
created: 2022-03-04
</pre>
<h1 id="iota-nft-standard---irc27"><a class="header" href="#iota-nft-standard---irc27">IOTA NFT Standard - IRC27</a></h1>
<h2 id="abstract-4"><a class="header" href="#abstract-4">Abstract</a></h2>
<p><strong>IRC27</strong> is a series of standards to support interoperable and universal NFT systems throughout the IOTA ecosystem, to provide a more robust and secure system for creators and buyers.</p>
<h3 id="introduction"><a class="header" href="#introduction">Introduction</a></h3>
<p>This document aims to support a universal system that can provide dApp developers and creators with an interoperable foundation of standards to support ease-of-adoption and a connected NFT ecosystem. To bring value, security, trust, and interoperability.</p>
<p>Focusing on the primary use case for digital assets as NFTs, this defined standard supports key aspects in the creation, trade, and exchange of different assets with a focus on image, video, audio, and 3d asset file types.</p>
<p>To support an easy-to-implement system the IOTA NFT Standard supports:</p>
<ul>
<li><strong>Collection ID</strong> system should define NFT origins by issuerId and collectionId for authenticity and verification within the IOTA NFT space.</li>
<li><strong>Creator Royalty</strong> System that can support universal creator royalties throughout the ecosystem.</li>
<li><strong>NFT Schema Standard</strong> allowing for easily definable keys and values for ease-of-integration.</li>
<li><strong>Version Modelling</strong> to allow for easy updates as well as backwards compatibility.</li>
<li><strong>Modular System Design</strong> to provide developers freedom to utilise only required elements, as well as for future standards expansion beyond the existing standard model.</li>
</ul>
<p>The standard provides the foundation for future expansion, supporting a modular design to provide an opportunity for selective integration, as well as further use case expansion through additional modules as time goes by.</p>
<h2 id="motivation-23"><a class="header" href="#motivation-23">Motivation</a></h2>
<h3 id="why-iota-nft-standards"><a class="header" href="#why-iota-nft-standards">Why IOTA NFT Standards?</a></h3>
<p>Non-Standardised NFT systems have caused concerns and issues across a number of areas in other ecosystems. The lack of interoperable standards present numerous awkward and complicated experiences and in some ecosystems has resulted in countless verification and API issues that segment the NFT community.</p>
<p>Early safeguards are possible to put in place to support a more secure and interoperable ecosystem that puts creators and buyer security at the forefront, providing developers and dApp makers the grounds to build a more connected and consistent ecosystem.</p>
<p>With the IOTA Tokenization Framework in its infancy, the early adoption of an IOTA NFT Standard can support a safer, more secure environment for creators and dApp providers, to allow an easily interoperable experience through-out the IOTA ecosystem.</p>
<p>In this document we will present the IOTA NFT Standard - IRC27.</p>
<h2 id="specification-4"><a class="header" href="#specification-4">Specification</a></h2>
<h3 id="collection-id"><a class="header" href="#collection-id">Collection ID</a></h3>
<p>The IOTA Tokenization Framework allows for a unique and robust solution when defining the identity of a collection. The integration of such a system can support verification of the origins of the creation of an NFT. For example, an artist creating a collection of works that will be labelled under a single collection. This allows for ease of verification for buyers and 3rd party application developers to provide an easily observable system of authenticity for users navigating the IOTA NFT space.</p>
<p>The standard is defined utilising the creation mechanism for NFTs.</p>
<p><code>issuerId</code> (referred to as <a href="https://github.com/iotaledger/tips/pull/38">Issuer Block in TIP-18</a>) is already defined in the framework, allowing every NFT created from the same source to be easily defined.</p>
<p>Each NFT in the IOTA Tokenization Framework has its own unique address, that allows the ability to define a <strong>collection UTXO</strong> that can subsequently mint each unique NFT within that collection.</p>
<p>The <code>nftId</code> of a collection NFT is defined as the <code>collectionId</code>.</p>
<p>The <code>collectionId</code> will act as a unique identifier for the collection and would allow the <code>collectionNft</code> to control NFT creation in a collection. This allows for unprecedented amounts of control where you can lock NFT creation in a collection for some time. It also allows for the ability to transfer the <code>collectionNft</code> (parent NFT of all the NFTs minted within a collection) on transfer of which the new holder will be able to add NFTs to the collection, gaining control over ownership of the collection brand, but also with the ability to lock the collection by the destruction of the collection NFT.</p>
<p>A creator should define the UTXO of their collection NFT as the sole minting source of an entire collection that is the <code>collectionId</code>.</p>
<p>A creator may choose to burn the collection NFT on completion of minting or retain the collection NFT to add further NFTs to the collection over time.</p>
<p>The UTXO of the collection NFT, <code>nftId</code>, acts as the <code>collectionId</code> for the collection and can be used in dApps to define the verified origin of an NFT.</p>
<p>To call the defined <code>collectionId</code> you should request the <code>collectionId</code> UTXO of the collection NFT and resolve to the Collection Registry for human identifiable verification.</p>
<p>To better serve the ecosystem with a single point of record for registered collections one possible Public Token Registry is defined in <a href="https://github.com/iotaledger/tips/pull/72">IOTA Public Token Registry - TIP 33</a> where further reading can be found.</p>
<p>It is important to note that several token registries may coexist in the future, TIP-27 only defines the data structure of NFT metadata.It is up to the registry to decide what criteria and method to use to verify and accept submissions.</p>
<h3 id="creator-royalties"><a class="header" href="#creator-royalties">Creator Royalties</a></h3>
<p>A system to support interoperable royalty payments across dApps. Allowing universal secondary market reward systems to be integrated through-out the ecosystem. Integration of such systems is at the choosing of the dApp developer but is encouraged to support creator royalties.</p>
<p>Royalty addresses may be defined under the <code>royalties</code> key within the NFT metadata.</p>
<ul>
<li>The key inside the royalties object must be a valid iota1/smr1 address where royalties will be sent to.</li>
<li>The value must be a numeric decimal representative of the percentage required ie. 0.05=5%</li>
</ul>
<pre><code class="language-json">{
  ...
  &quot;royalties&quot;: {
    &quot;iota1...a&quot;: 0.05
  }
}
</code></pre>
<p>In the event there are further royalty, multiple royalty addresses could be used in the form of an object where the address and percentage are mapped in a key value format inside the <code>royalties</code> field.</p>
<pre><code class="language-json">{
  ...
  &quot;royalties&quot;: {
    &quot;iota1...a&quot;: 0.025,
    &quot;iota1...b&quot;: 0.025,
    &quot;iota1...c&quot;: 0.025,
    &quot;iota1...d&quot;: 0.025
  }
}
</code></pre>
<p>The total decimal sum of all <code>royaltyPercentage</code> must never exceed 1 and is recommended not to exceed 0.5.</p>
<p>If <code>royalties</code> exists, it is iterated over the keys and then all the royalties are paid out till there are no keys left to iterate over.</p>
<h3 id="nft-schema"><a class="header" href="#nft-schema">NFT Schema</a></h3>
<p>For ease of development and interoperability between applications within the ecosystem an extendable schema standard is defined to support ease of integration of NFTs for developers.</p>
<p>Each schema is defined by three main keys:</p>
<ul>
<li><code>standard</code> – the standard model</li>
<li><code>schema</code> – the defined schema type</li>
<li><code>version</code> – the version of the standard</li>
</ul>
<p><strong>Universal schema</strong>
Each NFT schema should consist of a collection of universal keys to define key properties of the NFT</p>
<p>The standard defined is:</p>
<ul>
<li><code>IRC27</code></li>
</ul>
<p>The schema type is defined as a <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types">MIME type</a>, for example:</p>
<ul>
<li>Image files: <code>image/jpeg</code>, <code>image/png</code>, <code>image/gif</code>, etc.</li>
<li>Video files: <code>video/x-msvideo</code> (avi), <code>video/mp4</code>, <code>video/mpeg</code>, etc.</li>
<li>Audio files: <code>audio/mpeg</code>, <code>audio/wav</code>, etc.</li>
<li>3D Assets: <code>model/obj</code>, <code>model/u3d</code>, etc.</li>
<li>Documents: <code>application/pdf</code>, <code>text/plain</code>, etc.</li>
</ul>
<p>You may find all common MIME types in <a href="https://www.iana.org/assignments/media-types/media-types.xhtml">IANA's registry</a>.
Custom file types might define their own MIME types.</p>
<p>The version is defined by the version number used preceded with the letter v, current version:</p>
<ul>
<li><code>v1.0</code></li>
</ul>
<p>Define the standard, the type, and the version:</p>
<pre><code class="language-json">
{
  &quot;standard&quot;: &quot;IRC27&quot;,
  &quot;type&quot;: &quot;image/jpeg&quot;,
  &quot;version&quot;: &quot;v1.0&quot;
}
</code></pre>
<p>Additional keys that must be included in every NFT schema:</p>
<ul>
<li><code>uri</code> – url pointing to the NFT file location with MIME type defined in <code>type</code>.</li>
<li><code>name</code> - alphanumeric text string defining the human identifiable name for the NFT</li>
</ul>
<pre><code class="language-json">{
  &quot;standard&quot;: &quot;IRC27&quot;,
  &quot;version&quot;: &quot;v1.0&quot;,
  &quot;type&quot;: &quot;image/jpeg&quot;,
  &quot;uri&quot;: &quot;https://mywebsite.com/my-nft-files-1.jpeg&quot;,
  &quot;name&quot;: &quot;My NFT #0001&quot;
}
</code></pre>
<p>Optional, but recommended keys, that may be included in NFT schema include:</p>
<ul>
<li><code>collectionName</code> – alphanumeric text string defining the human identifiable collection name</li>
<li><code>royalties</code> - Object containing key value pair where payment address mapped to the payout percentage</li>
<li><code>issuerName</code> – alphanumeric text string to define the human identifiable name of the creator</li>
<li><code>description</code> – alphanumeric text string to define a basic description of the NFT</li>
<li><code>attributes</code> - Array objects defining additional attributes of the NFT</li>
</ul>
<pre><code class="language-json">{
  &quot;standard&quot;: &quot;IRC27&quot;,
  &quot;version&quot;: &quot;v1.0&quot;,
  &quot;type&quot;: &quot;image/jpeg&quot;,
  &quot;uri&quot;: &quot;https://mywebsite.com/my-nft-files-1.jpeg&quot;,
  &quot;name&quot;: &quot;My NFT #0001&quot;,
  &quot;collectionName&quot;: &quot;My Collection of Art&quot;,
  &quot;royalties&quot;: {
    &quot;iota1...a&quot;: 0.025,
    &quot;iota1...b&quot;: 0.025
  },
  &quot;issuerName&quot;: &quot;My Artist Name&quot;,
  &quot;description&quot;: &quot;A little information about my NFT collection&quot;
}
</code></pre>
<p>In addition to the required and recommended schema, the inclusion of <code>attributes</code> allows for versatile expansion for NFT metadata.</p>
<p><code>attributes</code> are the attributes for the item, which will show up on dApps like NFT Marketplaces.</p>
<p>IRC27 NFT metadata follows the <a href="https://docs.opensea.io/docs/metadata-standards">OpenSea metadata standards</a>.</p>
<pre><code class="language-json">{
  &quot;standard&quot;: &quot;IRC27&quot;,
  &quot;version&quot;: &quot;v1.0&quot;,
  &quot;type&quot;: &quot;image/jpeg&quot;,
  &quot;uri&quot;: &quot;https://mywebsite.com/my-nft-files-1.jpeg&quot;,
  &quot;name&quot;: &quot;My NFT #0001&quot;,
  &quot;collectionName&quot;: &quot;My Collection of Art&quot;,
  &quot;royalties&quot;: {
    &quot;iota1...a&quot;: 0.025,
    &quot;iota1...b&quot;: 0.025
  },
  &quot;issuerName&quot;: &quot;My Artist Name&quot;,
  &quot;description&quot;: &quot;A little information about my NFT collection&quot;
  &quot;attributes&quot;: [
    {
      &quot;trait_type&quot;: &quot;Background&quot;,
      &quot;value&quot;: &quot;Purple&quot;
    },
    {
      &quot;trait_type&quot;: &quot;Element&quot;,
      &quot;value&quot;: &quot;Water&quot;
    },
    {
      &quot;trait_type&quot;: &quot;Attack&quot;,
      &quot;value&quot;: &quot;150&quot;
    },
    {
      &quot;trait_type&quot;: &quot;Health&quot;,
      &quot;value&quot;: &quot;500&quot;
    }
  ]
}
</code></pre>
<h2 id="practical-example"><a class="header" href="#practical-example">Practical example</a></h2>
<p>How does this all work for L1 NFT collections in the IOTA Tangle? Best to explain with an example.</p>
<p>In Stardust L1 NFTs are represented as outputs in the ledger. Each NFT output has the following properties:</p>
<ul>
<li>(mandatory) <code>nftId</code>: a unique identifier of the NFT output assigned by the protocol upon minting </li>
<li>(mandatory) <code>owner</code>: address in <em>Address Unlock Condition</em> that is allowed to unlock the NFT output</li>
<li>(optional) <code>immutableIssuer</code>: an address (can be alias/nft address too) that minted the NFT output</li>
<li>(optional) <code>immutableMetadata</code>: binary blob of data defined upon minting by the issuer</li>
<li>(optional) <code>sender</code>: defines an address that transferred the nft to the current owner</li>
<li>(optional) <code>mutableMetadata</code>: binary blob defined by the last sender</li>
</ul>
<p>To host metadata about the NFT, the <code>immutableMetadata</code> field of the output should be used, as the mutable one may be changed by the current owner.
Storing metadata in an output increases the storage deposit requirement of the output, but then no additional off-chain metadata storage solution is required.</p>
<p>NFTs may be standalone assets, but often they are part of a collection. In EVM based NFT platforms collections are represented as a single contract that manages the collection and keeps the ownership record of the NFTs within collection. Since L1 NFTs in IOTA are represented as UTXOs in the ledger rather than smart contracts, minting a collection is conceptually different.</p>
<h3 id="minting-l1-nft-collections"><a class="header" href="#minting-l1-nft-collections">Minting L1 NFT Collections</a></h3>
<p>The idea is to tie NFTs (individual UTXOs) within one collection together via the <code>immutableIssuer</code> property.
The collection itself is represented by a special NFT output, the <code>Collection NFT</code>. It holds information about the properties of the collection and when included in transactions, it can mint the NFTs within the collection where <code>immutableIssuer</code> becomes the <code>nftId</code> of the <code>Collection NFT</code>.</p>
<p>It is possible to timelock the <code>Collection NFT</code> on protocol level to prevent minting of the NFTs for a certain time period. It is also possible send the <code>Collection NFT</code> to the zero address, or burn it al together, which essentially means that the collection is locked forever, no more collection items can ever be minted.
It is not possible to define on protocol level how many items can the <code>Collection NFT</code> can mint, unless it is deposited into a L2 smart contract that manages issuer rights.</p>
<p>Let's look at a practical example on how the process looks like.</p>
<h3 id="1-minting-the-collection-nft"><a class="header" href="#1-minting-the-collection-nft">1. Minting the Collection NFT</a></h3>
<p>The issuer mints an NFT output on L1 with the following properties:</p>
<ul>
<li><code>nftId</code>: a unique identifier of the NFT output assigned by the protocol upon minting. This will become the <code>collectionId</code>.</li>
<li><code>immutableIssuer</code>: L1 address of the minting artist. Can be used to prove authenticity of the collection.</li>
<li><code>immutableMetadata</code>: binary blob of data defined upon minting by the issuer. This will become the <code>collectionMetadata</code>.</li>
</ul>
<p>The issuer of the <code>Collection NFT</code> defines the collection metadata according to IRC-27 standard. In our example, <code>collectionMetadata</code> is a JSON object:</p>
<pre><code class="language-json">{
  &quot;standard&quot;: &quot;IRC27&quot;,
  &quot;version&quot;: &quot;v1.0&quot;,
  &quot;type&quot;: &quot;text/html&quot;,
  &quot;uri&quot;: &quot;https://my-awesome-nft-project.com&quot;,
  &quot;name&quot;: &quot;My Awesome NFT Collection&quot;,
  &quot;issuerName&quot;: &quot;Me&quot;
}
</code></pre>
<ul>
<li>The binary blob of this JSON object is put in the <code>immutableMetadata</code> field of the NFT output.</li>
</ul>
<h3 id="2-minting-nfts-within-the-collection"><a class="header" href="#2-minting-nfts-within-the-collection">2. Minting NFTs within the collection</a></h3>
<p>The issuer includes the <code>Collection NFT</code> in a transaction that mints NFTs within the collection. The number of mintable NFTs in one transaction is defined by the protocol as the <a href="https://github.com/Wollac/protocol-rfcs/blob/protocol-parameters/tips/TIP-0022/tip-0022.md#detailed-design">Max Outputs Count defined in TIP-22</a> - 1 (the <code>Collection NFT</code> is also part of the outputs).</p>
<p>The minted NFTs will have the following properties:</p>
<ul>
<li><code>nftId</code>: the unique identifier of the NFT output assigned by the protocol upon minting.</li>
<li><code>immutableIssuer</code>: is set as <code>collectionId</code> of the <code>Collection NFT</code>. This unique value identifies which collection the NFT belongs to.</li>
<li><code>immutableMetadata</code>: metadata for the individual NFT. Binary blob of an IRC-27 compliant JSON object.</li>
</ul>
<p>For item 4 for example, the metadata is:</p>
<pre><code class="language-json">{
  &quot;standard&quot;: &quot;IRC27&quot;,
  &quot;version&quot;: &quot;v1.0&quot;,
  &quot;type&quot;: &quot;image/gif&quot;,
  &quot;uri&quot;: &quot;https://my-awesome-nft-project.com/item-4.gif&quot;,
  &quot;name&quot;: &quot;#4 My Awesome NFT&quot;,
  &quot;issuerName&quot;: &quot;Me&quot;,
  &quot;royalties&quot;: {
    &quot;smr1q5948....&quot;: 0.05
  },
  &quot;collectionName&quot;: &quot;My Awesome NFT Collection&quot;,
  &quot;attributes&quot;: [
    {
      &quot;trait_type&quot;: &quot;awesomeness&quot;,
      &quot;value&quot;: 60
    }
]
}
</code></pre>
<p>In case the metadata is not stored in the NFT output but is hosted off-chain, it is still recommended to include information in the <code>immutableMetadata</code> field such that clients are able to locate it. The <code>immutableMetadata</code> json object would look something like:</p>
<pre><code class="language-json">{
&quot;standard&quot;: &quot;IRC27&quot;,
&quot;version&quot;: &quot;v1.0&quot;,
&quot;type&quot;: &quot;application/json&quot;,
&quot;uri&quot;: &quot;https://my-awesome-nft-project.com/{id}.json&quot;,
&quot;name&quot;: &quot;#4 My Awesome NFT&quot;
}
</code></pre>
<ul>
<li>Note the {id} substitution in the <code>uri</code> field. Clients should replace <code>id</code> with the <code>nftId</code> property of the NFT output, without the <code>0x</code> prefix.</li>
</ul>
<h3 id="3-fetching-content-of-a-collection"><a class="header" href="#3-fetching-content-of-a-collection">3. Fetching content of a collection</a></h3>
<p>Since each NFT within the collection has the <code>immutableIssuer</code> set as the <code>collectionId</code>, it is possible to query the
UTXO Indexer API (<a href="https://github.com/iotaledger/tips/blob/indexer-api/tips/TIP-0026/tip-0026.md">TIP-26</a>) to get the outputIds for all
NFTs that belong to the collection. Then the output objects can be fetched via the Core API (<a href="https://github.com/iotaledger/tips/blob/stardust-api/tips/TIP-0025/tip-0025.md">TIP-25</a>):</p>
<ul>
<li>GET <code>&lt;node-url&gt;/api/indexer/v1/outputs/nft?issuer=collectionId</code> returns the outputIds that have <code>collectionId</code> in the <code>issuer</code> field.</li>
<li>GET <code>&lt;node-url&gt;/api/core/v2/outputs/{outputId}</code> returns the NFT output itself.</li>
</ul>
<p>The Collection NFT can be fetched via:</p>
<ul>
<li>GET <code>&lt;node-url&gt;/api/indexer/v1/outputs/nfts/{collectionId}</code> returns the outputId of the Collection NFT (if not burnt).</li>
<li>GET <code>&lt;node-url&gt;/api/core/v2/outputs/{outputId}</code> returns the Collection NFT output itself.</li>
</ul>
<h2 id="rationale-3"><a class="header" href="#rationale-3">Rationale</a></h2>
<h3 id="interoperable-standards"><a class="header" href="#interoperable-standards">Interoperable Standards</a></h3>
<p>For a unified IOTA NFT ecosystem the standards have been designed to support ease of integration and cross-compatibility of NFTs throughout the IOTA network. Observations of undefined standards in other ecosystems has illustrated the importance of such developments in the early stages of the technology. Simple defined keys such as <code>uri</code>, instead of <code>nftUrl</code> or <code>fileLocation</code> can support a much more interoperable experience for creators and dApp developers with everyone working from the same foundations.</p>
<p>Supporting creators is also a key element in driving adoption for the technology, royalty integrations vary substantially in other blockchain ecosystems which remains a challenge for both 3rd party applications and creators in sustaining a consistent and reliable ecosystem across different applications.</p>
<p>This standard also supports expansion, backwards compatibility, and a universal guideline for the ecosystem to develop with. Allowing an immediate interoperable environment that can support ease-of-adoption in the early stages of IOTA NFTs, whilst continually supporting feature expansion and future development.</p>
<h2 id="backwards-compatibility-2"><a class="header" href="#backwards-compatibility-2">Backwards Compatibility</a></h2>
<h3 id="versioning"><a class="header" href="#versioning">Versioning</a></h3>
<p>Expanding use-cases in the NFT space will present multiple requirements for different standards and schemas to be developed and over time alterations and updates will be presented to support an evolving technology and future developments.</p>
<p>Version is introduced from the start to allow dApp developers and creators to maintain backwards compatibility with differing versions of the standard, which can be defined as a numeric value proceeded with the letter v. All future versions will be submitted as separate TIPs.</p>
<p>Current version <code>v1.0</code></p>
<h3 id="modular-structure-expansion"><a class="header" href="#modular-structure-expansion">Modular Structure Expansion</a></h3>
<p>A modular structure to the standard has been created to support use case expansion, file type extension, standards catalogue. Allowing creators to utilise minimalist implementations as well as the more advanced expanded standards.</p>
<h2 id="copyright-26"><a class="header" href="#copyright-26">Copyright</a></h2>
<p>Copyright and related rights waived via <a href="https://creativecommons.org/publicdomain/zero/1.0/">CC0</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><pre>
tip: 28
title: Event API
description: Node event API definitions in AsyncAPI Specification
author: Luca Moser (@luca-moser) <luca.moser@iota.org>, Levente Pap (@lzpap) <levente.pap@iota.org>
discussions-to: https://github.com/iotaledger/tips/pull/33, https://github.com/iotaledger/tips/pull/66
status: Active
type: Standards
layer: Interface
created: 2022-03-02
replaces: 16
</pre>
<h2 id="abstract-5"><a class="header" href="#abstract-5">Abstract</a></h2>
<p>This proposal describes the <a href="https://mqtt.org/">MQTT</a> based Node Event API for IOTA nodes. Clients may subscribe to
topics provided by the node, that acts as the message publisher and broker at the same time.</p>
<h2 id="motivation-24"><a class="header" href="#motivation-24">Motivation</a></h2>
<p>The event API makes it possible for clients to implement event-based architectures as opposed to polling supported
by the REST API defined in <a href="tips/TIP-0028/../TIP-0025/tip-0025.html">draft TIP-25</a>.</p>
<p>The event-based architecture should be of great benefit to:</p>
<ul>
<li>wallets monitoring status of submitted blocks or transactions,</li>
<li>explorers displaying the evolution of the Tangle and ledger state,</li>
<li>archivers documenting the history of the Tangle.</li>
</ul>
<h2 id="specification-5"><a class="header" href="#specification-5">Specification</a></h2>
<p>The API is described using the AsyncAPI Specification:</p>
<p><a href="https://studio.asyncapi.com/?url=https://raw.githubusercontent.com/iotaledger/tips/main/tips/TIP-0028/event-api.yml">AsyncAPI Editor</a></p>
<h2 id="rationale-4"><a class="header" href="#rationale-4">Rationale</a></h2>
<ul>
<li>MQTT is a lightweight protocol that is good at minimizing bandwidth and ensuring message delivery via Quality of Service.</li>
<li>It may run on resource constrained devices as well and works on top of TCP/IP protocol.</li>
<li>The publish-subscribe model makes information dissemination effective to interested clients only.</li>
</ul>
<h2 id="backwards-compatibility-3"><a class="header" href="#backwards-compatibility-3">Backwards Compatibility</a></h2>
<p>The previously employed event API described in <a href="tips/TIP-0028/../TIP-0016/tip-0016.html">TIP-16</a> is not backwards compatible with the
current proposal, therefore versioning is introduced in the access URL of the API.</p>
<p>The response models are shared between the REST API and the event API.</p>
<p>The access route of the message broker should be updated to:</p>
<ul>
<li><code>{nodeURL}/api/mqtt/v1</code></li>
</ul>
<h2 id="reference-implementation-6"><a class="header" href="#reference-implementation-6">Reference Implementation</a></h2>
<h3 id="broker"><a class="header" href="#broker">Broker</a></h3>
<ul>
<li>https://github.com/gohornet/inx-mqtt</li>
</ul>
<h3 id="client"><a class="header" href="#client">Client</a></h3>
<ul>
<li>Go: https://github.com/iotaledger/iota.go/blob/develop/nodeclient/event_api_client.go</li>
<li>Rust: https://github.com/iotaledger/iota.rs/tree/develop/client/src/node_api/mqtt</li>
<li>TypeScript: https://github.com/iotaledger/iota.js/tree/feat/stardust/packages/mqtt</li>
</ul>
<h2 id="copyright-27"><a class="header" href="#copyright-27">Copyright</a></h2>
<p>Copyright and related rights waived via <a href="https://creativecommons.org/publicdomain/zero/1.0/">CC0</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><pre>
tip: 29
title: Milestone Payload
description: Coordinator issued milestone payload with Ed25519 authentication
author: Angelo Capossele (@capossele) <angelo.capossele@iota.org>, Wolfgang Welz (@Wollac) <wolfgang.welz@iota.org>
discussions-to: https://github.com/iotaledger/tips/pull/69
status: Active
type: Standards
layer: Core
created: 2022-03-25
replaces: 8
</pre>
<h1 id="abstract-6"><a class="header" href="#abstract-6">Abstract</a></h1>
<p>In IOTA, nodes use the milestones issued by the Coordinator to reach a consensus on which transactions are confirmed. This TIP proposes a milestone payload for the blocks described in the IOTA protocol <a href="tips/TIP-0029/../TIP-0024/tip-0024.html">TIP-24</a>. It uses Edwards-curve Digital Signature Algorithm (EdDSA) to authenticate the milestones.</p>
<h1 id="motivation-25"><a class="header" href="#motivation-25">Motivation</a></h1>
<p>In order to integrate the concept of milestones consistently into Tangle blocks, this TIP describes a dedicated payload type for milestones. In this context, the document also describes how Ed25519 signatures are used to assure authenticity of the issued milestones. In order to make the management and security of the used private keys easier, simple multisignature features with support for key rotation have been added.</p>
<h1 id="specification-6"><a class="header" href="#specification-6">Specification</a></h1>
<p>The <a href="https://tools.ietf.org/html/rfc7693">BLAKE2b-256</a> hash of the <em>Milestone Essence</em>, consisting of the actual milestone information (like its index number or position in the tangle), is signed using the Ed25519 signature scheme as described in the IRTF <a href="https://tools.ietf.org/html/rfc8032">RFC 8032</a>.</p>
<p>To increase the security of the design, a milestone can (optionally) be independently signed by multiple keys at once. These keys should be operated by detached signature provider services running on independent infrastructure elements. This assists in mitigating the risk of an attacker having access to all the key material necessary for forging milestones. While the Coordinator takes responsibility for forming Milestone Payload Blocks, it delegates signing in to these providers through an ad-hoc RPC connector. Mutual authentication should be enforced between the Coordinator and the signature providers: a <a href="https://en.wikipedia.org/wiki/Transport_Layer_Security#Client-authenticated_TLS_handshake">client-authenticated TLS handshake</a> scheme is advisable. To increase the flexibility of the mechanism, nodes can be configured to require a quorum of valid signatures to consider a milestone as genuine.</p>
<p>In addition, a key rotation policy can also be enforced by limiting key validity to certain milestone intervals. Accordingly, nodes need to know which public keys are applicable for which milestone index. This can be provided by configuring a list of entries consisting of the following fields:</p>
<ul>
<li><em>Index Range</em> providing the interval of milestone indices for which this entry is valid. The interval must not overlap with any other entry.</li>
<li><em>Applicable Public Keys</em> defining the set of valid public keys.</li>
<li><em>Signature Threshold</em> specifying the minimum number of valid signatures. Must be at least one and not greater than the number of <em>Applicable Public Keys</em>.</li>
</ul>
<h2 id="milestone-id"><a class="header" href="#milestone-id">Milestone ID</a></h2>
<p>The <em>Milestone ID</em> is the BLAKE2b-256 hash of the serialized <em>Milestone Essence</em>.
It is important to note that the signatures do not impact the <em>Milestone ID</em>.</p>
<h2 id="structure-4"><a class="header" href="#structure-4">Structure</a></h2>
<h3 id="serialized-layout-5"><a class="header" href="#serialized-layout-5">Serialized Layout</a></h3>
<p>All values are serialized in little-endian encoding. The serialized form of the milestone is deterministic, meaning the same logical milestone always results in the same serialized byte sequence.</p>
<p>The following table describes the entirety of a <em>Milestone Payload</em> in its serialized form following the notation from <a href="tips/TIP-0029/../TIP-0021/tip-0021.html">TIP-21</a>:</p>
<table>
  <tr>
    <th>Name</th>
    <th>Type</th>
    <th>Description</th>
  </tr>
  <tr>
    <td>Payload Type</td>
    <td>uint32</td>
    <td>Set to <strong>value 7</strong> to denote a <i>Milestone Payload</i>.</td>
  </tr>
  <tr>
    <td valign="top">Essence <code>oneOf</code></td>
    <td colspan="2">
      <details open="true">
        <summary>Milestone Essence</summary>
        <blockquote>Describes the signed part of a <i>Milestone Payload</i>.</blockquote>
        <table>
          <tr>
            <th>Name</th>
            <th>Type</th>
            <th>Description</th>
          </tr>
          <tr>
            <td>Index Number</td>
            <td>uint32</td>
            <td>The index number of the milestone.</td>
          </tr>
          <tr>
            <td>Timestamp</td>
            <td>uint32</td>
            <td>The Unix time (seconds since Unix epoch) at which the milestone was issued.</td>
          </tr>
          <tr>
            <td>Protocol Version</td>
            <td>uint8</td>
            <td>The protocol version of the Milestone Payload and its block.</td>
          </tr>
          <tr>
            <td>Previous Milestone ID</td>
            <td>ByteArray[32]</td>
            <td>The Milestone ID of the milestone with <code>Index Number - 1</code>.</td>
          </tr>
          <tr>
            <td>Parents Count</td>
            <td>uint8</td>
            <td>The number of parents referenced by this milestone.</td>
          </tr>
          <tr>
            <td valign="top">Parents <code>anyOf</code></td>
            <td colspan="2">
              <details>
                <summary>Parent</summary>
                <blockquote>A block that is directly referenced by this milestone.</blockquote>
                <table>
                  <tr>
                    <th>Name</th>
                    <th>Type</th>
                    <th>Description</th>
                  </tr>
                  <tr>
                    <td>Block ID</td>
                    <td>ByteArray[32]</td>
                    <td>The Block ID of the parent.</td>
                  </tr>
                </table>
              </details>
            </td>
          </tr>
          <tr>
            <td>Inclusion Merkle Root</td>
            <td>ByteArray[32]</td>
            <td>The Merkle tree hash (BLAKE2b-256) of the Block IDs of all blocks included by this milestone.</td>
          </tr>
          <tr>
            <td>Applied Merkle Root</td>
            <td>ByteArray[32]</td>
            <td>The Merkle tree hash (BLAKE2b-256) of the Block IDs of all blocks applied by this milestone that contain a state-mutating transaction¹</td>
          </tr>
          <tr>
            <td>Metadata</td>
            <td>(uint16)ByteArray</td>
            <td>Binary data only relevant to the milestone issuer, e.g. internal state. A leading uint16 denotes its length.</td>
          </tr>
          <tr>
            <td>Options Count</td>
            <td>uint8</td>
            <td>The number of milestone options following.</td>
          </tr>
          <tr>
            <td valign="top">Options <code>atMostOneOfEach</code></td>
            <td colspan="2">
              <details>
                <summary>Receipts Milestone Option</summary>
                <blockquote>Defines UTXOs for newly migrated funds.</blockquote>
              </details>              
              <details>
                <summary>Protocol Parameters Milestone Option</summary>
                <blockquote>Defines dynamic changes to the protocol parameters.</blockquote>
              </details>
            </td>
          </tr>
        </table>
      </details>
    </td>
  </tr>
  <tr>
    <td>Signatures Count</td>
    <td>uint8</td>
    <td>The number of signature entries following.</td>
  </tr>
  <tr>
    <td valign="top">Signatures <code>anyOf</code></td>
    <td colspan="2">
      <details open="true">
        <summary>Ed25519 Signature</summary>
        <table>
          <tr>
            <th>Name</th>
            <th>Type</th>
            <th>Description</th>
          </tr>
          <tr>
            <td>Signature Type</td>
            <td>uint8</td>
            <td>
              Set to <strong>value 0</strong> to denote an <i>Ed25519 Signature</i>.
            </td>
          </tr>
          <tr>
            <td>Public Key</td>
            <td>ByteArray[32]</td>
            <td>The Ed25519 public key of the signature.</td>
          </tr>
          <tr>
            <td>Signature</td>
            <td>ByteArray[64]</td>
            <td>The Ed25519 signature signing the BLAKE2b-256 hash of the serialized <i>Milestone Essence</i>.</td>
          </tr>
        </table>
      </details>
    </td>
  </tr>
</table>
<p>¹: See <a href="tips/TIP-0029/../TIP-0004/tip-0004.html">TIP-4</a>.</p>
<h3 id="milestone-options"><a class="header" href="#milestone-options">Milestone options</a></h3>
<p>The <code>Options</code> field holds additional data authenticated by the milestone.</p>
<p>The following table lists all the <code>Milestone Option Type</code> that are currently supported as well as links to the corresponding specification:</p>
<div class="table-wrapper"><table><thead><tr><th>Payload Name</th><th>Type Value</th><th>TIP</th></tr></thead><tbody>
<tr><td>Receipt</td><td>0</td><td><a href="tips/TIP-0029/../TIP-0034/tip-0034.html#receipt-milestone-option">TIP-34</a></td></tr>
<tr><td>Protocol Parameters</td><td>1</td><td><a href="tips/TIP-0029/tip-0029.html#protocol-parameters-milestone-option">TIP-29</a></td></tr>
</tbody></table>
</div>
<h4 id="protocol-parameters-milestone-option"><a class="header" href="#protocol-parameters-milestone-option">Protocol Parameters Milestone Option</a></h4>
<p>This <code>Milestone Option</code> is used to signal to nodes the commencing of new protocol parameters, including new protocol
version or PoW difficulty.</p>
<details>
  <summary>Protocol Parameters Milestone Option</summary>
  <blockquote>
    Defines changing protocol parameters.
  </blockquote>
</details>
<table>
    <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
    </tr>
    <tr>
        <td>Milestone Option Type</td>
        <td>uint8</td>
        <td>Set to <strong>value 1</strong> to denote a <i>Protocol Parameters Milestone Option</i>.</td>
    </tr>
    <tr>
        <td>Target Milestone Index</td>
        <td>uint32</td>
        <td>The milestone index at which these protocol parameters become active.</td>
    </tr>
    <tr>
        <td>Protocol Version</td>
        <td>uint8</td>
        <td>The to be applied protocol version.</td>
    </tr>
    <tr>
        <td>Parameters</td>
        <td>(uint16)ByteArray</td>
        <td>The protocol parameters in binary, serialized form.</td>
    </tr>
</table>
<h5 id="syntactic-validation-4"><a class="header" href="#syntactic-validation-4">Syntactic Validation</a></h5>
<ul>
<li><code>Target Milestone Index</code> must be greater than <code>Index Number</code> of the milestone it is contained in.</li>
<li><code>Target Milestone Index</code> must be less than or equal to <code>Index Number</code> + 30. (This value is fixed and technically not a protocol parameter as defined in <a href="tips/TIP-0029/../TIP-0022/tip-0022.html">TIP-22</a>, as it should not be subject to protocol parameter changes induced by this option.)</li>
<li><code>length(Parameters)</code> must not exceed <code>Max Metadata Length</code>.</li>
</ul>
<h2 id="milestone-validation-1"><a class="header" href="#milestone-validation-1">Milestone Validation</a></h2>
<p>Similar to transaction validation, milestone validation has been separated into two classes. For a milestone to be valid, both of them need to be true.</p>
<h3 id="syntactic-validation-5"><a class="header" href="#syntactic-validation-5">Syntactic validation</a></h3>
<p>Syntactic validation can be checked from the <em>Milestone Essence</em> plus the blocks in the past cone referenced by it.</p>
<ul>
<li>Essence:
<ul>
<li><code>Index Number</code> must not be smaller than <code>First Milestone Index</code>.</li>
<li>If <code>Index Number</code> equals <code>First Milestone Index</code>, the following fields must be zeroed out:
<ul>
<li><code>Previous Milestone ID</code></li>
<li><code>Inclusion Merkle Root</code></li>
<li><code>Applied Merkle Root</code></li>
</ul>
</li>
<li>If <code>Index Number</code> is greater than <code>First Milestone Index</code>, the milestone must reference (i.e. one of the <code>Parents</code> must contain or reference) another syntactically valid milestone whose <em>Milestone ID</em> matches <code>Previous Milestone ID</code>. With respect to that referenced milestone, the following must hold:
<ul>
<li><code>Index Number</code> must increment by <code>1</code>. </li>
<li><code>Timestamp</code> must be strictly larger (i.e. at least one second later).</li>
<li><code>Inclusion Merkle Root</code> must match the Merkle tree hash of the IDs of all blocks in <em>White Flag Ordering</em> (as described in <a href="tips/TIP-0029/../TIP-0002/tip-0002.html#deterministically-ordering-the-tangle">TIP-2</a>) that are newly referenced. (This always includes at least one valid milestone block with <code>Previous Milestone ID</code>.)</li>
<li><code>Applied Merkle Root</code> must match the Merkle tree hash of the not-ignored state-mutating transactions that are newly referenced (see <a href="tips/TIP-0029/../TIP-0002/tip-0002.html">TIP-2</a>).</li>
</ul>
</li>
<li><code>Parents</code> must match the <code>Parents</code> field of the encapsulating <em>Block</em>, i.e. the <em>Block</em> that contains the <em>Milestone Payload</em>.</li>
<li><code>length(Metadata)</code> must not exceed <code>Max Metadata Length</code>.</li>
<li>Options:
<ul>
<li><code>Milestone Option Type</code> must match one of the values described under <a href="tips/TIP-0029/tip-0029.html#milestone-options">Milestone Options</a>.</li>
<li>The option itself must pass syntactic validation.</li>
<li>The options must be sorted in ascending order based on their <code>Milestone Option Type</code>. </li>
</ul>
</li>
</ul>
</li>
<li>Signatures:
<ul>
<li><code>Signatures Count</code> must be at least the <em>Signature Threshold</em> and at most the number of <em>Applicable Public Keys</em> for the current milestone index.</li>
<li>For each signature block the following must be true:
<ul>
<li><code>Signature Type</code> value must denote an <code>Ed25519 Signature</code>.</li>
<li><code>Public Key</code> must be contained in <em>Applicable Public Keys</em> for the current milestone index.</li>
<li><code>Signature</code> must contain a valid signature for <code>Public Key</code>.</li>
</ul>
</li>
<li>The signature blocks must be sorted with respect to their <code>Public Key</code> in lexicographical order.</li>
<li>Each <code>Public Key</code> must be unique.</li>
</ul>
</li>
<li>Given the type and length information, the <em>Milestone Payload</em> must consume the entire byte array of the <code>Payload</code> field of the <em>Block</em>.</li>
</ul>
<h3 id="semantic-validation-2"><a class="header" href="#semantic-validation-2">Semantic validation</a></h3>
<p>Semantic validation is defined in the context of all available blocks.</p>
<ul>
<li>The milestone chain must not fork, i.e. there must not be two different, syntactically valid milestones with the same <code>Index Number</code>. In case of a fork, the correct state of the ledger cannot be derived from the milestones alone and usually the node implementation should alert the user and halt.</li>
</ul>
<h1 id="rationale-5"><a class="header" href="#rationale-5">Rationale</a></h1>
<ul>
<li>Due to the layered design of blocks and payloads, it is practically not possible to prevent reattachments of <em>Milestone Payloads</em>. Hence, this payload has been designed in a way to be independent from the block it is contained in. A milestone should be considered as a virtual marker (referencing <code>Parents</code>) rather than an actual block in the Tangle. This concept is compatible with reattachments and supports a cleaner separation of the block layers.</li>
<li>Forcing matching <code>Parents</code> in the <em>Milestone Payload</em> and its block makes it impossible to reattach the same payload at different positions in the Tangle. Strictly speaking, this violates the separation of payload and block. However, it simplifies milestone processing as the position of the block will be the same as the position encoded in the Milestone Payload. Having these clear structural properties seems to be more desirable than a strict separation of layers.</li>
<li>While it is always possible to cryptographically prove that a block was confirmed by a given milestone by supplying all the blocks of a path from the milestone to the block, such a proof can become rather large (depending on the blocks). To simplify such proof-of-inclusions, the <code>Inclusion Merkle Root</code> of all the included blocks has been added.</li>
</ul>
<h1 id="copyright-28"><a class="header" href="#copyright-28">Copyright</a></h1>
<p>Copyright and related rights waived via <a href="https://creativecommons.org/publicdomain/zero/1.0/">CC0</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><pre>
tip: 30
title: Native Token Metadata JSON Schema
description: A JSON schema that describes token metadata format for native token foundries.
author: Levente Pap @lzpap <levente.pap@iota.org>
discussions-to: https://github.com/iotaledger/tips/pull/68
status: Active
type: Standards
layer: IRC
created: 2022-03-25
requires: 18
</pre>
<h2 id="abstract-7"><a class="header" href="#abstract-7">Abstract</a></h2>
<p>This TIP describes a JSON schema to store native token metadata on-chain in foundry outputs.</p>
<h2 id="motivation-26"><a class="header" href="#motivation-26">Motivation</a></h2>
<p>By introducing a standardized token metadata schema we aim to address the following problems:</p>
<ul>
<li>Storing structured token metadata on-chain,</li>
<li>Interoperability of dApps, wallets and clients handling native tokens,</li>
<li>Creating the possibility of off-chain token verification based on social consensus.</li>
</ul>
<h2 id="specification-7"><a class="header" href="#specification-7">Specification</a></h2>
<p>Native tokens are user defined tokens controlled by foundries, as described in
<a href="tips/TIP-0030/../TIP-0018/tip-0018.html">TIP-18</a>. Each native token is identified by its 38 bytes long
<i>Token ID</i>, that also identifies the unique identifier of the foundry, <i>Foundry ID</i>.</p>
<p>Given <i>Foundry ID</i>, the most recent unspent foundry output controlling the supply of the native token can be
fetched via the UTXO indexer API defined in <a href="https://github.com/iotaledger/tips/pull/62">draft TIP 26</a>.</p>
<p>The foundry output may contain an immutable <i>Metadata Feature</i> that holds raw binary data. By encoding metadata in
JSON format adhering to the JSON schema defined in this TIP and placing it in the immutable <i>Metadata Feature</i> of
a foundry output, issuers can supply metadata to wallets, dApps and clients on-tangle, without the need for a
metadata server.</p>
<p>Standardizing the JSON schema for token metadata plays an important role in establishing interoperability of
decentralized applications and wallets.</p>
<h3 id="json-schema"><a class="header" href="#json-schema">JSON Schema</a></h3>
<p>The proposed JSON schema is located <a href="tips/TIP-0030/./irc30.schema.json">here</a>:</p>
<pre><code class="language-json">{
  &quot;$schema&quot;: &quot;https://json-schema.org/draft/2020-12/schema&quot;,
  &quot;$id&quot;: &quot;https://github.com/iotaledger/tips/main/tips/TIP-0030/irc30.schema.json&quot;,
  &quot;title&quot;: &quot;IRC30 Native Token Metadata Schema&quot;,
  &quot;description&quot;: &quot;A JSON schema for IRC30 compliant native token metadata&quot;,
  &quot;type&quot;: &quot;object&quot;,
  &quot;properties&quot;: {
    &quot;standard&quot;: {
      &quot;description&quot;: &quot;The IRC standard of the token metadata&quot;,
      &quot;type&quot;: &quot;string&quot;,
      &quot;pattern&quot;: &quot;^IRC30$&quot;
    },
    &quot;name&quot;: {
      &quot;description&quot;: &quot;The human-readable name of the native token&quot;,
      &quot;type&quot;: &quot;string&quot;
    },
    &quot;description&quot;: {
      &quot;description&quot;: &quot;The human-readable description of the token&quot;,
      &quot;type&quot;: &quot;string&quot;
    },
    &quot;symbol&quot;: {
      &quot;description&quot;: &quot;The symbol/ticker of the token&quot;,
      &quot;type&quot;: &quot;string&quot;
    },
    &quot;decimals&quot;: {
      &quot;description&quot;: &quot;Number of decimals the token uses (divide the token amount by 10^decimals to get its user representation)&quot;,
      &quot;type&quot;: &quot;integer&quot;,
      &quot;minimum&quot;: 0
    },
    &quot;url&quot;: {
      &quot;description&quot;: &quot;URL pointing to more resources about the token&quot;,
      &quot;type&quot;: &quot;string&quot;
    },
    &quot;logoUrl&quot;: {
      &quot;description&quot;: &quot;URL pointing to an image resource of the token logo&quot;,
      &quot;type&quot;: &quot;string&quot;
    },
    &quot;logo&quot;: {
      &quot;description&quot;: &quot;The svg logo of the token encoded as a byte string&quot;,
      &quot;type&quot;: &quot;string&quot;
    }
  },
  &quot;required&quot;: [
    &quot;standard&quot;,
    &quot;name&quot;,
    &quot;symbol&quot;,
    &quot;decimals&quot;
  ]
}
</code></pre>
<h3 id="examples-3"><a class="header" href="#examples-3">Examples</a></h3>
<p>The following examples are located in the <a href="https://github.com/iotaledger/tips/tree/main/tips/TIP-0030/examples"><code>examples/</code></a> folder.</p>
<p>To try the schema validation in Python, install <a href="https://python-jsonschema.readthedocs.io/en/stable/">jsonschema</a>
package by running:</p>
<pre><code class="language-bash">pip install jsonschema
</code></pre>
<p>Then navigate into the folder of this TIP (<code>tips/TIP-0030/</code>) of the cloned
<a href="https://github.com/iotaledger/tips">TIP repository</a> and run the validation in console:</p>
<pre><code class="language-bash">jsonschema -i examples/1-valid.json irc30.schema.json
</code></pre>
<p>If the validation fails, error messages are printed out to the console.</p>
<h4 id="1-a-minimum-valid-token-metadata-json"><a class="header" href="#1-a-minimum-valid-token-metadata-json">1. A minimum valid token metadata JSON</a></h4>
<pre><code class="language-json">{
  &quot;standard&quot;: &quot;IRC30&quot;,
  &quot;name&quot;: &quot;FooCoin&quot;,
  &quot;symbol&quot;: &quot;FOO&quot;,
  &quot;decimals&quot;: 3,
}
</code></pre>
<h4 id="2-a-more-descriptive-valid-token-metadata-json"><a class="header" href="#2-a-more-descriptive-valid-token-metadata-json">2. A more descriptive valid token metadata JSON</a></h4>
<pre><code class="language-json">{
  &quot;standard&quot;: &quot;IRC30&quot;,
  &quot;name&quot;: &quot;FooCoin&quot;,
  &quot;description&quot;: &quot;FooCoin is the utility and governance token of FooLand, a revolutionary protocol in the play-to-earn crypto gaming field.&quot;,
  &quot;symbol&quot;: &quot;FOO&quot;,
  &quot;decimals&quot;: 3,
  &quot;url&quot;: &quot;https://foocoin.io&quot;,
  &quot;logoUrl&quot;: &quot;https://ipfs.io/ipfs/QmR36VFfo1hH2RAwVs4zVJ5btkopGip5cW7ydY4jUQBrkR&quot;
}
</code></pre>
<h4 id="3-invalid-token-metadata"><a class="header" href="#3-invalid-token-metadata">3. Invalid token metadata</a></h4>
<pre><code class="language-json">{
  &quot;standard&quot;: &quot;IRC27&quot;,
  &quot;name&quot;: &quot;FooCoin&quot;,
  &quot;description&quot;: &quot;FooCoin is the utility and governance token of FooLand, a revolutionary protocol in the play-to-earn crypto gaming field.&quot;,
  &quot;decimals&quot;: 0.5
}
</code></pre>
<p>The metadata JSON is not a valid IRC30 token metadata JSON as:</p>
<ul>
<li>The <code>standard</code> field is not <code>IRC30</code></li>
<li><code>symbol</code> property is missing, although it is required, and</li>
<li><code>decimals</code> is not an integer.</li>
</ul>
<h2 id="rationale-6"><a class="header" href="#rationale-6">Rationale</a></h2>
<p>The main motive of this design is to allow interoperability of applications handling native tokens while also leaving
room for optional, non-required fields that might be needed for certain use-cases.</p>
<p>Alternatively, a non-standardized token metadata structure would lead to a fragmented application space and hence
worse developer and user experiences while interacting with the network.</p>
<h2 id="backwards-compatibility-4"><a class="header" href="#backwards-compatibility-4">Backwards Compatibility</a></h2>
<p>IRC30 aims to be a minimum standard that can be compatible with future token standards, as long as the few originally
required fields are respected.</p>
<h2 id="copyright-29"><a class="header" href="#copyright-29">Copyright</a></h2>
<p>Copyright and related rights waived via <a href="https://creativecommons.org/publicdomain/zero/1.0/">CC0</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><pre>
tip: 31
title: Bech32 Address Format
description: Extendable address format supporting various signature schemes and address types
author: Wolfgang Welz (@Wollac) <wolfgang.welz@iota.org>, Levente Pap (@lzpap) <levente.pap@iota.org>
discussions-to: https://github.com/iotaledger/tips/pull/20
status: Active
type: Standards
layer: Interface
created: 2022-04-04
replaces: 11
</pre>
<h1 id="summary-22"><a class="header" href="#summary-22">Summary</a></h1>
<p>This document proposes an extendable address format for the IOTA protocol supporting various signature schemes and address types. It relies on the <a href="https://github.com/bitcoin/bips/blob/master/bip-0173.mediawiki">Bech32</a> format to provide a compact, human-readable encoding with strong error correction guarantees.</p>
<h1 id="motivation-27"><a class="header" href="#motivation-27">Motivation</a></h1>
<p>With <a href="https://roadmap.iota.org/chrysalis">Chrysalis</a>, IOTA started using Ed25519 to generate digital signatures, in which addresses correspond to a BLAKE2b-256 hash. It is necessary to define a universal and extendable address format capable of encoding different types of addresses (introduced also in <a href="tips/TIP-0031/../TIP-0018/tip-0018.html">TIP-18</a>).</p>
<p>The legacy IOTA protocol (1.0, pre-Chrysalis) relies on Base27 addresses with a truncated Kerl checksum. However, both the character set and the checksum algorithm have limitations:</p>
<ul>
<li>Base27 is designed for ternary and is ill-suited for binary data.</li>
<li>The Kerl hash function also requires ternary input. Further, it is slow and provides no error-detection guarantees.</li>
<li>It does not support the addition of version or type information to distinguish between different kinds of addresses with the same length.</li>
</ul>
<p>All of these points are addressed in the Bech32 format introduced in <a href="https://github.com/bitcoin/bips/blob/master/bip-0173.mediawiki">BIP-0173</a>: In addition to the usage of the human-friendly Base32 encoding with an optimized character set, it implements a <a href="https://en.wikipedia.org/wiki/BCH_code">BCH code</a> that <em>guarantees detection</em> of any error affecting at most four characters and has less than a 1 in 10<sup>9</sup> chance of failing to detect more errors.</p>
<p>This TIP proposes a simple and extendable binary serialization for addresses of different types that is then Bech32 encoded to provide a unique appearance for human-facing applications such as wallets.</p>
<h1 id="detailed-design-19"><a class="header" href="#detailed-design-19">Detailed design</a></h1>
<h2 id="binary-serialization-1"><a class="header" href="#binary-serialization-1">Binary serialization</a></h2>
<p>The address format uses a simple serialization scheme which consists of two parts:</p>
<ul>
<li>The first byte describes the type of the address.</li>
<li>The remaining bytes contain the type-specific raw address bytes.</li>
</ul>
<p>Currently, only three kind of addresses are supported:</p>
<ul>
<li>Ed25519, where the address consists of the BLAKE2b-256 hash of the Ed25519 public key.</li>
<li>Alias, where the address consists of the BLAKE2b-256 hash of the <i>Output ID</i> (defined in <a href="tips/TIP-0031/../TIP-0020/tip-0020.html#utxo-input">TIP-0020</a>) that created the alias.</li>
<li>NFT, where the address consists of the BLAKE2b-256 hash of the <i>Output ID</i> (defined in <a href="tips/TIP-0031/../TIP-0020/tip-0020.html#utxo-input">TIP-0020</a>) that created the NFT.</li>
</ul>
<p>They are serialized as follows:</p>
<div class="table-wrapper"><table><thead><tr><th>Type</th><th>First byte</th><th>Address bytes</th></tr></thead><tbody>
<tr><td>Ed25519</td><td><code>0x00</code></td><td>32 bytes: The BLAKE2b-256 hash of the Ed25519 public key.</td></tr>
<tr><td>Alias</td><td><code>0x08</code></td><td>32 bytes: The BLAKE2b-256 hash of the <i>Output ID</i> that created the alias.</td></tr>
<tr><td>NFT</td><td><code>0x10</code></td><td>32 bytes: The BLAKE2b-256 hash of the <i>Output ID</i> that created the NFT.</td></tr>
</tbody></table>
</div>
<h2 id="bech32-for-human-readable-encoding-1"><a class="header" href="#bech32-for-human-readable-encoding-1">Bech32 for human-readable encoding</a></h2>
<p>The human-readable encoding of the address is Bech32 (as described in <a href="https://github.com/bitcoin/bips/blob/master/bip-0173.mediawiki">BIP-0173</a>). A Bech32 string is at most 90 characters long and consists of:</p>
<ul>
<li>The <strong>human-readable part</strong> (HRP), which conveys the protocol and distinguishes between the different networks. HRPs are registered in <a href="https://github.com/satoshilabs/slips/blob/master/slip-0173.md">SLIP-0173</a>:
<ul>
<li><code>iota</code> is the human-readable part for IOTA Mainnet addresses (IOTA tokens)</li>
<li><code>atoi</code> is the human-readable part for IOTA Testnet/Devnet addresses</li>
<li><code>smr</code> is the human-readable part for Shimmer network addresses (Shimmer tokens)</li>
<li><code>rms</code> is the human-readable part for Shimmer Testnet/Devnet addresses</li>
</ul>
</li>
<li>The <strong>separator</strong>, which is always <code>1</code>.</li>
<li>The <strong>data part</strong>, which consists of the Base32 encoded serialized address and the 6-character checksum.</li>
</ul>
<h2 id="examples-4"><a class="header" href="#examples-4">Examples</a></h2>
<ul>
<li>Ed25519 Address
<ul>
<li>Ed25519 public key (32-byte): <code>6f1581709bb7b1ef030d210db18e3b0ba1c776fba65d8cdaad05415142d189f8</code></li>
<li>BLAKE2b-256 hash (32-byte): <code>efdc112efe262b304bcf379b26c31bad029f616ee3ec4aa6345a366e4c9e43a3</code></li>
<li>serialized (33-byte): <code>00efdc112efe262b304bcf379b26c31bad029f616ee3ec4aa6345a366e4c9e43a3</code></li>
<li>Bech32 string:
<ul>
<li><strong>IOTA</strong> (64-char):<code>iota1qrhacyfwlcnzkvzteumekfkrrwks98mpdm37cj4xx3drvmjvnep6xqgyzyx</code></li>
<li><strong>IOTA Testnet</strong> (64-char): <code>atoi1qrhacyfwlcnzkvzteumekfkrrwks98mpdm37cj4xx3drvmjvnep6x8x4r7t</code></li>
<li><strong>Shimmer</strong> (63-char): <code>smr1qrhacyfwlcnzkvzteumekfkrrwks98mpdm37cj4xx3drvmjvnep6xhcazjh</code></li>
<li><strong>Shimmer Testnet</strong>: (63-char) <code>rms1qrhacyfwlcnzkvzteumekfkrrwks98mpdm37cj4xx3drvmjvnep6xrlkcfw</code></li>
</ul>
</li>
</ul>
</li>
<li>Alias Address
<ul>
<li><em>Output ID</em> (34-byte): <code>52fdfc072182654f163f5f0f9a621d729566c74d10037c4d7bbb0407d1e2c6490000</code></li>
<li><em>Alias ID</em>, BLAKE2b-256 hash (32-byte): <code>fe80c2eb7c736da2f7c98ecf135ee9e34e4e076afe6e1dfebc9ec578b8f56d2f</code></li>
<li>serialized (33-byte): <code>08fe80c2eb7c736da2f7c98ecf135ee9e34e4e076afe6e1dfebc9ec578b8f56d2f</code></li>
<li>Bech32 string:
<ul>
<li><strong>IOTA</strong> (64-char): <code>iota1prlgpsht03ekmghhex8v7y67a835uns8dtlxu807hj0v279c74kj76j6rev</code></li>
<li><strong>IOTA Testnet</strong> (64-char): <code>atoi1prlgpsht03ekmghhex8v7y67a835uns8dtlxu807hj0v279c74kj7autzrp</code></li>
<li><strong>Shimmer</strong> (63-char): <code>smr1prlgpsht03ekmghhex8v7y67a835uns8dtlxu807hj0v279c74kj7dzrr0a</code></li>
<li><strong>Shimmer Testnet</strong> (63-char): <code>rms1prlgpsht03ekmghhex8v7y67a835uns8dtlxu807hj0v279c74kj7e9ge5y</code></li>
</ul>
</li>
</ul>
</li>
<li>NFT Address
<ul>
<li><em>Output ID</em> (34-byte): <code>97b9d84d33419199483daab1f81ddccdeff478b6ee9040cfe026c517f67757880000</code></li>
<li><em>NFT ID</em>, BLAKE2b-256 hash (32-byte): <code>3159b115e27128b6db16db5e61f1aa4c70d84a99be753faa3ee70d9ad9c6a6b7</code></li>
<li>serialized (33-byte): <code>103159b115e27128b6db16db5e61f1aa4c70d84a99be753faa3ee70d9ad9c6a6b7</code></li>
<li>Bech32 string:
<ul>
<li><strong>IOTA</strong> (64-char): <code>iota1zqc4nvg4ufcj3dkmzmd4uc034fx8pkz2nxl820a28mnsmxkec6ntw0vklm7</code></li>
<li><strong>IOTA Testnet</strong> (64-char): <code>atoi1zqc4nvg4ufcj3dkmzmd4uc034fx8pkz2nxl820a28mnsmxkec6ntwgz87pn</code></li>
<li><strong>Shimmer</strong> (63-char): <code>smr1zqc4nvg4ufcj3dkmzmd4uc034fx8pkz2nxl820a28mnsmxkec6ntwcu0ld0</code></li>
<li><strong>Shimmer Testnet</strong> (63-char): <code>rms1zqc4nvg4ufcj3dkmzmd4uc034fx8pkz2nxl820a28mnsmxkec6ntwvmy9kk</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="drawbacks-14"><a class="header" href="#drawbacks-14">Drawbacks</a></h1>
<ul>
<li>Addresses look fundamentally different from the established 81-tryte legacy IOTA addresses. However, since the switch from binary to ternary and Chrysalis in general was a substantial change, this is a very reasonable and desired consequence.</li>
<li>A four character HRP plus one type byte only leaves a maximum of 48 bytes for the actual address.</li>
</ul>
<h1 id="rationale-and-alternatives-16"><a class="header" href="#rationale-and-alternatives-16">Rationale and alternatives</a></h1>
<ul>
<li>There are several ways to convert the binary serialization into a human-readable format, e.g. Base58 or hexadecimal. The Bech32 format, however, offers the best compromise between compactness and error correction guarantees. A more detailed motivation can be found in <a href="https://github.com/bitcoin/bips/blob/master/bip-0173.mediawiki#motivation">BIP-0173 Motivation</a>.</li>
<li>The binary serialization itself must be as compact as possible while still allowing you to distinguish between different address types of the same byte length. As such, the introduction of a version byte offers support for up to 256 different kinds of addresses at only the cost of one single byte.</li>
</ul>
<h1 id="reference-implementation-7"><a class="header" href="#reference-implementation-7">Reference implementation</a></h1>
<p>Example Go implementation in <a href="https://github.com/Wollac/iota-crypto-demo">wollac/iota-crypto-demo</a>:</p>
<ul>
<li>Bech32 encoding: <a href="https://github.com/Wollac/iota-crypto-demo/tree/master/pkg/bech32">pkg/bech32</a></li>
<li>Example: <a href="https://github.com/Wollac/iota-crypto-demo/tree/master/examples/bech32">examples/bech32</a></li>
</ul>
<p>Example Go implementation in <a href="https://github.com/iotaledger/iota.go/tree/v3">iotaledger/iota.go/v3</a>:</p>
<ul>
<li>Bech32 encoding: <a href="https://github.com/iotaledger/iota.go/tree/v3/bech32">bech32</a></li>
<li>Address implementations: <a href="https://github.com/iotaledger/iota.go/blob/v3/address_ed25519.go">Ed25519</a>, <a href="https://github.com/iotaledger/iota.go/blob/v3/address_alias.go">Alias</a>, <a href="https://github.com/iotaledger/iota.go/blob/v3/address_nft.go">NFT</a></li>
</ul>
<h1 id="copyright-30"><a class="header" href="#copyright-30">Copyright</a></h1>
<p>Copyright and related rights waived via <a href="https://creativecommons.org/publicdomain/zero/1.0/">CC0</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><pre>
tip: 32
title: Shimmer Protocol Parameters
description: Describes the global protocol parameters for the Shimmer protocol
author: Wolfgang Welz (@Wollac) <wolfgang.welz@iota.org>, Levente Pap (@lzpap) <levente.pap@iota.org>
discussions-to: https://github.com/iotaledger/tips/pull/71
status: Active
type: Standards
layer: Core
created: 2022-04-04
</pre>
<h1 id="summary-23"><a class="header" href="#summary-23">Summary</a></h1>
<p>This TIP describes the global protocol parameters for the Shimmer protocol.</p>
<h1 id="motivation-28"><a class="header" href="#motivation-28">Motivation</a></h1>
<p>Various other protocol TIPs rely on certain constants that need to be defined for an actual implementation of nodes or other applications using the protocol. This TIP serves as a single document to provide these parameters. It also serves as a historical record of protocol parameter changes.</p>
<h1 id="detailed-design-20"><a class="header" href="#detailed-design-20">Detailed design</a></h1>
<h2 id="shimmer-units"><a class="header" href="#shimmer-units">Shimmer Units</a></h2>
<p>The base token of the Shimmer Network is Shimmer (<code>SMR</code>). <code>SMR</code> token representation supports 6 decimal places, therefore the smallest possible value that may occur in the network is  10<sup>-6</sup> <code>SMR</code> = 0.000001 <code>SMR</code>. This indivisible amount is called a <code>glow</code>.</p>
<p>The concept of <code>glow</code> is analogous to <a href="https://en.bitcoin.it/wiki/Satoshi_(unit)"><code>satoshi</code> for <code>BTC</code></a>, or <a href="https://en.bitcoinwiki.org/wiki/WEI"><code>wei</code> for <code>ETH</code></a>.</p>
<div class="table-wrapper"><table><thead><tr><th>Amount in <code>glow</code></th><th>Amount in <code>SMR</code></th></tr></thead><tbody>
<tr><td>1 glow</td><td>0.000001 SMR</td></tr>
<tr><td>10 glow</td><td>0.00001 SMR</td></tr>
<tr><td>100 glow</td><td>0.0001 SMR</td></tr>
<tr><td>1,000 glow</td><td>0.001 SMR</td></tr>
<tr><td>10,000 glow</td><td>0.01 SMR</td></tr>
<tr><td>100,000 glow</td><td>0.1 SMR</td></tr>
<tr><td>1,000,000 glow</td><td>1 SMR</td></tr>
<tr><td>10,000,000 glow</td><td>10 SMR</td></tr>
<tr><td>100,000,000 glow</td><td>100 SMR</td></tr>
<tr><td>1,000,000,000 glow</td><td>1,000 SMR</td></tr>
<tr><td>10,000,000,000 glow</td><td>10,000 SMR</td></tr>
<tr><td>100,000,000,000 glow</td><td>100,000 SMR</td></tr>
<tr><td>1,000,000,000,000 glow</td><td>1,000,000 SMR</td></tr>
</tbody></table>
</div>
<p><strong>On protocol level, all token amounts are recorded in <code>glow</code>. <a href="tips/TIP-0032/../TIP-0018/tip-0018.html#output-design">Outputs</a>
of a <a href="tips/TIP-0032/../TIP-0020/tip-0020.html#structure">transaction</a> specify the
transfer amounts in <code>glow</code>. Graphical user interfaces of explorers, wallets and other tools are recommended to display
transfer amounts in <code>SMR</code> denomination.</strong></p>
<h2 id="genesis-supply"><a class="header" href="#genesis-supply">Genesis Supply</a></h2>
<p>The Shimmer genesis supply is allocated according to the following figure:</p>
<p><img src="tips/TIP-0032/genesis-supply.png" alt="" /></p>
<h3 id="iota-stakers---80"><a class="header" href="#iota-stakers---80">IOTA Stakers - 80%</a></h3>
<p>80% of the Shimmer genesis token supply has been distributed to IOTA token holders who staked their tokens to receive SMR during
the Shimmer staking event:</p>
<ul>
<li>Start date: Tuesday, December 28, 2021 3:00 PM CET (<a href="https://explorer.iota.org/mainnet/search/2102114">Milestone #2102114</a>)</li>
<li>End date: Monday, March 28, 2022 8:12 PM CET (<a href="https://explorer.iota.org/mainnet/search/2879714">Milestone #2879714</a>)</li>
<li><a href="https://github.com/iotaledger/participation-events/pull/2">Community-validated</a> results: https://github.com/iotaledger/participation-events/blob/master/results/staking/shimmer.json</li>
</ul>
<p><a href="https://raw.githubusercontent.com/iotaledger/participation-events/master/results/staking/shimmer.json">Rewards</a> are recorded in the base unit of the Shimmer network, <code>glow</code>. 1 <code>SMR</code> token equals 1,000,000 <code>glow</code>.</p>
<p>In total, <strong>1,450,896,407,249,092 <code>glow</code> (~1,450,896,407 <code>SMR</code>) is allocated to IOTA Stakers</strong> in the Shimmer genesis snapshot.</p>
<h3 id="shimmer-community-treasury-dao---10"><a class="header" href="#shimmer-community-treasury-dao---10">Shimmer Community Treasury (DAO) - 10%</a></h3>
<p>The IOTA community carried out an <a href="https://github.com/iotaledger/participation-events/blob/master/events/vote/shimmer_funding.json">on-chain vote</a> on the initial <a href="https://govern.iota.org/t/discussion-proposal-to-increase-the-shimmer-supply-for-a-community-treasury/1291">Shimmer Ecosystem Funding Proposal</a> and its <a href="https://govern.iota.org/t/discussion-follow-up-proposal-to-the-establishment-of-a-shimmer-ecosystem-fund/1315">follow-up proposal</a>.</p>
<p>The <a href="https://github.com/iotaledger/participation-events/pull/10/files">community-validated result</a> of the vote allocated 10% of the new total Shimmer supply to a Shimmer Community Treasury DAO.</p>
<p>As a consequence, the <strong>genesis Shimmer snapshot allocates 181,362,050,906,137 <code>glow</code> (~181,362,051 <code>SMR</code>) to the address of the Shimmer Community Treasury</strong>:</p>
<ul>
<li><strong>smr1qrmakyqt5ezm5k9c0sk39gwfavpktxkjmx0jvh9ejxjq6pr6d39egv2mvuc</strong></li>
</ul>
<h3 id="tangle-ecosystem-association-tea---10"><a class="header" href="#tangle-ecosystem-association-tea---10">Tangle Ecosystem Association (TEA) - 10%</a></h3>
<p>The Tangle Ecosystem Association was set up by the IOTA Foundation to host the new structure of the Ecosystem Development Fund and other ecosystem-focused activities.</p>
<p>The <a href="https://github.com/iotaledger/participation-events/pull/10/files">community-validated result</a> of the same <a href="https://github.com/iotaledger/participation-events/blob/master/events/vote/shimmer_funding.json">on-chain vote</a> on the initial <a href="https://govern.iota.org/t/discussion-proposal-to-increase-the-shimmer-supply-for-a-community-treasury/1291">Shimmer Ecosystem Funding Proposal</a> and its <a href="https://govern.iota.org/t/discussion-follow-up-proposal-to-the-establishment-of-a-shimmer-ecosystem-fund/1315">follow-up proposal</a> allocates 10% of the total Shimmer genesis supply to the Tangle Ecosystem Association.</p>
<p>As a consequence, the <strong>genesis Shimmer snapshot allocates 181,362,050,906,136 <code>glow</code> (~181,362,051 <code>SMR</code>) to the address of the Tangle Ecosystem Association</strong>:</p>
<ul>
<li><strong>smr1qpjva0y6qwjmv42dspw2se2776l5qr0r5p2s5m7nrg73qhvm6a6y7uvqxn6</strong></li>
</ul>
<h2 id="global-parameters"><a class="header" href="#global-parameters">Global Parameters</a></h2>
<ul>
<li>Dynamic parameters can be changed via fluid upgrades through <a href="https://github.com/iotaledger/tips/blob/milestone-with-signature-blocks/tips/TIP-0029/tip-0029.md#protocol-parameters-milestone-option">Milestone Announcement</a>.</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Value</th><th>Class</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td>Network Name</td><td>&quot;shimmer&quot;</td><td>dynamic</td><td>string</td><td>Identifier string of the network. Its hash it used for the <code>Network ID</code> field in transactions.</td></tr>
<tr><td>Protocol Version</td><td>2</td><td>dynamic</td><td>uint8</td><td>Protocol version currently used by the network.</td></tr>
<tr><td>Max Block Length</td><td>32768</td><td>dynamic</td><td>uint32</td><td>Maximum length of a block in bytes. Limits Tangle storage size and communication costs.</td></tr>
<tr><td>Max Parents Count</td><td>8</td><td>dynamic</td><td>uint32</td><td>Maximum number of parents of a block.</td></tr>
<tr><td>Min Parents Count</td><td>1</td><td>dynamic</td><td>uint32</td><td>Maximum number of parents of a block.</td></tr>
<tr><td>Min PoW Score</td><td>1500</td><td>dynamic</td><td>uint32</td><td>Minimum PoW score for blocks to pass syntactic validation.</td></tr>
<tr><td>Below Max Depth</td><td>15</td><td>dynamic</td><td>uint8</td><td>Below Max Depth is the maximum allowed delta value between Oldest Cone Root Index (OCRI) of a given block in relation to the current Confirmed Milestone Index (CMI) before it gets lazy.</td></tr>
<tr><td></td><td></td><td></td><td></td><td></td></tr>
<tr><td>Max Shimmer Genesis Supply</td><td>1813620509061365</td><td>static</td><td>uint64</td><td>Total amount of Shimmer genesis supply denominated in <code>glow</code>. 1 <code>glow</code> = 0.000001 <code>SMR</code></td></tr>
<tr><td>Max Inputs Count</td><td>128</td><td>dynamic</td><td>uint32</td><td>Maximum number of inputs in a transaction payload.</td></tr>
<tr><td>Max Outputs Count</td><td>128</td><td>dynamic</td><td>uint32</td><td>Maximum number of outputs in a transaction payload.</td></tr>
<tr><td>Max Native Token Count</td><td>64</td><td>dynamic</td><td>uint32</td><td>Maximum number of different native tokens that can be referenced in one transaction.</td></tr>
<tr><td></td><td></td><td></td><td></td><td></td></tr>
<tr><td>Max Tag Length</td><td>64</td><td>dynamic</td><td>uint8</td><td>Maximum length of a <code>Tag</code> field in bytes.</td></tr>
<tr><td>Max Metadata Length</td><td>8192</td><td>dynamic</td><td>uint16</td><td>Maximum length of a <code>Metadata</code> field in bytes.</td></tr>
<tr><td></td><td></td><td></td><td></td><td></td></tr>
<tr><td>VByte Cost</td><td>100</td><td>dynamic</td><td>uint32</td><td>Minimum amount of Shimmer (denominated in <code>glow</code>) that need to be deposited per vbyte of an output.</td></tr>
<tr><td>VByte Factor Data</td><td>1</td><td>dynamic</td><td>uint8</td><td>Weight of <code>data</code> fields that determines the relation between actual byte size and virtual byte size.</td></tr>
<tr><td>VByte Factor Key</td><td>10</td><td>dynamic</td><td>uint8</td><td>Weight of <code>key</code> fields that determines the relation between actual byte size and virtual byte size.</td></tr>
<tr><td></td><td></td><td></td><td></td><td></td></tr>
<tr><td>SLIP-44 Coin Type (decimal)</td><td>4219</td><td>static</td><td>uint32</td><td>Registered coin type (decimal) for usage in level 2 of <a href="https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki">BIP44</a> described in chapter &quot;Coin type&quot;.</td></tr>
<tr><td>SLIP-44 Path Component (<code>coin_type'</code>)</td><td>0x8000107b</td><td>static</td><td>string</td><td>Registered path component for usage in level 2 of <a href="https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki">BIP44</a> described in chapter &quot;Coin type&quot;.</td></tr>
<tr><td></td><td></td><td></td><td></td><td></td></tr>
<tr><td>Bech32 Human-Readable Part</td><td><code>smr</code></td><td>static</td><td>string</td><td>HRP prefix to use for Bech32 encoded Shimmer addresses. (e.g. <code>smr1qrhacyfwlcnzkvzteumekfkrrwks98mpdm37cj4xx3drvmjvnep6xhcazjh</code>)</td></tr>
<tr><td>Bech32 Human-Readable Part (Test)</td><td><code>rms</code></td><td>static</td><td>string</td><td>HRP prefix to use for Bech32 encoded Shimmer addresses on test- or development networks. (e.g. <code>rms1qrhacyfwlcnzkvzteumekfkrrwks98mpdm37cj4xx3drvmjvnep6xrlkcfw</code>)</td></tr>
</tbody></table>
</div>
<h1 id="rationale-for-parameter-choices-1"><a class="header" href="#rationale-for-parameter-choices-1">Rationale for parameter choices</a></h1>
<h2 id="proof-of-work"><a class="header" href="#proof-of-work">Proof-of-work</a></h2>
<p>Initially, <code>Min PoW Score</code> was chosen to roughly match the difficulty of a data transaction in the legacy IOTA protocol:</p>
<ul>
<li>The payload length (<code>signatureMessageFragment</code>) of a legacy transaction is 2187 trytes or 1100 - 1300 bytes depending on the encoding.</li>
<li>With a minimum weight magnitude (trailing zero trits) of 14, this corresponds to a PoW score of about 4000.</li>
</ul>
<p>The Stardust protocol debuts on Shimmer and as such, it is the first network capable of supporting L2 smart contract chains (ISC).
One possible bottleneck of smart contract chain performance is the time it takes to compute PoW for smart contract chain anchor
transactions, as these are typically bigger than the aforementioned legacy IOTA transaction size.</p>
<p>Accordingly, Shimmer lowers <code>Min PoW Score</code> to 1500 to ease the operation of smart contract chains and facilitate the
development of the L2 smart contract ecosystem. This value was chosen based on calculations with block sizes for smallest possible blocks (46 byte -&gt; minimum weight magnitude of 11) and typical ISC on-chain requests for chain deployment and chain deposits (~573 byte -&gt; minimum weight magnitude of 13).</p>
<h2 id="transaction-and-block-limits-1"><a class="header" href="#transaction-and-block-limits-1">Transaction and block limits</a></h2>
<p>The blocks parameters <code>Max Block Length</code> and <code>Max Parent Count</code>, as well as the transaction parameters <code>Max Inputs Count</code>, <code>Max Outputs Count</code>, <code>Max Native Token Count</code>, <code>Max Tag Length</code> and <code>Max Metadata Length</code> govern the block and transaction validity. Their values have been chosen to ensure functionality of the protocol within constrained resource restrictions. Furthermore, choosing more conservatives values here is preferable as increasing such limits can always been done preserving backward compatibility.</p>
<h2 id="dust-protection-1"><a class="header" href="#dust-protection-1">Dust protection</a></h2>
<p>The <code>VByte Cost</code> is the core parameter of the dust protection. The reasoning behind its value is explained in <a href="tips/TIP-0032/../TIP-0019/tip-0019.html">TIP-19 Dust Protection</a>.</p>
<h1 id="copyright-31"><a class="header" href="#copyright-31">Copyright</a></h1>
<p>Copyright and related rights waived via <a href="https://creativecommons.org/publicdomain/zero/1.0/">CC0</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><pre>
tip: 34
title: Wotsicide (Stardust)
description: Define migration from legacy W-OTS addresses to post-Chrysalis network
author: Luca Moser (@luca-moser) <luca.moser@iota.org>, Wolfgang Welz (@Wollac) <wolfgang.welz@iota.org>
discussions-to: https://github.com/iotaledger/tips/pull/74
status: Obsolete
type: Standards
layer: Core
created: 2022-04-21
replaces: 17
</pre>
<h1 id="abstract-8"><a class="header" href="#abstract-8">Abstract</a></h1>
<p>This TIP defines the migration process of funds using the legacy Winternitz one-time signature scheme (W-OTS) to the current network.</p>
<h1 id="motivation-29"><a class="header" href="#motivation-29">Motivation</a></h1>
<p>With Chrysalis, the IOTA protocol moved away from W-OTS as it created a number of security, protocol and UX issues:</p>
<ul>
<li>W-OTS signatures are big and make up a disproportionate amount of data of a transaction.</li>
<li>It is only safe to spend from an address <strong>once</strong>. Spending multiple times from the same address reveals random parts of the private key, making any subsequent transfers (other than the first) susceptible to thefts.</li>
<li>As a prevention mechanism to stop users from spending multiple times from the same address, nodes have to keep an ever growing list of those addresses.</li>
</ul>
<p>As the current protocol no longer supports W-OTS addresses, there needs to be a migration process from W-OTS addresses to Ed25519 addresses. To make this migration as smooth as possible, this TIP proposes a mechanism allowing users to migrate their funds at any time with only a small delay until they are available on the new network.</p>
<p>This TIP outlines the detailed architecture of how users will be able to migrate their funds and specifies the underlying components and their purposes.</p>
<h1 id="specification-8"><a class="header" href="#specification-8">Specification</a></h1>
<p>On a high-level the migration process works as follows:</p>
<ul>
<li>Users create migration bundles in the legacy network which target their Ed25519 address in the new network.</li>
<li>The Coordinator then mints those migrated funds in so-called <em>Receipt Milestone Option</em> which are placed within milestones on the new network.</li>
<li>Nodes in the new network evaluate receipts and book the corresponding funds by creating new UTXOs in the ledger.</li>
</ul>
<h2 id="legacy-network"><a class="header" href="#legacy-network">Legacy network</a></h2>
<h3 id="migration-bundle-1"><a class="header" href="#migration-bundle-1">Migration bundle</a></h3>
<p>The node software no longer books ledger mutations to non-migration addresses. This means that users are incentivized to migrate their funds as they want to use their tokens. See this document on what <a href="https://hackmd.io/@iota-protocol/rkO-r1qAv">migration addresses</a> are.</p>
<p>A migration bundle is defined as follows:</p>
<ul>
<li>It contains exactly one output transaction of which the destination address is a valid <a href="https://hackmd.io/@iota-protocol/rkO-r1qAv">migration address</a> and is positioned as the tail transaction within the bundle. The output transaction value is at least 1'000'000 tokens.</li>
<li>It does not contain any zero-value transactions which do not hold signature fragments. This means that transactions other than the tail transaction must always be part of an input.</li>
<li>Input transactions must not use migration addresses.</li>
</ul>
<p>The node will only use tail transactions of migration or milestone bundles for the tip-pool. This means that past cones referenced by a milestone will only include such bundles.</p>
<p>The legacy node software is updated with an additional HTTP API command called <code>getWhiteFlagConfirmation</code> which given request data in the following form:</p>
<pre><code class="language-json">{
    &quot;command&quot;: &quot;getWhiteFlagConfirmation&quot;,
    &quot;milestoneIndex&quot;: 1434593
}
</code></pre>
<p>returns data for the given milestone white-flag confirmation:</p>
<pre><code class="language-json">{
    &quot;milestoneBundle&quot;: [
        &quot;SDGKWKJAG...&quot;,
        &quot;WNGHJWIFA...&quot;,
        &quot;DSIEWSDIG...&quot;
    ],
    &quot;includedBundles&quot;: [
        [
            &quot;SKRGI9DFS...&quot;,
            &quot;NBJSKRJGW...&quot;,
            &quot;ITRUQORTZ...&quot;
        ],
        [
            &quot;OTIDFJKSD...&quot;,
            &quot;BNSUGRWER...&quot;,
            &quot;OPRGJSDFJ...&quot;
        ],
        ...
    ]
}
</code></pre>
<p>where <code>milestoneBundle</code> contains the milestone bundle trytes and <code>includedBundles</code> is an array of tryte arrays of included bundles in the same DFS order as the white-flag confirmation. Trytes within a bundle &quot;array&quot; are sorted from <code>currentIndex</code> = 0 ascending to the <code>lastIndex</code>.</p>
<p>This HTTP API command allows interested parties to verify which migration bundles were confirmed by a given milestone.</p>
<h3 id="milestone-inclusion-merkle-proof-1"><a class="header" href="#milestone-inclusion-merkle-proof-1">Milestone inclusion Merkle proof</a></h3>
<p>The Coordinator will only include migration bundles (respectively the tails of those bundles) in its inclusion Merkle proof. Nodes which do not run with the updated code will crash.</p>
<h3 id="preventing-non-migration-bundles-1"><a class="header" href="#preventing-non-migration-bundles-1">Preventing non-migration bundles</a></h3>
<p>As an additional measure to prevent users from submitting never confirming non-migration bundles (which would lead to key-reuse), nodes will no longer accept non-migration bundles in the HTTP API.</p>
<p>HTTP API level checks:</p>
<ul>
<li>The user must submit an entire migration bundle. No more single zero-value transactions, value-spam bundles etc. are allowed.</li>
<li>Input transactions are spending the entirety of the funds residing on the corresponding address. There must be more than 0 tokens on the given address.</li>
</ul>
<p>Wallet software must be updated to no longer support non-migration bundles.</p>
<p>There are no restrictions put in place on the gossip level, as it is too complex to prevent non-migration transactions to be filtered out, however, these transactions will never become part of a milestone cone.</p>
<h2 id="current-network"><a class="header" href="#current-network">Current network</a></h2>
<h3 id="receipt-milestone-option"><a class="header" href="#receipt-milestone-option">Receipt Milestone Option</a></h3>
<p>Each <em>Milestone Essence</em> as specified in <a href="tips/TIP-0034/../TIP-0029/tip-0029.html">TIP-29</a> can contain a <em>Receipt Milestone Option</em>. Receipts allow for fast migration of funds from the legacy into the new network.</p>
<h4 id="serialized-layout-6"><a class="header" href="#serialized-layout-6">Serialized layout</a></h4>
<p>The following table describes the entirety of a <em>Receipt Milestone Option</em> in its serialized form following the notation from <a href="tips/TIP-0034/../TIP-0021/tip-0021.html">TIP-21</a>:</p>
<table>
  <tr>
    <th>Name</th>
    <th>Type</th>
    <th>Description</th>
  </tr>
  <tr>
    <td>Milestone Option Type</td>
    <td>uint8</td>
    <td>Set to <strong>value 0</strong> to denote a <i>Receipt Milestone Option</i>.</td>
  </tr>
  <tr>
    <td>Migrated At</td>
    <td>uint32</td>
    <td>The index of the legacy milestone in which the listed funds were migrated at.</td>
  </tr>
  <tr>
    <td>Final</td>
    <td>uint8</td>
    <td>The value 1 indicates that this receipt is the last receipt for the given <i>Migrated At</i> index.</td>
  </tr>
  <tr>
    <td>Funds Count</td>
    <td>uint16</td>
    <td>Denotes how many migrated fund entries are within the receipt.</td>
  </tr>
  <tr>
    <td>Funds</td>
    <td colspan="2">
      <details open="true">
        <summary>Migrated Funds Entry</summary>
        <table>
          <tr>
            <th>Name</th>
            <th>Type</th>
            <th>Description</th>
          </tr>
          <tr>
            <td>Tail Transaction Hash</td>
            <td>ByteArray[49]</td>
            <td>The <code>t5b1</code> encoded tail transaction hash of the migration bundle.</td>
          </tr>
          <tr>
            <td valign="top">Address <code>oneOf</code></td>
            <td colspan="2">
              <details open="true">
                <summary>Ed25519 Address</summary>
                <table>
                  <tr>
                    <td><b>Name</b></td>
                    <td><b>Type</b></td>
                    <td><b>Description</b></td>
                  </tr>
                  <tr>
                    <td>Address Type</td>
                    <td>uint8</td>
                    <td>Set to <strong>value 0</strong> to denote an <i>Ed25519 Address</i>.</td>
                  </tr>
                  <tr>
                    <td>PubKeyHash</td>
                    <td>ByteArray[32]</td>
                    <td>The raw bytes of the Ed25519 address which is a BLAKE2b-256 hash of the Ed25519 public key.</td>
                  </tr>
                </table>
              </details>
            </td>
          </tr>
          <tr>
            <td>Amount</td>
            <td>uint64</td>
            <td>The amount which was migrated</td>
          </tr>
        </table>
      </details>
    </td>
  </tr>
  <tr>
    <td valign="top">Treasury <code>oneOf</code></td>
    <td colspan="2">
      <details>
        <summary>Treasury Transaction</summary>
      </details>
    </td>
  </tr>
</table>
<h4 id="validation-5"><a class="header" href="#validation-5">Validation</a></h4>
<h5 id="syntactic-validation-6"><a class="header" href="#syntactic-validation-6">Syntactic validation</a></h5>
<ul>
<li><code>Final</code> must be either 0 or 1.</li>
<li>Funds:
<ul>
<li><code>Funds Count</code> must be 0 &lt; x ≤ <code>Max Inputs Count</code>.</li>
<li>For each fund entry the following must be true:
<ul>
<li><code>Amount</code> must be at least 1'000'000.</li>
</ul>
</li>
<li>The fund entries must be sorted with respect to their <code>Tail Transaction Hash</code> in lexicographical order.</li>
<li>Each <code>Tail Transaction Hash</code> must be unique.</li>
</ul>
</li>
<li><code>Treasury</code> must be a syntactically valid <em>Treasury Transaction</em> as described in the <a href="tips/TIP-0034/tip-0034.html#treasury-transaction">Treasury Transaction</a> section.</li>
</ul>
<h5 id="semantic-validation-3"><a class="header" href="#semantic-validation-3">Semantic validation</a></h5>
<p>Semantic validation is checked with respect to the previous <em>Receipt Milestone Option</em>, i.e. the receipt whose Milestone's <code>Index Number</code> is the largest but still less than the current milestone.</p>
<ul>
<li><code>Migrated At</code> must not be smaller than in the previous receipt.</li>
<li>If the previous receipt has <code>Final</code> set to 1, <code>Migrated At</code> must be larger than the previous.</li>
<li>The <code>Amount</code> of the previous <code>Treasury Output</code> plus the sum of all <code>Amount</code> fields of the current <em>Migrated Funds Entries</em> must equal the <code>Amount</code> of the current <code>Treasury Output</code>.</li>
</ul>
<h5 id="legitimacy-of-migrated-funds-1"><a class="header" href="#legitimacy-of-migrated-funds-1">Legitimacy of migrated funds</a></h5>
<p>While the syntactic and semantic validation ensure that the receipt's integrity is correct, it does not actually tell whether the given funds were really migrated in the legacy network.</p>
<p>In order validate this criteria, the node software performs the following operations:</p>
<ol>
<li>The HTTP API of a legacy node is queried for the <code>Tail Transaction Hash</code> of each <em>Migrated Funds Entry</em>.</li>
<li>The node checks whether the <em>Migrated Funds Entry</em> matches the response from the legacy node.</li>
<li>Additionally, if the receipt's <code>Final</code> flag was set to 1, it is validated whether all funds for the given legacy milestone were migrated, i.e. whether for each <em>Migration Bundle</em> confirmed by that milestone there exists a <em>Migrated Funds Entry</em> in the current or a previous receipt.</li>
</ol>
<p>If the operation fails, the node software must gracefully terminate with an appropriate error message.</p>
<h3 id="treasury-transaction-1"><a class="header" href="#treasury-transaction-1">Treasury Transaction</a></h3>
<p>A <em>Treasury Transaction</em> contains a reference to the current <em>Treasury Output</em> (in the form of a <em>Treasury Input</em> object) and a <em>Treasury Output</em> which deposits the remainder.</p>
<p>The <em>Treasury Output</em> cannot be referenced or spent by transactions, it can only be referenced by receipts. It can be queried from the HTTP API and needs to be included within snapshots in order to keep the total supply intact.</p>
<p>The following table describes the entirety of a <em>Treasury Transaction</em> in its serialized form following the notation from <a href="tips/TIP-0034/../TIP-0021/tip-0021.html">TIP-21</a>:</p>
<table>
  <tr>
    <th>Name</th>
    <th>Type</th>
    <th>Description</th>
  </tr>
  <tr>
    <td>Input <code>oneOf</code></td>
    <td colspan="2">
      <details open="true">
        <summary>Treasury Input</summary>
        <blockquote>Equivalent to a normal <i>UTXO Input</i>, but instead of a transaction it references a milestone.</blockquote>
        <table>
          <tr>
            <th>Name</th>
            <th>Type</th>
            <th>Description</th>
          </tr>
          <tr>
            <td>Input Type</td>
            <td>uint8</td>
            <td>Set to <strong>value 1</strong> to denote an <i>Treasury Input</i>.</td>
          </tr>
          <tr>
            <td>Milestone ID</td>
            <td>ByteArray[32]</td>
            <td>The <i>Milestone ID</i> of the milestone that created the referenced <i>Treasury Output</i>.</td>
          </tr>
        </table>
      </details>
    </td>
  </tr>
  <tr>
    <td>Output <code>oneOf</code></td>
    <td colspan="2">
      <details open="true">
        <summary>Treasury Output</summary>
        <blockquote>Represents the treasury of the network, i.e. the not yet migrated funds.</blockquote>
        <table>
          <tr>
            <th>Name</th>
            <th>Type</th>
            <th>Description</th>
          </tr>
          <tr>
            <td>Output Type</td>
            <td>uint8</td>
            <td>Set to <strong>value 2</strong> to denote an <i>Treasury Output</i>.</td>
          </tr>
          <tr>
            <td>Amount</td>
            <td>uint64</td>
            <td>The amount of funds residing in the treasury.</td>
          </tr>
        </table>
      </details>
    </td>
  </tr>
</table>
<h3 id="booking-receipts-1"><a class="header" href="#booking-receipts-1">Booking receipts</a></h3>
<p>After successful receipt validation, the node software generates UTXOs in the following form: For each <em>Migrated Funds Entry</em> a <em>Basic Output</em> (see <a href="tips/TIP-0034/../TIP-0018/tip-0018.html">TIP-18</a>) is created with <code>Amount</code> matching the <code>Amount</code> field of the entry as well as a single <em>Address Unlock Condition</em> for the entry's <code>Address</code>. All other fields of the output are left empty.
Normally, the <em>Output ID</em> corresponds to <em>Transaction ID</em> plus <em>Output Index</em>. However, as for those migrated outputs there is no corresponding creating transaction, the <em>Milestone ID</em> of the encapsulating milestone is used as the <em>Transaction ID</em> part. In this case, the <em>Output Index</em> corresponds to the index of the corresponding <em>Migrated Funds Entry</em>.</p>
<p>All the generated <em>Basic Outputs</em> are then booked into the ledger and the new <em>Treasury Output</em> is persisted as an UTXO using the <em>Milestone ID</em> of the receipt which included the <em>Treasury Transaction</em> payload.</p>
<h1 id="rationale-7"><a class="header" href="#rationale-7">Rationale</a></h1>
<ul>
<li>At the current legacy network ledger size of 261446 entries (addresses with ≥ 1'000'000 tokens), it would take at least 2058 receipts to migrate all the funds. While theoretically the <em>Max Message Length</em> allows for more entries to be included in one receipt, the number is limited by the fact that the index of the <em>Migrated Funds Entry</em> is used to generate the <em>Output Index</em> of the generated output. As such, the maximum number of <em>Migrated Funds Entry</em> should also be limited by <code>Max Inputs Count</code></li>
<li>Assuming the best case scenario in which all 261446 entries are sent to migration addresses in the legacy network, these funds could therefore be migrated into the new network within ~5.7h (at a 10 second milestone interval). Of course, in practice users will migrate over time and the receipt mechanism will need to be in place as long as the new network runs.</li>
</ul>
<h1 id="copyright-32"><a class="header" href="#copyright-32">Copyright</a></h1>
<p>Copyright and related rights waived via <a href="https://creativecommons.org/publicdomain/zero/1.0/">CC0</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><pre>
tip: 35
title: Local Snapshot File Format
description: File format to export and import ledger state
author: Luca Moser (@luca-moser) <luca.moser@iota.org>, Max Hase (@muXxer) <maximilian.hase@iota.org>
discussions-to: https://github.com/iotaledger/tips/pull/25
status: Active
type: Standards
layer: Interface
created: 2022-05-06
replaces: 9
</pre>
<h1 id="summary-24"><a class="header" href="#summary-24">Summary</a></h1>
<p>This TIP defines a file format for local snapshots which is compatible with Stardust.
The version of the snapshot file format described in this TIP is <code>Version 2</code>.</p>
<h1 id="motivation-30"><a class="header" href="#motivation-30">Motivation</a></h1>
<p>Nodes create local snapshots to produce ledger representations at a point in time of a given milestone to be able to:</p>
<ul>
<li>Start up from a recent milestone instead of having to synchronize from the genesis transaction.</li>
<li>Delete old transaction data below a given milestone.</li>
</ul>
<p>For Stardust, this file format has to be assimilated to support protocol parameters and to contain the milestone
at the point of the snapshot index in order extract startup metadata from it.</p>
<h1 id="detailed-design-21"><a class="header" href="#detailed-design-21">Detailed design</a></h1>
<p>Since a UTXO based ledger is much larger in size, this TIP proposes two formats for snapshot files:</p>
<ul>
<li>A <code>full</code> format which represents a complete ledger state.</li>
<li>A <code>delta</code> format which only contains diffs (created and consumed outputs) of milestones from a given milestone index
onwards.</li>
</ul>
<p>This separation allows nodes to swiftly create new delta snapshot files, which then can be distributed with a companion
full snapshot file to reconstruct a recent state.</p>
<h3 id="formats-1"><a class="header" href="#formats-1">Formats</a></h3>
<blockquote>
<p>All types are serialized in little-endian</p>
</blockquote>
<h4 id="full-ledger-state-1"><a class="header" href="#full-ledger-state-1">Full Ledger State</a></h4>
<p>A full ledger snapshot file contains the UTXOs (<code>outputs</code> section) of a node's confirmed
milestone (<code>Ledger Milestone Index</code>). The <code>diffs</code> contain the diffs to rollback the <code>outputs</code> state to regain the ledger
state of the snapshot <code>Target Milestone Index</code>.</p>
<p><img src="tips/TIP-0035/full_snapshot.png" alt="" /></p>
<p>While the node producing such a full ledger state snapshot could theoretically pre-compute the actual snapshot milestone
state, this is deferred to the consumer of the data to speed up local snapshot creation.</p>
<h4 id="delta-ledger-state-1"><a class="header" href="#delta-ledger-state-1">Delta Ledger State</a></h4>
<p>A delta ledger state local snapshot only contains the <code>diffs</code> of milestones starting from a
given <code>Full Snapshot Target Milestone Index</code>. A node consuming such data must know the state of the ledger at <code>Full Snapshot Target Milestone Index</code>.</p>
<p><img src="tips/TIP-0035/delta_snapshot.png" alt="" /></p>
<h4 id="schema-2"><a class="header" href="#schema-2">Schema</a></h4>
<h5 id="output-1"><a class="header" href="#output-1">Output</a></h5>
<p>Defines an output.</p>
<table>
    <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
    </tr>
    <tr>
        <td>Output ID</td>
        <td>Array&lt;byte&gt;[34]</td>
        <td>The ID of the output which is a concatenation of the transaction ID + output index.</td>
    </tr>
    <tr>
        <td>Block ID</td>
        <td>Array&lt;byte&gt;[32]</td>
        <td>The ID of the Block in which the transaction was contained which generated this output.</td>
    </tr>
    <tr>
        <td>Milestone Index Booked</td>
        <td>uint32</td>
        <td>The milestone index at which this output was generated.</td>
    </tr>
    <tr>
        <td>Milestone Timestamp Booked</td>
        <td>uint32</td>
        <td>The UNIX timestamp in seconds of the milestone which produced this output.</td>
    </tr>
    <tr>
        <td>Output Length</td>
        <td>uint32</td>
        <td>Denotes the length of the output.</td>
    </tr>
    <tr>
        <td valign="top">Output <code>oneOf</code></td>
        <td colspan="2">
            <details>
                <summary>BasicOutput</summary>
            </details>
            <details>                                 
                <summary>AliasOutput</summary>
            </details>
            <details>                                 
                <summary>FoundryOutput</summary>
            </details>
            <details>                                 
                <summary>NFTOutput</summary>
            </details>
        </td>
    </tr>
</table>
<h5 id="consumed-output"><a class="header" href="#consumed-output">Consumed Output</a></h5>
<p>Defines a consumed output.</p>
<table>
    <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
    </tr>
    <tr>
        <td>Output</td>
        <td>Array&lt;byte&gt;[Output length]</td>
        <td>The serialized Output (see above).</td>
    </tr>
    <tr>
        <td>Target Transaction ID</td>
        <td>Array&lt;byte&gt;[32]</td>
        <td>The ID of the transaction that spent this output.</td>
    </tr>
</table>
<h5 id="milestone-diff-1"><a class="header" href="#milestone-diff-1">Milestone Diff</a></h5>
<p>Defines the diff a milestone produced by listing the created/consumed outputs and the milestone payload itself.</p>
<table>
    <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
    </tr>
    <tr>
        <td>Milestone Diff Length</td>
        <td>uint32</td>
        <td>Denotes the length of the milestone diff.</td>
    </tr>
    <tr>
        <td>Milestone Payload Length</td>
        <td>uint32</td>
        <td>Denotes the length of the milestone payload.</td>
    </tr>
    <tr>
        <td>Milestone Payload</td>
        <td>Array&lt;byte&gt;[Milestone Payload length]</td>
        <td>The milestone payload in its serialized binary form.</td>
    </tr>
    <tr>
        <td>
            Treasury Input
            <blockquote>
                only included if milestone contains a receipt
            </blockquote>
        </td>
        <td colspan="2">
            <table>
                <tr>
                    <th>Name</th>
                    <th>Type</th>
                    <th>Description</th>
                </tr>
                <tr>
                    <td>Treasury Input Milestone ID</td>
                    <td>Array&lt;byte&gt;[32]</td>
                    <td>The ID of the milestone this input references.</td>
                </tr>
                <tr>
                    <td>Treasury Input Amount</td>
                    <td>uint64</td>
                    <td>The amount of this treasury input.</td>
                </tr>
            </table>
        </td>
    </tr>
    <tr>
        <td>Created Outputs Count</td>
        <td>uint32</td>
        <td>The amount of outputs generated with this milestone diff.</td>
    </tr>
    <tr>
        <td valign="top">Created Outputs <code>anyOf</code></td>
        <td colspan="2">
            <details>
                <summary>Output</summary>
            </details>
        </td>
    </tr>
    <tr>
        <td>Consumed Outputs Count</td>
        <td>uint32</td>
        <td>The amount of outputs consumed with this milestone diff.</td>
    </tr>
    <tr>
        <td valign="top">Consumed Outputs <code>anyOf</code></td>
        <td colspan="2">
            <details>
                <summary>Consumed Output</summary>
            </details>
        </td>
    </tr>
</table>
<h5 id="protocol-parameters-milestone-option-1"><a class="header" href="#protocol-parameters-milestone-option-1">Protocol Parameters Milestone Option</a></h5>
<p>This Milestone Option is used to signal to nodes the commencing of new protocol parameters, including new protocol version or PoW difficulty.</p>
<table>
    <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
    </tr>
    <tr>
        <td>Milestone Option Type</td>
        <td>byte</td>
        <td>Set to value 1 to denote a Protocol Parameters Milestone Option.</td>
    </tr>
    <tr>
        <td>Target Milestone Index</td>
        <td>uint32</td>
        <td>Then name of the network from which this snapshot was generated from.</td>
    </tr>
    <tr>
        <td>Protocol Version</td>
        <td>byte</td>
        <td>The to be applied protocol version.</td>
    </tr>
    <tr>
        <td>Protocol Parameters</td>
        <td>(uint16)ByteArray</td>
        <td>The protocol parameters in binary, serialized form.</td>
    </tr>
</table>
<h5 id="protocol-parameters"><a class="header" href="#protocol-parameters">Protocol Parameters</a></h5>
<p>Defines protocol parameters.</p>
<table>
    <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
    </tr>
    <tr>
        <td>Protocol Version</td>
        <td>byte</td>
        <td>The version of the protocol.</td>
    </tr>
    <tr>
        <td>Network Name</td>
        <td>(uint8)string</td>
        <td>Then name of the network from which this snapshot was generated from.</td>
    </tr>
    <tr>
        <td>Bech32HRP</td>
        <td>(uint8)string</td>
        <td>The human-readable part of the addresses within the network.</td>
    </tr>
    <tr>
        <td>MinPoWScore</td>
        <td>uint32</td>
        <td>The minimum PoW score.</td>
    </tr>
    <tr>
        <td>BelowMaxDepth</td>
        <td>uint8</td>
        <td>The below max depth parameter.</td>
    </tr>
    <tr>
        <td>RentStructure</td>
        <td colspan="2">
            <table>
                <tr>
                    <th>Name</th>
                    <th>Type</th>
                    <th>Description</th>
                </tr>
                <tr>
                    <td>VByteCost</td>
                    <th>uint32</th>
                    <td>The token price per virtual byte</td>
                </tr>
                <tr>
                    <td>VBFactorData</td>
                    <th>uint8</th>
                    <td>The factor to use for data fields</td>
                </tr>
                <tr>
                    <td>VBFactorKey</td>
                    <th>uint8</th>
                    <td>The factor to use for indexed fields</td>
                </tr>
            </table>
        </td>
    </tr>
    <tr>
        <td>TokenSupply</td>
        <td>uint64</td>
        <td>The token supply.</td>
    </tr>
</table>
<h5 id="full-snapshot-file-format-1"><a class="header" href="#full-snapshot-file-format-1">Full snapshot file format</a></h5>
<p>Defines what a full snapshot file contains.</p>
<table>
    <tr>
        <td><b>Name</b></td>
        <td><b>Type</b></td>
        <td><b>Description</b></td>
    </tr>
    <tr>
        <td>Version</td>
        <td>byte</td>
        <td>Denotes the version of this file format. (Version 2)</td>
    </tr>
    <tr>
        <td>Type</td>
        <td>byte</td>
        <td>Denotes the type of this file format. <b>Value 0</b> denotes a full snapshot.</td>
    </tr>
    <tr>
        <td>Genesis Milestone Index</td>
        <td>uint32</td>
        <td>The index of the genesis milestone of the network.</td>
    </tr>
    <tr>
        <td>Target Milestone Index</td>
        <td>uint32</td>
        <td>The index of the milestone of which the SEPs within the snapshot are from.</td>
    </tr>
    <tr>
        <td>Target Milestone Timestamp</td>
        <td>uint32</td>
        <td>The UNIX timestamp in seconds of the milestone of which the SEPs within the snapshot are from.</td>
    </tr>
    <tr>
        <td>Target Milestone ID</td>
        <td>Array&lt;byte&gt;[32]</td>
        <td>The ID of the milestone of which the SEPs within the snapshot are from.</td>
    </tr>
    <tr>
        <td>Ledger Milestone Index</td>
        <td>uint32</td>
        <td>The index of the milestone of which the UTXOs within the snapshot are from.</td>
    </tr>
    <tr>
        <td>Treasury Output Milestone ID</td>
        <td>Array&lt;byte&gt;[32]</td>
        <td>The milestone ID of the milestone which generated the treasury output.</td>
    </tr>
    <tr>
        <td>Treasury Output Amount</td>
        <td>uint64</td>
        <td>The amount of funds residing on the treasury output.</td>
    </tr>
    <tr>
        <td>Protocol Parameters Milestone Option Length</td>
        <td>uint16</td>
        <td>Denotes the length of the Protocol Parameters Milestone Option.</td>
    </tr>
    <tr>
        <td valign="top">Protocol Parameters Milestone Option</td>
        <td colspan="2">
            <details>
                <summary>Protocol Parameters Milestone Option that is active at the milestone of which the UTXOs within the snapshot are from.</summary>
            </details>
        </td>
    </tr>
    <tr>
        <td>Outputs Count</td>
        <td>uint64</td>
        <td>The amount of UTXOs contained within this snapshot.</td>
    </tr>
    <tr>
        <td>Milestone Diffs Count</td>
        <td>uint32</td>
        <td>The amount of milestone diffs contained within this snapshot.</td>
    </tr>
    <tr>
        <td>SEPs Count</td>
        <td>uint16</td>
        <td>The amount of SEPs contained within this snapshot.</td>
    </tr>
    <tr>
        <td valign="top">Outputs</td>
        <td colspan="2">
            <details>
                <summary>Output</summary>
            </details>
        </td>
    </tr>
    <tr>
        <td valign="top">Milestone Diffs</td>
        <td colspan="2">
            <details>
                <summary>Milestone Diff</summary>
            </details>
        </td>
    </tr>
    <tr>
        <td valign="top">SEPs</td>
        <td colspan="2">
            <details>
                <summary>SEP Array[32]</summary>
            </details>
        </td>
    </tr>
</table>
<h5 id="delta-snapshot-file-format-1"><a class="header" href="#delta-snapshot-file-format-1">Delta snapshot file format</a></h5>
<p>Defines what a delta snapshot contains.</p>
<table>
    <tr>
        <td><b>Name</b></td>
        <td><b>Type</b></td>
        <td><b>Description</b></td>
    </tr>
    <tr>
        <td>Version</td>
        <td>byte</td>
        <td>Denotes the version of this file format. (Version 2)</td>
    </tr>
    <tr>
        <td>Type</td>
        <td>byte</td>
        <td>Denotes the type of this file format. <b>Value 1</b> denotes a delta snapshot.</td>
    </tr>
    <tr>
        <td>Target Milestone Index</td>
        <td>uint32</td>
        <td>The index of the milestone of which the SEPs within the snapshot are from.</td>
    </tr>
    <tr>
        <td>Target Milestone Timestamp</td>
        <td>uint32</td>
        <td>The UNIX timestamp in seconds of the milestone of which the SEPs within the snapshot are from.</td>
    </tr>
    <tr>
        <td>Full Snapshot Target Milestone ID</td>
        <td>Array&lt;byte&gt;[32]</td>
        <td>The ID of the target milestone of the full snapshot this delta snapshot builts up from.</td>
    </tr>
    <tr>
        <td>SEP File Offset</td>
        <td>uint64</td>
        <td>The file offset of the SEPs field. This is used to easily update an existing delta snapshot without parsing its content.</td>
    </tr>
    <tr>
        <td>Milestone Diffs Count</td>
        <td>uint32</td>
        <td>The amount of milestone diffs contained within this snapshot.</td>
    </tr>
    <tr>
        <td>SEPs Count</td>
        <td>uint16</td>
        <td>The amount of SEPs contained within this snapshot.</td>
    </tr>
    <tr>
        <td valign="top">Milestone Diffs</td>
        <td colspan="2">
            <details>
                <summary>Milestone Diff</summary>
            </details>
        </td>
    </tr>
    <tr>
        <td valign="top">SEPs</td>
        <td colspan="2">
            <details>
                <summary>SEP Array[32]</summary>
            </details>
        </td>
    </tr>
</table>
<h1 id="updating-an-existing-delta-snapshot-file"><a class="header" href="#updating-an-existing-delta-snapshot-file">Updating an existing Delta snapshot file</a></h1>
<p>When creating a delta snapshot, an existing delta snapshot file can be reused.</p>
<p>In order to do that, the following steps need to be done:</p>
<ol>
<li>Open the existing delta snapshot file.</li>
<li>Read the existing delta snapshot file header.</li>
<li>Verify that <code>Version</code> and <code>Full Snapshot Target Milestone ID</code> match between the existing and new delta snapshot.</li>
<li>Seek to the position of <code>Target Milestone Index</code> and replace it with the new value.</li>
<li>Seek to the position of <code>Target Milestone Timestamp</code> and replace it with the new value.</li>
<li>Seek to the position that is written in the existing <code>SEP File Offset</code> and truncate the file at this position.</li>
<li>Add the additional <code>Milestone Diffs</code> at this position.</li>
<li>Add the new <code>SEPs</code>.</li>
<li>Seek to the position of <code>SEP File Offset</code> and replace it with the new value.</li>
<li>Seek to the position of <code>Milestone Diffs Count</code> and replace it with the new value.</li>
<li>Seek to the position of <code>SEPs Count</code> and replace it with the new value.</li>
<li>Close the file.</li>
</ol>
<h1 id="drawbacks-15"><a class="header" href="#drawbacks-15">Drawbacks</a></h1>
<p>Nodes need to support this new format.</p>
<h1 id="rationale-and-alternatives-17"><a class="header" href="#rationale-and-alternatives-17">Rationale and alternatives</a></h1>
<ul>
<li>In conjunction with a companion full snapshot, a tool or node can &quot;truncate&quot; the data from a delta snapshot back to a
single full snapshot. In that case, the <code>Ledger Milestone Index</code> and <code>Target Milestone Index</code> would be the same. In the
example above, given the full and delta snapshots, one could produce a new full snapshot for milestone 1350.</li>
<li>Since snapshots may include millions of UTXOs, code generating such files needs to stream data directly onto disk
instead of keeping the entire representation in memory. In order to facilitate this, the count denotations for SEPs,
UTXOs and diffs are at the beginning of the file. This allows code generating snapshot files to only have to seek back
once after the actual count of elements is known.</li>
</ul>
<h1 id="copyright-33"><a class="header" href="#copyright-33">Copyright</a></h1>
<p>Copyright and related rights waived via <a href="https://creativecommons.org/publicdomain/zero/1.0/">CC0</a>.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>

<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>TIP-18 Multi-Asset Ledger and ISC Support - The Tangle Improvement Proposal (TIP) Book</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../../favicon.svg">
        <link rel="shortcut icon" href="../../favicon.png">
        <link rel="stylesheet" href="../../css/variables.css">
        <link rel="stylesheet" href="../../css/general.css">
        <link rel="stylesheet" href="../../css/chrome.css">
        <link rel="stylesheet" href="../../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../../highlight.css">
        <link rel="stylesheet" href="../../tomorrow-night.css">
        <link rel="stylesheet" href="../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../../introduction.html">Introduction</a></li><li class="chapter-item expanded "><a href="../../tips/TIP-0001/tip-0001.html">TIP-1 TIP Process</a></li><li class="chapter-item expanded "><a href="../../tips/TIP-0002/tip-0002.html">TIP-2 White Flag Ordering</a></li><li class="chapter-item expanded "><a href="../../tips/TIP-0003/tip-0003.html">TIP-3 Uniform Random Tip Selection</a></li><li class="chapter-item expanded "><a href="../../tips/TIP-0004/tip-0004.html">TIP-4 Milestone Merkle Validation</a></li><li class="chapter-item expanded "><a href="../../tips/TIP-0005/tip-0005.html">TIP-5 Binary To Ternary Encoding</a></li><li class="chapter-item expanded "><a href="../../tips/TIP-0006/tip-0006.html">TIP-6 Tangle Message</a></li><li class="chapter-item expanded "><a href="../../tips/TIP-0007/tip-0007.html">TIP-7 Transaction Payload</a></li><li class="chapter-item expanded "><a href="../../tips/TIP-0008/tip-0008.html">TIP-8 Milestone Payload</a></li><li class="chapter-item expanded "><a href="../../tips/TIP-0009/tip-0009.html">TIP-9 Local Snapshot File Format</a></li><li class="chapter-item expanded "><a href="../../tips/TIP-0010/tip-0010.html">TIP-10 Mnemonic Ternary Seed</a></li><li class="chapter-item expanded "><a href="../../tips/TIP-0011/tip-0011.html">TIP-11 Bech32 Address Format</a></li><li class="chapter-item expanded "><a href="../../tips/TIP-0012/tip-0012.html">TIP-12 Message PoW</a></li><li class="chapter-item expanded "><a href="../../tips/TIP-0013/tip-0013.html">TIP-13 REST API</a></li><li class="chapter-item expanded "><a href="../../tips/TIP-0014/tip-0014.html">TIP-14 Ed25519 Validation</a></li><li class="chapter-item expanded "><a href="../../tips/TIP-0015/tip-0015.html">TIP-15 Dust Protection</a></li><li class="chapter-item expanded "><a href="../../tips/TIP-0016/tip-0016.html">TIP-16 Event API</a></li><li class="chapter-item expanded "><a href="../../tips/TIP-0017/tip-0017.html">TIP-17 Wotsicide</a></li><li class="chapter-item expanded "><a href="../../tips/TIP-0018/tip-0018.html" class="active">TIP-18 Multi-Asset Ledger and ISC Support</a></li><li class="chapter-item expanded "><a href="../../tips/TIP-0019/tip-0019.html">TIP-19 Dust Protection Based on Byte Costs (Storage Deposit)</a></li><li class="chapter-item expanded "><a href="../../tips/TIP-0020/tip-0020.html">TIP-20 Transaction Payload with TIP-18 Output Types</a></li><li class="chapter-item expanded "><a href="../../tips/TIP-0021/tip-0021.html">TIP-21 Serialization Primitives</a></li><li class="chapter-item expanded "><a href="../../tips/TIP-0022/tip-0022.html">TIP-22 IOTA Protocol Parameters</a></li><li class="chapter-item expanded "><a href="../../tips/TIP-0023/tip-0023.html">TIP-23 Tagged Data Payload</a></li><li class="chapter-item expanded "><a href="../../tips/TIP-0024/tip-0024.html">TIP-24 Tangle Block</a></li><li class="chapter-item expanded "><a href="../../tips/TIP-0025/tip-0025.html">TIP-25 Core REST API</a></li><li class="chapter-item expanded "><a href="../../tips/TIP-0026/tip-0026.html">TIP-26 UTXO Indexer API</a></li><li class="chapter-item expanded "><a href="../../tips/TIP-0027/tip-0027.html">TIP-27 IOTA NFT Standard IRC27</a></li><li class="chapter-item expanded "><a href="../../tips/TIP-0028/tip-0028.html">TIP-28 Event API</a></li><li class="chapter-item expanded "><a href="../../tips/TIP-0029/tip-0029.html">TIP-29 Milestone Payload</a></li><li class="chapter-item expanded "><a href="../../tips/TIP-0030/tip-0030.html">TIP-30 Native Token Metadata JSON Schema</a></li><li class="chapter-item expanded "><a href="../../tips/TIP-0031/tip-0031.html">TIP-31 Bech32 Address Format</a></li><li class="chapter-item expanded "><a href="../../tips/TIP-0032/tip-0032.html">TIP-32 Shimmer Protocol Parameters</a></li><li class="chapter-item expanded "><a href="../../tips/TIP-0034/tip-0034.html">TIP-34 Wotsicide (Stardust)</a></li><li class="chapter-item expanded "><a href="../../tips/TIP-0035/tip-0035.html">TIP-35 Local Snapshot File Format</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Tangle Improvement Proposal (TIP) Book</h1>

                    <div class="right-buttons">
                        <a href="../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <pre>
tip: 18
title: Multi-Asset Ledger and ISC Support
description: Transform IOTA into a multi-asset ledger that supports running IOTA Smart Contracts
author: Levente Pap (@lzpap) <levente.pap@iota.org>
discussions-to: https://github.com/iotaledger/tips/pull/38
status: Active
type: Standards
layer: Core
created: 2021-11-04
requires: TIP-19, TIP-20, TIP-21 and TIP-22
</pre>
<h1 id="summary"><a class="header" href="#summary">Summary</a></h1>
<p>This document proposes new output types and transaction validation rules for the IOTA protocol to support <strong>native
tokenization</strong> and <strong>smart contract</strong> features.</p>
<p>Native tokenization refers to the capability of the IOTA ledger to <strong>track the ownership and transfer of user defined
tokens, so-called native tokens</strong>, thus making it a <strong>multi-asset ledger</strong>. The scalable and feeless nature of IOTA
makes it a prime candidate for tokenization use cases.</p>
<p>The <strong>IOTA Smart Contract Protocol (ISCP)</strong> is a <strong>layer 2 extension</strong> of the IOTA protocol that adds smart contract
features to the Tangle. Many so-called <strong>smart contract chains</strong>, which anchor their state to the base ledger, can be
run in parallel. Users wishing to interact with smart contract chains can send <strong>requests to layer 1 chain accounts
either as regular transactions or directly to the chain</strong>, but <strong>chains may also interact with other chains</strong> in a
trustless manner through the Tangle.</p>
<p>This TIP presents output types that realize the required new features:</p>
<ul>
<li>Smart contract chains have a new account type, called alias account, represented by an <strong>alias output.</strong></li>
<li>Requests to smart contract chains can be carried out using the configurable new output type called
<strong>basic output.</strong></li>
<li>Native tokens have their own <strong>supply control policy</strong> enforced by <strong>foundry outputs.</strong></li>
<li>Layer 1 native <strong>non-fungible tokens</strong> (unique tokens with attached metadata) are introduced via <strong>NFT outputs.</strong></li>
</ul>
<h1 id="motivation"><a class="header" href="#motivation">Motivation</a></h1>
<p>IOTA transitioned from an account based ledger model to an unspent transaction output (UTXO) model with the upgrade to
<a href="../TIP-0007/tip-0007.html">Chrysalis phase 2</a>. In this model, transactions explicitly
reference funds produced by previous transactions to be consumed. This property is desired for scalability: transaction
validation does not depend on the shared global state and, as such, transactions can be validated in parallel.
Double-spends can easily be detected as they spend the very same output more than once.</p>
<p>The UTXO model becomes even more powerful when unlocking criteria (validation) of outputs is extended as demonstrated
by the <a href="https://fc20.ifca.ai/wtsc/WTSC2020/WTSC20_paper_25.pdf">EUTXO model (Chakravarty et al., 2020)</a>: instead of
requiring only a valid signature for the output's address to unlock it, additional unlocking conditions can be
programmed into outputs. This programmability of outputs is the main idea behind the new output types presented in this
document.</p>
<p>Today, outputs in the IOTA protocol are designed for one specific use case: the single asset cryptocurrency. The aim of
this TIP is to design several output types for the use cases of:</p>
<ul>
<li>Native Tokenization Framework,</li>
<li>ISCP style smart contracts,</li>
<li>seamless interoperability between layer 1 and layer 2 tokenization concepts.</li>
</ul>
<p>Users will be able to mint their own native tokens directly in the base ledger, which can then be transferred without
any fees just like regular IOTA coins. Each native token has its own supply control policy enforced by the protocol.
These policies are transparent to all network participants. Issuers will be able to store metadata about their tokens
on-ledger, accessible to anyone.</p>
<p>Non-fungible tokens can be minted and transferred with zero fees. The validated issuers of such NFTs are immutably
attached to the tokens, making it impossible to counterfeit them.</p>
<p>Users will be able to interact with smart contracts by posting requests through the Tangle. Requests can carry commands
to smart contracts and can additionally also transfer native tokens and NFTs. By depositing native tokens to smart
contracts, their features can be greatly enhanced and programmed to specific use cases.</p>
<p>The proposal in this TIP not only makes it possible to transfer native tokens to layer 2 smart contracts, but tokens
that originate from layer 2 smart contract chains can also be wrapped into their respective layer 1 representation.
Smart contract chains may transfer tokens between themselves through this mechanism, and they can also post requests to
other chains.</p>
<p>Composability of smart contracts extends the realm of one smart contract chain, as smart contracts residing on
different chains can call each other in a trustless manner.</p>
<p>In conclusion, the IOTA protocol will become a scalable general purpose multi-asset DLT with the addition of smart
contracts and native tokenization frameworks. The transition is motivated by the ever-growing need for a scalable and
affordable decentralized application platform.</p>
<h1 id="detailed-design"><a class="header" href="#detailed-design">Detailed Design</a></h1>
<p>Outputs in the UTXO model are essential, core parts of the protocol. The new output types introduce new validation and
unlocking mechanisms, therefore the protocol needs to be adapted. The structure of the remaining sections is as follows:</p>
<ol>
<li><a href="#ledger-programmability">Introduction to ledger programmability</a></li>
<li><a href="#data-types--subschema-notation">Data types, subschemas and protocol constants</a></li>
<li><a href="#transaction-payload-changes">Transaction Payload changes compared to Chrysalis Part 2</a></li>
<li><a href="#new-concepts">New concepts of output design</a>
<ul>
<li><a href="#native-tokens-in-outputs">Native tokens</a></li>
<li><a href="#unlock-conditions">Unlock Conditions</a></li>
<li><a href="#features">Features</a></li>
<li><a href="#chain-constraint-in-utxo">Chain constraint</a></li>
</ul>
</li>
<li><a href="#output-design">Detailed design of new output types</a>
<ul>
<li><a href="#basic-output">Basic Output</a></li>
<li><a href="#alias-output">Alias Output</a></li>
<li><a href="#foundry-output">Foundry Output</a></li>
<li><a href="#nft-output">NFT Output</a></li>
</ul>
</li>
<li><a href="#unlocking-chain-script-locked-outputs">New unlocking mechanisms</a></li>
<li><a href="#drawbacks">Discussion</a></li>
</ol>
<h2 id="ledger-programmability"><a class="header" href="#ledger-programmability">Ledger Programmability</a></h2>
<p>The current UTXO model only provides support to transfer IOTA coins. However, the UTXO model presents a unique
opportunity to extend the range of possible applications by programming outputs.</p>
<p>Programming the base ledger of a DLT is not a new concept. Bitcoin uses the UTXO model and attaches small executables
(scripts) that need to be executed during transaction validation. The bitcoin script language is however not
<a href="https://en.wikipedia.org/wiki/Turing_completeness">Turing-complete</a> as it can only support a small set of instructions
that are executed in a stack based environment. As each validator has to execute the same scripts and arrive at the
same conclusion, such scripts must terminate very quickly. Also, as transaction validation happens in the context of
the transaction and block, the scripts have no access to the global shared state of the system (all unspent transaction
outputs).</p>
<p>The novelty of Ethereum was to achieve quasi Turing-completeness by employing an account based model and gas to limit
resource usage during program execution. As the amount of gas used per block is limited, only quasi Turing-completeness
can be achieved. The account based model of Ethereum makes it possible for transactions to have access to the global
shared state of the system, furthermore, transactions are executed one-after-the-other. These two properties make
Ethereum less scalable and susceptible to high transaction fees.</p>
<p>Cardano achieves UTXO programmability by using the EUTXO model. This makes it possible to represent smart contracts in
a UTXO model as state machines. In EUTXO, states of the machine are encoded in outputs, while state transition rules
are governed by scripts. Just like in bitcoin, these scripts may only use a limited set of instructions.</p>
<p>It would be quite straightforward to support EUTXO in IOTA too, except that IOTA transactions are feeless. There is no
reward to be paid out to validators for validating transactions, as all nodes in the network validate all transactions.
Due to the unique data structure of the Tangle, there is no need for miners to explicitly choose which transactions are
included in the ledger, but there still has to be a notion of objective validity of transactions. Since it is not
possible without fees to penalize scripts that consume excessive network resources (node CPU cycles) during transaction
validation, IOTA has to be overly restrictive about what instructions are supported on layer 1.</p>
<p>It must also be noted that UTXO scripts are finite state machines with the state space restricted by the output and
transaction validation rules. It makes expressiveness of UTXO scripts inherently limited. In the context of complicated
application logic required by use cases such as modern DeFi, this leads to unconventional and complicated architectures
of the application, consisting of many interacting finite state machines. Apart from complexity and UX costs, it also
has performance and scalability penalties.</p>
<p>For the reason mentioned above, <strong>IOTA chooses to support configurable yet hard-coded scripts for output and
transaction validation on layer 1.</strong> The general full-scale quasi Turing-complete programmability of the IOTA ledger is
achieved by extending the ledger state transition function with layer 2 smart contract chains. This not only makes it
possible to keep layer 1 scalable and feeless, but also allows to support any type of virtual machine on layer 2 to
program advanced business logic and features.</p>
<p>Below, several new output types are discussed that implement their own configurable script logic. They can be viewed as
UTXO state machines in which the state of the machine is encoded as data inside the output. The state transition rules
are defined by the output type and by the parameters chosen upon deployment.</p>
<h2 id="data-types--subschema-notation"><a class="header" href="#data-types--subschema-notation">Data Types &amp; Subschema Notation</a></h2>
<p>Data types and subschemas used throughout this TIP are defined in <a href="../TIP-0021/tip-0021.html">TIP-21</a>.</p>
<h2 id="global-protocol-parameters"><a class="header" href="#global-protocol-parameters">Global Protocol Parameters</a></h2>
<p>Global protocol parameters used throughout this TIP are defined in <a href="../TIP-0022/tip-0022.html">TIP-22 (IOTA)</a> and <a href="../TIP-0032/tip-0032.html">TIP-32 (Shimmer)</a>.</p>
<h2 id="transaction-payload-changes"><a class="header" href="#transaction-payload-changes">Transaction Payload Changes</a></h2>
<p>The new output types and unlocking mechanisms require new transaction validation rules, furthermore some protocol rules
have been modified compared to
Chrysalis Part 2 Transaction Payload <a href="../TIP-0007/tip-0007.html">TIP-7</a>.</p>
<p><a href="../TIP-0020/tip-0020.html">TIP-20</a> replaces aforementioned
TIP-7 with the new transaction layout and validation rules. The updated version is the basis for
output validation in this TIP.</p>
<h3 id="summary-of-changes"><a class="header" href="#summary-of-changes">Summary of Changes</a></h3>
<ul>
<li>Deprecating <i>SigLockedSingleOutput</i> and <i>SigLockedDustAllowanceOutput</i>.
<ul>
<li>The new dust protection mechanism does not need a distinct output type, therefore
<i>SigLockedDustAllowanceOutput</i> will be deprecated. One alternative is that during migration to the new
protocol version, all dust outputs sitting on an address will be merged into a <i>Basic Output</i> together
with their respective <i>SigLockedDustAllowanceOutputs</i> to create the snapshot for the updated protocol.
The exact migration strategy will be decided later.</li>
</ul>
</li>
<li>Adding new <a href="#output-design">output types</a> to <em>Transaction Payload</em>.</li>
<li>Adding new <a href="#unlocking-chain-script-locked-outputs">unlock types</a> to <em>Transaction Payload</em>.</li>
<li><i>Inputs</i> and <i>Outputs</i> of a transaction become a list instead of a set. Binary duplicate inputs are not
allowed as they anyway mean double-spends, but binary duplicate outputs are allowed.</li>
<li>There can be many outputs created to the same address in the transaction.</li>
<li>Confirming milestone supplies notion of time to semantic transaction validation.</li>
</ul>
<h2 id="new-concepts"><a class="header" href="#new-concepts">New Concepts</a></h2>
<p>New output types add new features to the protocol and hence new transaction validation rules. While some of these new
features are specifically tied to one output type, some are general, LEGO like building blocks that may be put in
several types of outputs.</p>
<p>Below is a summary of such new features and the validation rules they introduce.</p>
<h3 id="native-tokens-in-outputs"><a class="header" href="#native-tokens-in-outputs">Native Tokens in Outputs</a></h3>
<p>Outputs are records in the UTXO ledger that track ownership of funds. Thus, each output must be able to specify which
funds it holds. With the addition of the Native Tokenization Framework, outputs may also carry user defined native
tokens, that is, tokens that are not IOTA coins but were minted by foundries and are tracked in the very same ledger.
Therefore, <strong>every output must be able to hold not only IOTA coins, but also native tokens</strong>.</p>
<p>Dust protection applies to all outputs, therefore it is not possible for outputs to hold only native tokens, the
storage deposit requirements must be covered via IOTA coins.</p>
<p>User defined tokens are called <i>Native Tokens</i> on protocol level. The maximum supply of a particular native token
is defined by the representation chosen on protocol level for defining their amounts in outputs. Since native tokens
are also a vehicle to wrap layer 2 tokens into layer 1 tokens, the chosen representation must take into account the
maximum possible supply of layer 2 tokens. Solidity, the most popular smart contract language defines the
maximum supply of an ERC-20 token as <code>MaxUint256</code>, therefore it should be possible to represent such huge amount of
assets on layer 1.</p>
<p>Outputs must have the following fields to define the balance of native tokens they hold:</p>
<table>
    <tr>
        <td><b>Name</b></td>
        <td><b>Type</b></td>
        <td><b>Description</b></td>
    </tr>
    <tr>
        <td>Native Tokens Count</td>
        <td>uint8</td>
        <td>The number of native tokens present in the output.</td>
    </tr>
    <tr>
        <td valign="top">Native Tokens <code>optAnyOf</code></td>
        <td colspan="2">
            <details>
                <summary>Native Token</summary>
                <table>
                    <tr>
                        <td><b>Name</b></td>
                        <td><b>Type</b></td>
                        <td><b>Description</b></td>
                    </tr>
                    <tr>
                        <td>Token ID</td>
                        <td>ByteArray[38]</td>
                        <td>
                            Identifier of the native token. Derivation defined <a href='https://github.com/iotaledger/tips/blob/main/tips/TIP-0018/tip-0018.md#foundry-output'>here</a>.
                        </td>
                    </tr>
                    <tr>
                        <td>Amount</td>
                        <td>uint256</td>
                        <td>
                            Amount of tokens.
                        </td>
                    </tr>
                </table>
            </details>
        </td>
    </tr>
</table>
<h4 id="additional-syntactic-output-validation-rules"><a class="header" href="#additional-syntactic-output-validation-rules">Additional syntactic output validation rules:</a></h4>
<ul>
<li><code>Native Tokens</code> must be lexicographically sorted based on <code>Token ID</code>.</li>
<li>Each <i>Native Token</i> must be unique in the set of <code>Native Tokens</code> based on its <code>Token ID</code>. No duplicates are
allowed.</li>
<li><code>Amount</code> of any <i>Native Token</i> must not be <code>0</code>.</li>
</ul>
<h4 id="additional-semantic-transaction-validation-rules"><a class="header" href="#additional-semantic-transaction-validation-rules">Additional semantic transaction validation rules:</a></h4>
<ul>
<li>The transaction is balanced in terms of native tokens, that is, the sum of native token balances in consumed outputs
equals that of the created outputs.</li>
<li>When the transaction is <strong>imbalanced</strong> and there is a surplus of native tokens on the:
<ul>
<li><strong>output side of the transaction:</strong> the foundry outputs controlling outstanding native token balances must be present in the transaction. The validation of the foundry output(s) determines if the minting operations are valid.</li>
<li><strong>input side of the transaction:</strong> the transaction destroys tokens. The presence and validation of the foundry outputs of the native tokens determines whether the tokens are burned (removed from the ledger) or melted in the foundry.</li>
</ul>
</li>
</ul>
<h3 id="new-functionalities-in-outputs"><a class="header" href="#new-functionalities-in-outputs">New Functionalities in Outputs</a></h3>
<p>The programmability of outputs opens the door for implementing new functionalities for the base protocol. While some outputs
were specifically designed for such new features, some are optional additions that may be used with any outputs that
support them.</p>
<p>These new functionalities are grouped into two categories:</p>
<ul>
<li><strong>Unlock Conditions</strong> and</li>
<li>simple <strong>Features</strong>.</li>
</ul>
<p>The <a href="#output-design">Output Design</a> section lists all supported <i>Unlock Conditions</i> and <i>Features</i> for
each output type.</p>
<h4 id="unlock-conditions"><a class="header" href="#unlock-conditions">Unlock Conditions</a></h4>
<p>New output features that introduce unlocking conditions, that is, they define constraints on how the output can
be unlocked and spent, are grouped under the field <i>Unlock Conditions</i>.</p>
<p>Each output <strong>must not contain more than one unlock condition of each type</strong> and not all unlock condition types are
supported for each output type.</p>
<h5 id="address-unlock-condition"><a class="header" href="#address-unlock-condition">Address Unlock Condition</a></h5>
<p>It is merely a layout change that the previously defined <code>Address</code> field of outputs (<a href="../TIP-0007/tip-0007.html">TIP-7</a>)
is represented as an <i>Address Unlock Condition</i>. Unlocking an <i>Ed25519 Address</i> doesn't change, it has to
be performed via a <i>Signature Unlock</i> in a transaction by signing the hash of the transaction essence.
Transaction validation rules are detailed in <a href="../TIP-0020/tip-0020.html">TIP-20</a>.</p>
<p>New additions are the <i>Alias Address</i> and <i>NFT Address</i> types, which have to be unlocked with their
corresponding unlocks, as defined in <a href="#unlocking-chain-script-locked-outputs">Unlocking Chain Script Locked Outputs</a>.</p>
<details>
    <summary>Address Unlock</summary>
    <blockquote>
        Defines the Address that owns this output, that is, it can unlock it with the proper <i>Unlock</i> in a
        transaction.
    </blockquote>
</details>
<table>
    <tr>
        <td><b>Name</b></td>
        <td><b>Type</b></td>
        <td><b>Description</b></td>
    </tr>
    <tr>
        <td>Unlock Condition Type</td>
        <td>uint8</td>
        <td>
            Set to <strong>value 0</strong> to denote an <i>Address Unlock Condition</i>.
        </td>
    </tr>
    <tr>
        <td>Address</td>
        <td colspan="2">
            <details>
                <summary>Ed25519 Address</summary>
                <table>
                    <tr>
                        <td><b>Name</b></td>
                        <td><b>Type</b></td>
                        <td><b>Description</b></td>
                    </tr>
                    <tr>
                        <td>Address Type</td>
                        <td>uint8</td>
                        <td>
                            Set to <strong>value 0</strong> to denote an <i>Ed25519 Address</i>.
                        </td>
                    </tr>
                    <tr>
                        <td>PubKeyHash</td>
                        <td>ByteArray[32]</td>
                        <td>The raw bytes of the Ed25519 address which is a BLAKE2b-256 hash of the Ed25519 public key.</td>
                    </tr>
                </table>
            </details>
            <details>
                <summary>Alias Address</summary>
                <table>
                    <tr>
                        <td><b>Name</b></td>
                        <td><b>Type</b></td>
                        <td><b>Description</b></td>
                    </tr>
                    <tr>
                        <td>Address Type</td>
                        <td>uint8</td>
                        <td>
                            Set to <strong>value 8</strong> to denote an <i>Alias Address</i>.
                        </td>
                    </tr>
                    <tr>
                        <td>Alias ID</td>
                        <td>ByteArray[32]</td>
                        <td>The raw bytes of the <i>Alias ID</i> which is the BLAKE2b-256 hash of the outputID that created it.</td>
                    </tr>
                </table>
            </details>
            <details>
                <summary>NFT Address</summary>
                <table>
                    <tr>
                        <td><b>Name</b></td>
                        <td><b>Type</b></td>
                        <td><b>Description</b></td>
                    </tr>
                    <tr>
                        <td>Address Type</td>
                        <td>uint8</td>
                        <td>
                            Set to <strong>value 16</strong> to denote an <i>NFT Address</i>.
                        </td>
                    </tr>
                    <tr>
                        <td>NFT ID</td>
                        <td>ByteArray[32]</td>
                        <td>The raw bytes of the <i>NFT ID</i> which is the BLAKE2b-256 hash of the outputID that created it.</td>
                    </tr>
                </table>
            </details>
        </td>
    </tr>
</table>
<div class="table-wrapper"><table><thead><tr><th>:information_source:  Good to know about address format</th></tr></thead><tbody>
</tbody></table>
</div>
<p>The <i>Address Type</i> byte of a raw address has an effect on the starting character of the bech32 encoded address,
which is the recommended address format for user facing applications.</p>
<p>A usual bech32 encoded mainnet address starts with <code>iota1</code>, and continues with the bech32 encoded bytes of the address.
By choosing <i>Address Type</i> as a multiple of 8 for different address types, the first character after the <code>1</code>
separator in the bech32 address will always be different.</p>
<div class="table-wrapper"><table><thead><tr><th>Address</th><th>Type Byte as <code>uint8</code></th><th>Bech32 Encoded</th></tr></thead><tbody>
<tr><td>Ed25519</td><td>0</td><td>iota1<strong>q</strong>...</td></tr>
<tr><td>Alias</td><td>8</td><td>iota1<strong>p</strong>...</td></tr>
<tr><td>NFT</td><td>16</td><td>iota1<strong>z</strong>...</td></tr>
</tbody></table>
</div>
<p>A user can identify by looking at the address whether it is a signature backed address, a smart contract chain account
or an NFT address.</p>
<h5 id="storage-deposit-return-unlock-condition"><a class="header" href="#storage-deposit-return-unlock-condition">Storage Deposit Return Unlock Condition</a></h5>
<p>This unlock condition is employed to achieve conditional sending. An output that has
<i>Storage Deposit Return Unlock Condition</i> specified can only be consumed in a transaction that deposits
<code>Return Amount</code> IOTA coins into <code>Return Address</code>. When several of such outputs are consumed, their return amounts per
<code>Return Addresses</code> are summed up and the output side must deposit this total sum per <code>Return Address</code>.</p>
<h6 id="additional-syntactic-transaction-validation-rule"><a class="header" href="#additional-syntactic-transaction-validation-rule">Additional syntactic transaction validation rule:</a></h6>
<ul>
<li><code>Minimum Storage Deposit</code> is the storage deposit in the base currency required for a <i>Basic Output</i> that only
has an <i>Address Unlock Condition</i>, no additional unlock conditions, no features and
no native tokens.</li>
<li>It must hold true, that <code>Minimum Storage Deposit</code> ≤  <code>Return Amount</code> ≤ <code>Amount</code>.</li>
</ul>
<h6 id="additional-semantic-transaction-validation-rule"><a class="header" href="#additional-semantic-transaction-validation-rule">Additional semantic transaction validation rule:</a></h6>
<ul>
<li>An output that has <i>Storage Deposit Return Unlock Condition</i> specified must only be consumed and unlocked in a
transaction that deposits <code>Return Amount</code> IOTA coins to <code>Return Address</code> via one or more outputs that:
<ul>
<li>are of type <a href="#basic-output"><i>Basic Output</i></a>,</li>
<li>have only an <a href="#address-unlock-condition"><i>Address Unlock Condition</i></a> defined,</li>
<li>have no <a href="#native-tokens-in-outputs"><i>Native Tokens</i></a>, and</li>
<li>have no <a href="#features"><i>Features</i></a>.</li>
</ul>
</li>
<li>When several outputs with <i>Storage Deposit Return Unlock Condition</i> and the same <code>Return Address</code> are consumed,
their return amounts per <code>Return Addresses</code> are summed up and the output side of the transaction must deposit
<em>at least</em> this total sum per <code>Return Address</code> via output(s) that satisfy the previous condition.</li>
</ul>
<details>
    <summary>Storage Deposit Return Unlock Condition</summary>
    <blockquote>
        Defines the amount of IOTAs used as storage deposit that have to be returned to <i>Return Address</i>.
    </blockquote>
</details>
<table>
    <tr>
        <td><b>Name</b></td>
        <td><b>Type</b></td>
        <td><b>Description</b></td>
    </tr>
    <tr>
        <td>Unlock Condition Type</td>
        <td>uint8</td>
        <td>
            Set to <strong>value 1</strong> to denote a <i>Storage Deposit Return Unlock Condition</i>.
        </td>
    </tr>
    <tr>
        <td valign="top">Return Address<code>oneOf</code></td>
        <td colspan="2">
            <details>
                <summary>Ed25519 Address</summary>
                <table>
                    <tr>
                        <td><b>Name</b></td>
                        <td><b>Type</b></td>
                        <td><b>Description</b></td>
                    </tr>
                    <tr>
                        <td>Address Type</td>
                        <td>uint8</td>
                        <td>
                            Set to <strong>value 0</strong> to denote an <i>Ed25519 Address</i>.
                        </td>
                    </tr>
                    <tr>
                        <td>PubKeyHash</td>
                        <td>ByteArray[32]</td>
                        <td>The raw bytes of the Ed25519 address which is a BLAKE2b-256 hash of the Ed25519 public key.</td>
                    </tr>
                </table>
            </details>
            <details>
                <summary>Alias Address</summary>
                <table>
                    <tr>
                        <td><b>Name</b></td>
                        <td><b>Type</b></td>
                        <td><b>Description</b></td>
                    </tr>
                    <tr>
                        <td>Address Type</td>
                        <td>uint8</td>
                        <td>
                            Set to <strong>value 8</strong> to denote an <i>Alias Address</i>.
                        </td>
                    </tr>
                    <tr>
                        <td>Alias ID</td>
                        <td>ByteArray[32]</td>
                        <td>The raw bytes of the <i>Alias ID</i> which is the BLAKE2b-256 hash of the outputID that created it.</td>
                    </tr>
                </table>
            </details>
            <details>
                <summary>NFT Address</summary>
                <table>
                    <tr>
                        <td><b>Name</b></td>
                        <td><b>Type</b></td>
                        <td><b>Description</b></td>
                    </tr>
                    <tr>
                        <td>Address Type</td>
                        <td>uint8</td>
                        <td>
                            Set to <strong>value 16</strong> to denote an <i>NFT Address</i>.
                        </td>
                    </tr>
                    <tr>
                        <td>NFT ID</td>
                        <td>ByteArray[32]</td>
                        <td>The raw bytes of the <i>NFT ID</i> which is the BLAKE2b-256 hash of the outputID that created it.</td>
                    </tr>
                </table>
            </details>
        </td>
    </tr>
    <tr>
        <td>Return Amount</td>
        <td>uint64</td>
        <td>
            Amount of IOTA coins the consuming transaction should deposit to <i>Return Address</i>.
        </td>
    </tr>
</table>
<p>This unlock condition makes it possible to send small amounts of IOTA coins or native tokens to addresses without having
to lose control of the required storage deposit. It is also a vehicle to send on-chain requests to ISCP chains that do not
require fees. To prevent the receiving party from blocking access to the storage deposit, it is advised to be used
together with the <a href="#expiration-unlock-conditions">Expiration Unlock Conditions</a>. The receiving party then has a sender-defined
time window to agree to the transfer by consuming the output, or the sender regains total control after expiration.</p>
<h5 id="timelock-unlock-condition"><a class="header" href="#timelock-unlock-condition">Timelock Unlock Condition</a></h5>
<p>The notion of time in the Tangle is introduced via milestones. Each milestone
<a href="../TIP-0008/tip-0008.html#structure">carries the current unix timestamp</a>
corresponding to that milestone index. Whenever a new milestone appears, nodes perform the white-flag ordering and transaction
validation on its past cone. The timestamp of the confirming milestone provide the time as an input parameter to
transaction validation.</p>
<p>An output that contains a <i>Timelock Unlock Condition</i> can not be unlocked before the specified timelock has
expired. The timelock is expired when the timestamp of the confirming milestone is equal or past the timestamp defined
in the <i>Timelock Unlock Condition</i>.</p>
<h6 id="additional-syntactic-transaction-validation-rules"><a class="header" href="#additional-syntactic-transaction-validation-rules">Additional syntactic transaction validation rules:</a></h6>
<ul>
<li><code>Unix Time</code> field of a <i>Timelock Unlock Condition</i> must be &gt; <code>0</code>.</li>
</ul>
<h6 id="additional-semantic-transaction-validation-rules-1"><a class="header" href="#additional-semantic-transaction-validation-rules-1">Additional semantic transaction validation rules:</a></h6>
<ul>
<li>An output that has <i>Timelock Unlock Condition</i> specified must only be consumed and unlocked in a
transaction, if the timestamp of the confirming milestone is equal or past the <code>Unix Time</code> specified in the unlock
condition.</li>
</ul>
<details>
    <summary>Timelock Unlock Condition</summary>
    <blockquote>
        Defines a unix timestamp until which the output can not be unlocked.
    </blockquote>
</details>
<table>
    <tr>
        <td><b>Name</b></td>
        <td><b>Type</b></td>
        <td><b>Description</b></td>
    </tr>
    <tr>
        <td>Unlock Condition Type</td>
        <td>uint8</td>
        <td>
            Set to <strong>value 2</strong> to denote a <i>Timelock Unlock Condition</i>.
        </td>
    </tr>
    <tr>
        <td>Unix Time</td>
        <td>uint32</td>
        <td>
            Unix time (seconds since Unix epoch) starting from which the output can be consumed.
        </td>
    </tr>
</table>
<h5 id="expiration-unlock-condition"><a class="header" href="#expiration-unlock-condition">Expiration Unlock Condition</a></h5>
<p>The expiration feature of outputs makes it possible for the return address to reclaim an output after a given expiration
time has been passed. The expiration can be specified as a unix timestamp.</p>
<p>The expiration feature can be viewed as an opt-in receive feature, because the recipient loses access to the received
funds after the output expires, while the return address specified by the sender regains control over them. This feature
is a big help for on-chain smart contract requests. Those that have expiration set and are sent to dormant smart contract
chains can be recovered by their senders. Not to mention the possibility to time requests by specifying both a
timelock and an expiration unlock condition.</p>
<h6 id="additional-syntactic-transaction-validation-rules-1"><a class="header" href="#additional-syntactic-transaction-validation-rules-1">Additional syntactic transaction validation rules:</a></h6>
<ul>
<li><code>Unix Time</code> field of an <i>Expiration Unlock Condition</i> must be &gt; <code>0</code>.</li>
</ul>
<h6 id="additional-semantic-transaction-validation-rules-2"><a class="header" href="#additional-semantic-transaction-validation-rules-2">Additional semantic transaction validation rules:</a></h6>
<ul>
<li>An output that has <i>Expiration Unlock Condition</i> set must only be consumed and
unlocked by the target <code>Address</code> (defined in <i>Address Unlock Condition</i>) in a transaction that has a confirming
milestone timestamp earlier than the <code>Unix Time</code> defined in the unlock condition.</li>
<li>An output that has <i>Expiration Unlock Condition</i> set must only be consumed and unlocked by the <code>Return Address</code>
in a transaction that has a confirming milestone timestamp same or later than the <code>Unix Time</code> defined in the unlock
condition.</li>
<li>Semantic validation of an output that has <i>Expiration Unlock Condition</i> set and is unlocked by the
<code>Return Address</code> must ignore:
<ul>
<li><a href="#storage-deposit-return-unlock-condition">Semantic validation of <i>Storage Deposit Return Unlock Condition</i></a> if present.</li>
</ul>
</li>
</ul>
<p>The following table summarizes the outcome of syntactic and semantic validation rules with respect to which account
is allowed to unlock the output containing the <i>Expiration Unlock Condition</i>:</p>
<div class="table-wrapper"><table><thead><tr><th>Milestone Unix Timestamp Condition</th><th>Outcome</th></tr></thead><tbody>
<tr><td><code>Unix Time</code> = <code>0</code></td><td>Output and containing transaction is invalid.</td></tr>
<tr><td><code>Unix Time</code> &gt; <code>Confirming Milestone Unix Timestamp</code></td><td>Unlockable by <code>Address</code></td></tr>
<tr><td><code>Unix Time</code> ≤ <code>Confirming Milestone Unix Timestamp</code></td><td>Unlockable by <code>Return Address</code></td></tr>
</tbody></table>
</div><details>
    <summary>Expiration Unlock Condition</summary>
    <blockquote>
        Defines a unix time until which only <i>Address</i>, defined in <i>Address Unlock Condition</i>, is allowed to
        unlock the output. After the unix time is reached/passed, only <i>Return Address</i> can unlock it.
    </blockquote>
</details>
<table>
    <tr>
        <td><b>Name</b></td>
        <td><b>Type</b></td>
        <td><b>Description</b></td>
    </tr>
    <tr>
        <td>Unlock Condition Type</td>
        <td>uint8</td>
        <td>
            Set to <strong>value 3</strong> to denote a <i>Expiration Unlock Condition</i>.
        </td>
    </tr>
    <tr>
        <td valign="top">Return Address <code>oneOf</code></td>
        <td colspan="2">
            <details>
                <summary>Ed25519 Address</summary>
                <table>
                    <tr>
                        <td><b>Name</b></td>
                        <td><b>Type</b></td>
                        <td><b>Description</b></td>
                    </tr>
                    <tr>
                        <td>Address Type</td>
                        <td>uint8</td>
                        <td>
                            Set to <strong>value 0</strong> to denote an <i>Ed25519 Address</i>.
                        </td>
                    </tr>
                    <tr>
                        <td>PubKeyHash</td>
                        <td>ByteArray[32]</td>
                        <td>The raw bytes of the Ed25519 address which is a BLAKE2b-256 hash of the Ed25519 public key.</td>
                    </tr>
                </table>
            </details>
            <details>
                <summary>Alias Address</summary>
                <table>
                    <tr>
                        <td><b>Name</b></td>
                        <td><b>Type</b></td>
                        <td><b>Description</b></td>
                    </tr>
                    <tr>
                        <td>Address Type</td>
                        <td>uint8</td>
                        <td>
                            Set to <strong>value 8</strong> to denote an <i>Alias Address</i>.
                        </td>
                    </tr>
                    <tr>
                        <td>Alias ID</td>
                        <td>ByteArray[32]</td>
                        <td>The raw bytes of the <i>Alias ID</i> which is the BLAKE2b-256 hash of the outputID that created it.</td>
                    </tr>
                </table>
            </details>
            <details>
                <summary>NFT Address</summary>
                <table>
                    <tr>
                        <td><b>Name</b></td>
                        <td><b>Type</b></td>
                        <td><b>Description</b></td>
                    </tr>
                    <tr>
                        <td>Address Type</td>
                        <td>uint8</td>
                        <td>
                            Set to <strong>value 16</strong> to denote an <i>NFT Address</i>.
                        </td>
                    </tr>
                    <tr>
                        <td>NFT ID</td>
                        <td>ByteArray[32]</td>
                        <td>The raw bytes of the <i>NFT ID</i> which is the BLAKE2b-256 hash of the outputID that created it.</td>
                    </tr>
                </table>
            </details>
        </td>
    </tr>
    <tr>
        <td>Unix Time</td>
        <td>uint32</td>
        <td>
            Before this unix time, <i>Address Unlock Condition</i> is allowed to unlock the output, after that only the address defined in <i>Return Address</i>.
        </td>
    </tr>
</table>
<h5 id="state-controller-address-unlock-condition"><a class="header" href="#state-controller-address-unlock-condition">State Controller Address Unlock Condition</a></h5>
<p>An unlock condition defined solely for <i>Alias Output</i>. It is functionally equivalent to an
<i>Address Unlock Condition</i>, however there are additional transition constraints defined for the Alias UTXO state
machine that can only be carried out by the <code>State Controller Address</code>, hence the distinct unlock condition type.</p>
<details>
    <summary>State Controller Address Unlock</summary>
    <blockquote>
        Defines the State Controller Address that owns this output, that is, it can unlock it with the proper <i>Unlock</i> in a
        transaction that state transitions the alias output.
    </blockquote>
</details>
<table>
    <tr>
        <td><b>Name</b></td>
        <td><b>Type</b></td>
        <td><b>Description</b></td>
    </tr>
    <tr>
        <td>Unlock Condition Type</td>
        <td>uint8</td>
        <td>
            Set to <strong>value 4</strong> to denote an <i>State Controller Address Unlock Condition</i>.
        </td>
    </tr>
    <tr>
        <td>Address</td>
        <td colspan="2">
            <details>
                <summary>Ed25519 Address</summary>
                <table>
                    <tr>
                        <td><b>Name</b></td>
                        <td><b>Type</b></td>
                        <td><b>Description</b></td>
                    </tr>
                    <tr>
                        <td>Address Type</td>
                        <td>uint8</td>
                        <td>
                            Set to <strong>value 0</strong> to denote an <i>Ed25519 Address</i>.
                        </td>
                    </tr>
                    <tr>
                        <td>PubKeyHash</td>
                        <td>ByteArray[32]</td>
                        <td>The raw bytes of the Ed25519 address which is a BLAKE2b-256 hash of the Ed25519 public key.</td>
                    </tr>
                </table>
            </details>
            <details>
                <summary>Alias Address</summary>
                <table>
                    <tr>
                        <td><b>Name</b></td>
                        <td><b>Type</b></td>
                        <td><b>Description</b></td>
                    </tr>
                    <tr>
                        <td>Address Type</td>
                        <td>uint8</td>
                        <td>
                            Set to <strong>value 8</strong> to denote an <i>Alias Address</i>.
                        </td>
                    </tr>
                    <tr>
                        <td>Alias ID</td>
                        <td>ByteArray[32]</td>
                        <td>The raw bytes of the <i>Alias ID</i> which is the BLAKE2b-256 hash of the outputID that created it.</td>
                    </tr>
                </table>
            </details>
            <details>
                <summary>NFT Address</summary>
                <table>
                    <tr>
                        <td><b>Name</b></td>
                        <td><b>Type</b></td>
                        <td><b>Description</b></td>
                    </tr>
                    <tr>
                        <td>Address Type</td>
                        <td>uint8</td>
                        <td>
                            Set to <strong>value 16</strong> to denote an <i>NFT Address</i>.
                        </td>
                    </tr>
                    <tr>
                        <td>NFT ID</td>
                        <td>ByteArray[32]</td>
                        <td>The raw bytes of the <i>NFT ID</i> which is the BLAKE2b-256 hash of the outputID that created it.</td>
                    </tr>
                </table>
            </details>
        </td>
    </tr>
</table>
<p>The additional constraints are defined in <a href="#alias-output">Alias Output Design</a> section.</p>
<h5 id="governor-address-unlock-condition"><a class="header" href="#governor-address-unlock-condition">Governor Address Unlock Condition</a></h5>
<p>An unlock condition defined solely for <i>Alias Output</i>. It is functionally equivalent to an
<i>Address Unlock Condition</i>, however there are additional transition constraints defined for the Alias UTXO state
machine that can only be carried out by the <code>Governor Address</code>, hence the distinct unlock condition type.</p>
<details>
    <summary>Governor Address Unlock</summary>
    <blockquote>
        Defines the Governor Address that owns this output, that is, it can unlock it with the proper <i>Unlock</i> in a
        transaction that governance transitions the alias output.
    </blockquote>
</details>
<table>
    <tr>
        <td><b>Name</b></td>
        <td><b>Type</b></td>
        <td><b>Description</b></td>
    </tr>
    <tr>
        <td>Unlock Condition Type</td>
        <td>uint8</td>
        <td>
            Set to <strong>value 5</strong> to denote an <i>Governor Address Unlock Condition</i>.
        </td>
    </tr>
    <tr>
        <td>Address</td>
        <td colspan="2">
            <details>
                <summary>Ed25519 Address</summary>
                <table>
                    <tr>
                        <td><b>Name</b></td>
                        <td><b>Type</b></td>
                        <td><b>Description</b></td>
                    </tr>
                    <tr>
                        <td>Address Type</td>
                        <td>uint8</td>
                        <td>
                            Set to <strong>value 0</strong> to denote an <i>Ed25519 Address</i>.
                        </td>
                    </tr>
                    <tr>
                        <td>PubKeyHash</td>
                        <td>ByteArray[32]</td>
                        <td>The raw bytes of the Ed25519 address which is a BLAKE2b-256 hash of the Ed25519 public key.</td>
                    </tr>
                </table>
            </details>
            <details>
                <summary>Alias Address</summary>
                <table>
                    <tr>
                        <td><b>Name</b></td>
                        <td><b>Type</b></td>
                        <td><b>Description</b></td>
                    </tr>
                    <tr>
                        <td>Address Type</td>
                        <td>uint8</td>
                        <td>
                            Set to <strong>value 8</strong> to denote an <i>Alias Address</i>.
                        </td>
                    </tr>
                    <tr>
                        <td>Alias ID</td>
                        <td>ByteArray[32]</td>
                        <td>The raw bytes of the <i>Alias ID</i> which is the BLAKE2b-256 hash of the outputID that created it.</td>
                    </tr>
                </table>
            </details>
            <details>
                <summary>NFT Address</summary>
                <table>
                    <tr>
                        <td><b>Name</b></td>
                        <td><b>Type</b></td>
                        <td><b>Description</b></td>
                    </tr>
                    <tr>
                        <td>Address Type</td>
                        <td>uint8</td>
                        <td>
                            Set to <strong>value 16</strong> to denote an <i>NFT Address</i>.
                        </td>
                    </tr>
                    <tr>
                        <td>NFT ID</td>
                        <td>ByteArray[32]</td>
                        <td>The raw bytes of the <i>NFT ID</i> which is the BLAKE2b-256 hash of the outputID that created it.</td>
                    </tr>
                </table>
            </details>
        </td>
    </tr>
</table>
<p>The additional constraints are defined in <a href="#alias-output">Alias Output Design</a> section.</p>
<h5 id="immutable-alias-address-unlock-condition"><a class="header" href="#immutable-alias-address-unlock-condition">Immutable Alias Address Unlock Condition</a></h5>
<p>An unlock condition defined for chain constrained UTXOs that can only be unlocked by a permanent <i>Alias Address</i>.</p>
<p>Output unlocking is functionally equivalent to an <i>Address Unlock Condition</i> with an <i>Alias Address</i>,
however there are additional transition constraints: the next state of the UTXO machine must have the same
<i>Immutable Alias Address Unlock Condition</i>.</p>
<details>
    <summary>Immutable Alias Address Unlock Condition</summary>
    <blockquote>
        Defines the permanent <i>Alias Address</i> that owns this output.
    </blockquote>
</details>
<table>
    <tr>
        <td><b>Name</b></td>
        <td><b>Type</b></td>
        <td><b>Description</b></td>
    </tr>
    <tr>
        <td>Unlock Condition Type</td>
        <td>uint8</td>
        <td>
            Set to <strong>value 6</strong> to denote an <i>Immutable Alias Address Unlock Condition</i>.
        </td>
    </tr>
    <tr>
        <td>Address</td>
        <td colspan="2">
            <details>
                <summary>Alias Address</summary>
                <table>
                    <tr>
                        <td><b>Name</b></td>
                        <td><b>Type</b></td>
                        <td><b>Description</b></td>
                    </tr>
                    <tr>
                        <td>Address Type</td>
                        <td>uint8</td>
                        <td>
                            Set to <strong>value 8</strong> to denote an <i>Alias Address</i>.
                        </td>
                    </tr>
                    <tr>
                        <td>Alias ID</td>
                        <td>ByteArray[32]</td>
                        <td>The raw bytes of the <i>Alias ID</i> which is the BLAKE2b-256 hash of the outputID that created it.</td>
                    </tr>
                </table>
            </details>
        </td>
    </tr>
</table>
<h6 id="additional-semantic-transaction-validation-rules-3"><a class="header" href="#additional-semantic-transaction-validation-rules-3">Additional semantic transaction validation rules:</a></h6>
<ul>
<li>The output must be unlocked with an <i><a href="#alias-unlock-semantic-validation">Alias Unlock</a></i>.</li>
<li>The next state of the UTXO state machine must have the same <i>Immutable Alias Address Unlock Condition</i> defined.</li>
</ul>
<h3 id="features"><a class="header" href="#features">Features</a></h3>
<p>New output features that do not introduce unlocking conditions, but rather add new functionality and add constraints on
output creation are grouped under <i>Features</i>.</p>
<p>Each output <strong>must not contain more than one feature of each type</strong> and not all feature types are supported for each output
type.</p>
<h5 id="sender-feature"><a class="header" href="#sender-feature">Sender Feature</a></h5>
<p>Every transaction consumes several elements from the UTXO set and creates new outputs. However, certain applications
(smart contracts) require to associate each output with exactly one sender address. Here, the sender feature is used to
specify the validated sender of an output.</p>
<p>Outputs that support the <i>Sender Feature</i> may specify a <code>Sender</code> address which is validated by the protocol during
transaction validation.</p>
<h6 id="additional-semantic-transaction-validation-rule-1"><a class="header" href="#additional-semantic-transaction-validation-rule-1">Additional semantic transaction validation rule:</a></h6>
<ul>
<li>The <i>Sender Feature</i>, and hence the output and transaction that contain it, is valid, if and only if <code>Sender</code> address is unlocked in the transaction. Based on the <code>Address Type</code>, an address is unlocked in the transaction, if and only if:
<ul>
<li><i>Ed25519 Address</i>:
<ul>
<li>The <i>Unlock</i> of the first output in the transaction that contains the address is a valid <i>Signature Unlock</i> with respect to the address.</li>
</ul>
</li>
<li><i>Alias Address</i>:
<ul>
<li>The <i>Alias Output</i> that defines the address is <strong>state transitioned</strong> in the transaction. A governance transition does not unlock the address.</li>
</ul>
</li>
<li><i>NFT Address</i>:
<ul>
<li>The <i>NFT Output</i> that defines the address is consumed as input in the transaction.</li>
</ul>
</li>
</ul>
</li>
</ul>
<details>
    <summary>Sender Feature</summary>
    <blockquote>
        Identifies the validated sender of the output.
    </blockquote>
</details>
<table>
    <tr>
        <td><b>Name</b></td>
        <td><b>Type</b></td>
        <td><b>Description</b></td>
    </tr>
    <tr>
        <td>Feature Type</td>
        <td>uint8</td>
        <td>
            Set to <strong>value 0</strong> to denote a <i>Sender Feature</i>.
        </td>
    </tr>
    <tr>
        <td valign="top">Address <code>oneOf</code></td>
        <td colspan="2">
            <details>
                <summary>Ed25519 Address</summary>
                <table>
                    <tr>
                        <td><b>Name</b></td>
                        <td><b>Type</b></td>
                        <td><b>Description</b></td>
                    </tr>
                    <tr>
                        <td>Address Type</td>
                        <td>uint8</td>
                        <td>
                            Set to <strong>value 0</strong> to denote an <i>Ed25519 Address</i>.
                        </td>
                    </tr>
                    <tr>
                        <td>PubKeyHash</td>
                        <td>ByteArray[32]</td>
                        <td>The raw bytes of the Ed25519 address which is a BLAKE2b-256 hash of the Ed25519 public key.</td>
                    </tr>
                </table>
            </details>
            <details>
                <summary>Alias Address</summary>
                <table>
                    <tr>
                        <td><b>Name</b></td>
                        <td><b>Type</b></td>
                        <td><b>Description</b></td>
                    </tr>
                    <tr>
                        <td>Address Type</td>
                        <td>uint8</td>
                        <td>
                            Set to <strong>value 8</strong> to denote an <i>Alias Address</i>.
                        </td>
                    </tr>
                    <tr>
                        <td>Alias ID</td>
                        <td>ByteArray[32]</td>
                        <td>The raw bytes of the <i>Alias ID</i> which is the BLAKE2b-256 hash of the outputID that created it.</td>
                    </tr>
                </table>
            </details>
            <details>
                <summary>NFT Address</summary>
                <table>
                    <tr>
                        <td><b>Name</b></td>
                        <td><b>Type</b></td>
                        <td><b>Description</b></td>
                    </tr>
                    <tr>
                        <td>Address Type</td>
                        <td>uint8</td>
                        <td>
                            Set to <strong>value 16</strong> to denote an <i>NFT Address</i>.
                        </td>
                    </tr>
                    <tr>
                        <td>NFT ID</td>
                        <td>ByteArray[32]</td>
                        <td>The raw bytes of the <i>NFT ID</i> which is the BLAKE2b-256 hash of the outputID that created it.</td>
                    </tr>
                </table>
            </details>
        </td>
    </tr>
</table>
<h5 id="issuer-feature"><a class="header" href="#issuer-feature">Issuer Feature</a></h5>
<p>The issuer feature is a special case of the sender feature that is only supported by outputs that implement a UTXO state
machine with <a href="#chain-constraint-in-utxo">chain constraint</a> (alias, NFT).
Only when the state machine is created (e.g. minted) it is checked during transaction validation that an output
corresponding to the <code>Issuer</code> address is consumed. In every future transition of the state machine, it is instead
checked that the issuer feature is still present and unchanged.</p>
<h6 id="additional-semantic-transaction-validation-rule-2"><a class="header" href="#additional-semantic-transaction-validation-rule-2">Additional semantic transaction validation rule:</a></h6>
<ul>
<li>When an <i>Issuer Feature</i> is present in an output representing the initial state of an UTXO state machine, the
transaction that contains this output is valid, if and only if <code>Issuer</code> address is unlocked in the transaction. Based on the <code>Address Type</code>, an address is unlocked in the transaction, if and only if:
<ul>
<li><i>Ed25519 Address</i>:
<ul>
<li>The <i>Unlock</i> of the first output in the transaction that contains the address is a valid <i>Signature Unlock</i> with respect to the address.</li>
</ul>
</li>
<li><i>Alias Address</i>:
<ul>
<li>The <i>Alias Output</i> that defines the address is <strong>state transitioned</strong> in the transaction. A governance transition does not unlock the address.</li>
</ul>
</li>
<li><i>NFT Address</i>:
<ul>
<li>The <i>NFT Output</i> that defines the address is consumed as input in the transaction.</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>The main use case is proving authenticity of NFTs. Whenever an NFT is minted as an NFT output, the creator (issuer) can
fill the <i>Issuer Feature</i> with their address that they have to unlock in the transaction. Issuers then can publicly
disclose their addresses to prove the authenticity of the NFT once it is in circulation.</p>
<details>
    <summary>Issuer Feature</summary>
    <blockquote>
        Identifies the validated issuer of the UTXO state machine.
    </blockquote>
</details>
<table>
    <tr>
        <td><b>Name</b></td>
        <td><b>Type</b></td>
        <td><b>Description</b></td>
    </tr>
    <tr>
        <td>Feature Type</td>
        <td>uint8</td>
        <td>
            Set to <strong>value 1</strong> to denote an <i>Issuer Feature</i>.
        </td>
    </tr>
    <tr>
        <td valign="top">Address <code>oneOf</code></td>
        <td colspan="2">
            <details>
                <summary>Ed25519 Address</summary>
                <table>
                    <tr>
                        <td><b>Name</b></td>
                        <td><b>Type</b></td>
                        <td><b>Description</b></td>
                    </tr>
                    <tr>
                        <td>Address Type</td>
                        <td>uint8</td>
                        <td>
                            Set to <strong>value 0</strong> to denote an <i>Ed25519 Address</i>.
                        </td>
                    </tr>
                    <tr>
                        <td>PubKeyHash</td>
                        <td>ByteArray[32]</td>
                        <td>The raw bytes of the Ed25519 address which is a BLAKE2b-256 hash of the Ed25519 public key.</td>
                    </tr>
                </table>
            </details>
            <details>
                <summary>Alias Address</summary>
                <table>
                    <tr>
                        <td><b>Name</b></td>
                        <td><b>Type</b></td>
                        <td><b>Description</b></td>
                    </tr>
                    <tr>
                        <td>Address Type</td>
                        <td>uint8</td>
                        <td>
                            Set to <strong>value 8</strong> to denote an <i>Alias Address</i>.
                        </td>
                    </tr>
                    <tr>
                        <td>Alias ID</td>
                        <td>ByteArray[32]</td>
                        <td>The raw bytes of the <i>Alias ID</i> which is the BLAKE2b-256 hash of the outputID that created it.</td>
                    </tr>
                </table>
            </details>
            <details>
                <summary>NFT Address</summary>
                <table>
                    <tr>
                        <td><b>Name</b></td>
                        <td><b>Type</b></td>
                        <td><b>Description</b></td>
                    </tr>
                    <tr>
                        <td>Address Type</td>
                        <td>uint8</td>
                        <td>
                            Set to <strong>value 16</strong> to denote an <i>NFT Address</i>.
                        </td>
                    </tr>
                    <tr>
                        <td>NFT ID</td>
                        <td>ByteArray[32]</td>
                        <td>The raw bytes of the <i>NFT ID</i> which is the BLAKE2b-256 hash of the outputID that created it.</td>
                    </tr>
                </table>
            </details>
        </td>
    </tr>
</table>
<p>Whenever a chain account mints an NFT on layer 1 on behalf of some user, the <code>Issuer</code> field can only contain the
chain's address, since user does not sign the layer 1 transaction. As a consequence, artist would have to mint NFTs
themselves on layer 1 and then deposit it to chains if they want to place their own address in the <code>Issuer</code> field.</p>
<h5 id="metadata-feature"><a class="header" href="#metadata-feature">Metadata Feature</a></h5>
<p>Outputs may carry additional data with them that is interpreted by higher layer applications built on the Tangle. The
protocol treats this metadata as pure binary data, it has no effect on the validity of an output except that it
increases the required storage deposit. ISC is a great example of a higher layer protocol that makes use of
<i>Metadata Feature</i>: smart contract request parameters are encoded in the metadata field of outputs.</p>
<h6 id="additional-syntactic-transaction-validation-rules-2"><a class="header" href="#additional-syntactic-transaction-validation-rules-2">Additional syntactic transaction validation rules:</a></h6>
<ul>
<li>An output with <i>Metadata Feature</i> is valid, if and only if 0 &lt; <code>length(Data)</code> ≤ <code>Max Metadata Length</code>.</li>
</ul>
<details>
    <summary>Metadata Feature</summary>
    <blockquote>
        Defines metadata (arbitrary binary data) that will be stored in the output.
    </blockquote>
</details>
<table>
    <tr>
        <td><b>Name</b></td>
        <td><b>Type</b></td>
        <td><b>Description</b></td>
    </tr>
    <tr>
        <td>Feature Type</td>
        <td>uint8</td>
        <td>
            Set to <strong>value 2</strong> to denote a <i>Metadata Feature</i>.
        </td>
    </tr>
    <tr>
        <td>Data</td>
        <td>(uint16)ByteArray</td>
        <td>Binary data. A leading uint16 denotes its length.</td>
    </tr>
</table>
<h4 id="tag-feature"><a class="header" href="#tag-feature">Tag Feature</a></h4>
<p>A <i>Tag Feature</i> makes it possible to tag outputs with an index, so they can be retrieved through an indexer API not
only by their address, but also based on the <code>Tag</code>. <strong>The combination of a <i>Tag Feature</i>, a
<i>Metadata Feature</i> and a <i>Sender Feature</i> makes it possible to retrieve data associated to an address and stored
in outputs that were created by a specific party (<code>Sender</code>) for a specific purpose (<code>Tag</code>).</strong></p>
<p>An example use case is voting on the Tangle via the <a href="https://github.com/iota-community/treasury/blob/main/specifications/hornet-participation-plugin.md">participation</a> plugin.</p>
<h5 id="additional-syntactic-transaction-validation-rules-3"><a class="header" href="#additional-syntactic-transaction-validation-rules-3">Additional syntactic transaction validation rules:</a></h5>
<ul>
<li>An output with <i>Tag Feature</i> is valid, if and only if 0 &lt; <code>length(Tag)</code> ≤
<code>Max Tag Length</code>.</li>
</ul>
<details>
    <summary>Tag Feature</summary>
    <blockquote>
        Defines an indexation tag to which the output can be indexed by additional node plugins.
    </blockquote>
</details>
<table>
    <tr>
        <td><b>Name</b></td>
        <td><b>Type</b></td>
        <td><b>Description</b></td>
    </tr>
    <tr>
        <td>Feature Type</td>
        <td>uint8</td>
        <td>
            Set to <strong>value 3</strong> to denote a <i>Tag Feature</i>.
        </td>
    </tr>
    <tr>
        <td>Tag</td>
        <td>(uint8)ByteArray</td>
        <td>Binary indexation tag. A leading uint8 denotes its length.</td>
    </tr>
</table>
<h3 id="chain-constraint-in-utxo"><a class="header" href="#chain-constraint-in-utxo">Chain Constraint in UTXO</a></h3>
<p>Previously created transaction outputs are destroyed when they are consumed in a subsequent transaction as an input.
The chain constraint makes it possible to <strong>carry the UTXO state machine state encoded in outputs across transactions.</strong>
When an output with chain constraint is consumed, that transaction has to create a single subsequent output that
carries the state forward. The <strong>state can be updated according to the transition rules defined for the given type of
output and its current state</strong>. As a consequence, each such output has a unique successor, and together they form a path
or <em>chain</em> in the graph induced by the UTXO spends. Each chain is identified by its globally unique identifier.</p>
<p><img src="chain-constraint.png" alt="" /></p>
<p>Alias outputs, foundry outputs and NFT outputs all use this chain constraint concept and define their own unique
identifiers.</p>
<h2 id="output-design"><a class="header" href="#output-design">Output Design</a></h2>
<p>In the following, we define four new output types. They are all designed with specific use cases in mind:</p>
<ul>
<li><strong>Basic Output</strong>: transfer of funds with attached metadata and optional spending restrictions. Main use cases are
on-ledger ISC requests, native asset transfers and indexed data storage in the UTXO ledger.</li>
<li><strong>Alias Output</strong>: representing ISC chain accounts on L1 that can process requests and transfer funds.</li>
<li><strong>Foundry Output</strong>: supply control of user defined native tokens. A vehicle for cross-chain asset transfers and asset
wrapping.</li>
<li><strong>NFT Output</strong>: an output that represents a Non-fungible token with attached metadata and proof-of-origin. A NFT is
represented as an output so that the token and metadata are transferred together, for example as a smart contract
requests. NFTs are possible to implement with native tokens as well, but then ownership of the token does not mean
ownership of the foundry that holds its metadata.</li>
</ul>
<p>The validation of outputs is part of the transaction validation process. There are two levels of validation for
transactions: syntactic and semantic validation. The former validates the structure of the transaction (and outputs),
while the latter validates whether protocol rules are respected in the semantic context of the transaction. Outputs
hence are validated on both levels:</p>
<ol>
<li><strong>Transaction Syntactic Validation</strong>: validates the structure of each output created by the transaction.</li>
<li><strong>Transaction Semantic Validation</strong>:
<ul>
<li><strong>For consumed outputs</strong>: validates whether the output can be unlocked in a transaction given the semantic
transaction context.</li>
<li><strong>For created outputs</strong>: validates whether the output can be created in a transaction given the semantic
transaction context.</li>
</ul>
</li>
</ol>
<p>Each new output type may add its own validation rules which become part of the transaction validation rules if the
output is placed inside a transaction. <i>Unlock Conditions</i> and <i>Features</i> described previously also add
constraints to transaction validation when they are placed in outputs.</p>
<h2 id="basic-output"><a class="header" href="#basic-output">Basic Output</a></h2>
<p><i>Basic Output</i> can hold native tokens and might have several unlock conditions and optional features. The
combination of several features provide the base functionality for the output to be used as an on-ledger smart contract
request:</p>
<ul>
<li>Verified <code>Sender</code>,</li>
<li>Attached <code>Metadata</code> that can encode the request payload for layer 2,</li>
<li><code>Return Amount</code> to get back the storage deposit,</li>
<li><code>Timelock</code> to be able to time requests,</li>
<li><code>Expiration</code> to recover funds in case of chain inactivity.</li>
</ul>
<p>Besides, the <i>Tag Feature</i> is a tool to store arbitrary, indexed data with verified origin in the ledger.</p>
<p>Note, that a <i>Basic Output</i> in its simplest possible form with only an <i>Address Unlock Condition</i> and
without features or native tokens is functionally equivalent to a <i>SigLockedSingleOutput</i>: it has an address
and an IOTA balance. Therefore, 
aforementioned output type, that was <a href="../TIP-0007/tip-0007.html">introduced for Chrysalis Part 2 via TIP-7</a>
is deprecated with the replacement of the <a href="../TIP-0020/tip-0020.html">TIP-20 Transaction Payload</a>.</p>
<table>
    <details>
        <summary>Basic Output</summary>
        <blockquote>
            Describes a basic output with optional features.
        </blockquote>
        <table>
            <tr>
                <td><b>Name</b></td>
                <td><b>Type</b></td>
                <td><b>Description</b></td>
            </tr>
            <tr>
                <td>Output Type</td>
                <td>uint8</td>
                <td>
                    Set to <strong>value 3</strong> to denote a <i>Basic Output</i>.
                </td>
            </tr>
            <tr>
                <td>Amount</td>
                <td>uint64</td>
                <td>The amount of IOTA coins to held by the output.</td>
            </tr>
            <tr>
                <td>Native Tokens Count</td>
                <td>uint8</td>
                <td>The number of native tokens held by the output.</td>
            </tr>
            <tr>
                <td valign="top">Native Tokens <code>optAnyOf</code></td>
                <td colspan="2">
                    <details>
                        <summary>Native Token</summary>
                        <table>
                            <tr>
                                <td><b>Name</b></td>
                                <td><b>Type</b></td>
                                <td><b>Description</b></td>
                            </tr>
                            <tr>
                                <td>Token ID</td>
                                <td>ByteArray[38]</td>
                                <td>
                                    Identifier of the native token.
                                </td>
                            </tr>
                            <tr>
                                <td>Amount</td>
                                <td>uint256</td>
                                <td>
                                    Amount of native tokens of the given <i>Token ID</i>.
                                </td>
                            </tr>
                        </table>
                    </details>
                </td>
            </tr>
            <tr>
                <td>Unlock Conditions Count</td>
                <td>uint8</td>
                <td>The number of unlock conditions following.</td>
            </tr>
            <tr>
                <td valign="top">Unlock Conditions <code>atMostOneOfEach</code></td>
                <td colspan="2">
                    <details>
                        <summary>Address Unlock Condition</summary>
                        <table>
                            <tr>
                                <td><b>Name</b></td>
                                <td><b>Type</b></td>
                                <td><b>Description</b></td>
                            </tr>
                            <tr>
                                <td>Unlock Condition Type</td>
                                <td>uint8</td>
                                <td>
                                    Set to <strong>value 0</strong> to denote an <i>Address Unlock Condition</i>.
                                </td>
                            </tr>
                            <tr>
                                <td>Address</td>
                                <td colspan="2">
                                    <details>
                                        <summary>Ed25519 Address</summary>
                                        <table>
                                            <tr>
                                                <td><b>Name</b></td>
                                                <td><b>Type</b></td>
                                                <td><b>Description</b></td>
                                            </tr>
                                            <tr>
                                                <td>Address Type</td>
                                                <td>uint8</td>
                                                <td>
                                                    Set to <strong>value 0</strong> to denote an <i>Ed25519 Address</i>.
                                                </td>
                                            </tr>
                                            <tr>
                                                <td>PubKeyHash</td>
                                                <td>ByteArray[32]</td>
                                                <td>The raw bytes of the Ed25519 address which is a BLAKE2b-256 hash of the Ed25519 public key.</td>
                                            </tr>
                                        </table>
                                    </details>
                                    <details>
                                        <summary>Alias Address</summary>
                                        <table>
                                            <tr>
                                                <td><b>Name</b></td>
                                                <td><b>Type</b></td>
                                                <td><b>Description</b></td>
                                            </tr>
                                            <tr>
                                                <td>Address Type</td>
                                                <td>uint8</td>
                                                <td>
                                                    Set to <strong>value 8</strong> to denote an <i>Alias Address</i>.
                                                </td>
                                            </tr>
                                            <tr>
                                                <td>Alias ID</td>
                                                <td>ByteArray[32]</td>
                                                <td>The raw bytes of the <i>Alias ID</i> which is the BLAKE2b-256 hash of the outputID that created it.</td>
                                            </tr>
                                        </table>
                                    </details>
                                    <details>
                                        <summary>NFT Address</summary>
                                        <table>
                                            <tr>
                                                <td><b>Name</b></td>
                                                <td><b>Type</b></td>
                                                <td><b>Description</b></td>
                                            </tr>
                                            <tr>
                                                <td>Address Type</td>
                                                <td>uint8</td>
                                                <td>
                                                    Set to <strong>value 16</strong> to denote an <i>NFT Address</i>.
                                                </td>
                                            </tr>
                                            <tr>
                                                <td>NFT ID</td>
                                                <td>ByteArray[32]</td>
                                                <td>The raw bytes of the <i>NFT ID</i> which is the BLAKE2b-256 hash of the outputID that created it.</td>
                                            </tr>
                                        </table>
                                    </details>
                                </td>
                            </tr>
                        </table>
                    </details>
                    <details>
                        <summary>Storage Deposit Return Unlock Condition</summary>
                        <blockquote>
                            Defines the amount of IOTAs used as storage deposit that have to be returned to <i>Return Address</i>.
                        </blockquote>
                        <table>
                            <tr>
                                <td><b>Name</b></td>
                                <td><b>Type</b></td>
                                <td><b>Description</b></td>
                            </tr>
                            <tr>
                                <td>Unlock Condition Type</td>
                                <td>uint8</td>
                                <td>
                                    Set to <strong>value 1</strong> to denote a <i>Storage Deposit Return Unlock Condition</i>.
                                </td>
                            </tr>
                            <tr>
                                <td valign="top">Return Address <code>oneOf</code></td>
                                <td colspan="2">
                                    <details>
                                        <summary>Ed25519 Address</summary>
                                        <table>
                                            <tr>
                                                <td><b>Name</b></td>
                                                <td><b>Type</b></td>
                                                <td><b>Description</b></td>
                                            </tr>
                                            <tr>
                                                <td>Address Type</td>
                                                <td>uint8</td>
                                                <td>
                                                    Set to <strong>value 0</strong> to denote an <i>Ed25519 Address</i>.
                                                </td>
                                            </tr>
                                            <tr>
                                                <td>PubKeyHash</td>
                                                <td>ByteArray[32]</td>
                                                <td>The raw bytes of the Ed25519 address which is a BLAKE2b-256 hash of the Ed25519 public key.</td>
                                            </tr>
                                        </table>
                                    </details>
                                    <details>
                                        <summary>Alias Address</summary>
                                        <table>
                                            <tr>
                                                <td><b>Name</b></td>
                                                <td><b>Type</b></td>
                                                <td><b>Description</b></td>
                                            </tr>
                                            <tr>
                                                <td>Address Type</td>
                                                <td>uint8</td>
                                                <td>
                                                    Set to <strong>value 8</strong> to denote an <i>Alias Address</i>.
                                                </td>
                                            </tr>
                                            <tr>
                                                <td>Alias ID</td>
                                                <td>ByteArray[32]</td>
                                                <td>The raw bytes of the <i>Alias ID</i> which is the BLAKE2b-256 hash of the outputID that created it.</td>
                                            </tr>
                                        </table>
                                    </details>
                                    <details>
                                        <summary>NFT Address</summary>
                                        <table>
                                            <tr>
                                                <td><b>Name</b></td>
                                                <td><b>Type</b></td>
                                                <td><b>Description</b></td>
                                            </tr>
                                            <tr>
                                                <td>Address Type</td>
                                                <td>uint8</td>
                                                <td>
                                                    Set to <strong>value 16</strong> to denote an <i>NFT Address</i>.
                                                </td>
                                            </tr>
                                            <tr>
                                                <td>NFT ID</td>
                                                <td>ByteArray[32]</td>
                                                <td>The raw bytes of the <i>NFT ID</i> which is the BLAKE2b-256 hash of the outputID that created it.</td>
                                            </tr>
                                        </table>
                                    </details>
                                </td>
                            </tr>
                            <tr>
                                <td>Return Amount</td>
                                <td>uint64</td>
                                <td>
                                    Amount of IOTA coins the consuming transaction should deposit to the address defined in <i>Return Address</i>.
                                </td>
                            </tr>
                        </table>
                    </details>
                    <details>
                        <summary>Timelock Unlock Condition</summary>
                        <blockquote>
                            Defines a unix timestamp until which the output can not be unlocked.
                        </blockquote>
                        <table>
                            <tr>
                                <td><b>Name</b></td>
                                <td><b>Type</b></td>
                                <td><b>Description</b></td>
                            </tr>
                            <tr>
                                <td>Unlock Condition Type</td>
                                <td>uint8</td>
                                <td>
                                    Set to <strong>value 2</strong> to denote a <i>Timelock Unlock Condition</i>.
                                </td>
                            </tr>
                            <tr>
                                <td>Unix Time</td>
                                <td>uint32</td>
                                <td>
                                    Unix time (seconds since Unix epoch) starting from which the output can be consumed.
                                </td>
                            </tr>
                        </table>
                    </details>
                    <details>
                        <summary>Expiration Unlock Condition</summary>
                        <blockquote>
                            Defines a unix time until which only <i>Address</i>, defined in <i>Address Unlock Condition</i>, is allowed to
                            unlock the output. After the unix time is reached or passed, only <i>Return Address</i> can unlock it.
                        </blockquote>
                        <table>
                            <tr>
                                <td><b>Name</b></td>
                                <td><b>Type</b></td>
                                <td><b>Description</b></td>
                            </tr>
                            <tr>
                                <td>Unlock Condition Type</td>
                                <td>uint8</td>
                                <td>
                                    Set to <strong>value 3</strong> to denote a <i>Expiration Unlock Condition</i>.
                                </td>
                            </tr>
                            <tr>
                                <td valign="top">Return Address <code>oneOf</code></td>
                                <td colspan="2">
                                    <details>
                                        <summary>Ed25519 Address</summary>
                                        <table>
                                            <tr>
                                                <td><b>Name</b></td>
                                                <td><b>Type</b></td>
                                                <td><b>Description</b></td>
                                            </tr>
                                            <tr>
                                                <td>Address Type</td>
                                                <td>uint8</td>
                                                <td>
                                                    Set to <strong>value 0</strong> to denote an <i>Ed25519 Address</i>.
                                                </td>
                                            </tr>
                                            <tr>
                                                <td>PubKeyHash</td>
                                                <td>ByteArray[32]</td>
                                                <td>The raw bytes of the Ed25519 address which is a BLAKE2b-256 hash of the Ed25519 public key.</td>
                                            </tr>
                                        </table>
                                    </details>
                                    <details>
                                        <summary>Alias Address</summary>
                                        <table>
                                            <tr>
                                                <td><b>Name</b></td>
                                                <td><b>Type</b></td>
                                                <td><b>Description</b></td>
                                            </tr>
                                            <tr>
                                                <td>Address Type</td>
                                                <td>uint8</td>
                                                <td>
                                                    Set to <strong>value 8</strong> to denote an <i>Alias Address</i>.
                                                </td>
                                            </tr>
                                            <tr>
                                                <td>Alias ID</td>
                                                <td>ByteArray[32]</td>
                                                <td>The raw bytes of the <i>Alias ID</i> which is the BLAKE2b-256 hash of the outputID that created it.</td>
                                            </tr>
                                        </table>
                                    </details>
                                    <details>
                                        <summary>NFT Address</summary>
                                        <table>
                                            <tr>
                                                <td><b>Name</b></td>
                                                <td><b>Type</b></td>
                                                <td><b>Description</b></td>
                                            </tr>
                                            <tr>
                                                <td>Address Type</td>
                                                <td>uint8</td>
                                                <td>
                                                    Set to <strong>value 16</strong> to denote an <i>NFT Address</i>.
                                                </td>
                                            </tr>
                                            <tr>
                                                <td>NFT ID</td>
                                                <td>ByteArray[32]</td>
                                                <td>The raw bytes of the <i>NFT ID</i> which is the BLAKE2b-256 hash of the outputID that created it.</td>
                                            </tr>
                                        </table>
                                    </details>
                                </td>
                            </tr>
                            <tr>
                                <td>Unix Time</td>
                                <td>uint32</td>
                                <td>
                                    Before this unix time, <i>Address Unlock Condition</i> is allowed to unlock the output, after that only the address defined in <i>Return Address</i>.
                                </td>
                            </tr>
                        </table>
                    </details>
                </td>
            </tr>
            <tr>
                <td>Features Count</td>
                <td>uint8</td>
                <td>The number of features following.</td>
            </tr>
            <tr>
                <td valign="top">Features <code>atMostOneOfEach</code></td>
                <td colspan="2">
                    <details>
                        <summary>Sender Feature</summary>
                        <blockquote>
                            Identifies the validated sender of the output.
                        </blockquote>
                        <table>
                            <tr>
                                <td><b>Name</b></td>
                                <td><b>Type</b></td>
                                <td><b>Description</b></td>
                            </tr>
                            <tr>
                                <td>Feature Type</td>
                                <td>uint8</td>
                                <td>
                                    Set to <strong>value 0</strong> to denote a <i>Sender Feature</i>.
                                </td>
                            </tr>
                            <tr>
                                <td valign="top">Address <code>oneOf</code></td>
                                <td colspan="2">
                                    <details>
                                        <summary>Ed25519 Address</summary>
                                        <table>
                                            <tr>
                                                <td><b>Name</b></td>
                                                <td><b>Type</b></td>
                                                <td><b>Description</b></td>
                                            </tr>
                                            <tr>
                                                <td>Address Type</td>
                                                <td>uint8</td>
                                                <td>
                                                    Set to <strong>value 0</strong> to denote an <i>Ed25519 Address</i>.
                                                </td>
                                            </tr>
                                            <tr>
                                                <td>PubKeyHash</td>
                                                <td>ByteArray[32]</td>
                                                <td>The raw bytes of the Ed25519 address which is a BLAKE2b-256 hash of the Ed25519 public key.</td>
                                            </tr>
                                        </table>
                                    </details>
                                    <details>
                                        <summary>Alias Address</summary>
                                        <table>
                                            <tr>
                                                <td><b>Name</b></td>
                                                <td><b>Type</b></td>
                                                <td><b>Description</b></td>
                                            </tr>
                                            <tr>
                                                <td>Address Type</td>
                                                <td>uint8</td>
                                                <td>
                                                    Set to <strong>value 8</strong> to denote an <i>Alias Address</i>.
                                                </td>
                                            </tr>
                                            <tr>
                                                <td>Alias ID</td>
                                                <td>ByteArray[32]</td>
                                                <td>The raw bytes of the <i>Alias ID</i> which is the BLAKE2b-256 hash of the outputID that created it.</td>
                                            </tr>
                                        </table>
                                    </details>
                                    <details>
                                        <summary>NFT Address</summary>
                                        <table>
                                            <tr>
                                                <td><b>Name</b></td>
                                                <td><b>Type</b></td>
                                                <td><b>Description</b></td>
                                            </tr>
                                            <tr>
                                                <td>Address Type</td>
                                                <td>uint8</td>
                                                <td>
                                                    Set to <strong>value 16</strong> to denote an <i>NFT Address</i>.
                                                </td>
                                            </tr>
                                            <tr>
                                                <td>NFT ID</td>
                                                <td>ByteArray[32]</td>
                                                <td>The raw bytes of the <i>NFT ID</i> which is the BLAKE2b-256 hash of the outputID that created it.</td>
                                            </tr>
                                        </table>
                                    </details>
                                </td>
                            </tr>
                        </table>
                    </details>
                    <details>
                        <summary>Metadata Feature</summary>
                        <blockquote>
                            Defines metadata (arbitrary binary data) that will be stored in the output.
                        </blockquote>
                        <table>
                            <tr>
                                <td><b>Name</b></td>
                                <td><b>Type</b></td>
                                <td><b>Description</b></td>
                            </tr>
                            <tr>
                                <td>Feature Type</td>
                                <td>uint8</td>
                                <td>
                                    Set to <strong>value 2</strong> to denote a <i>Metadata Feature</i>.
                                </td>
                            </tr>
                            <tr>
                                <td>Data</td>
                                <td>(uint16)ByteArray</td>
                                <td>Binary data. A leading uint16 denotes its length.</td>
                            </tr>
                        </table>
                    </details>
                    <details>
                        <summary>Tag Feature</summary>
                        <blockquote>
                            Defines an indexation tag to which the output can be indexed by additional node plugins.
                        </blockquote>
                        <table>
                            <tr>
                                <td><b>Name</b></td>
                                <td><b>Type</b></td>
                                <td><b>Description</b></td>
                            </tr>
                            <tr>
                                <td>Feature Type</td>
                                <td>uint8</td>
                                <td>
                                    Set to <strong>value 3</strong> to denote a <i>Tag Feature</i>.
                                </td>
                            </tr>
                            <tr>
                                <td>Tag</td>
                                <td>(uint8)ByteArray</td>
                                <td>Binary indexation data. A leading uint8 denotes its length.</td>
                            </tr>
                        </table>
                    </details>
                </td>
            </tr>
        </table>
    </details>
</table>
<h3 id="additional-transaction-syntactic-validation-rules"><a class="header" href="#additional-transaction-syntactic-validation-rules">Additional Transaction Syntactic Validation Rules</a></h3>
<ul>
<li><code>Amount</code> field must fulfill the dust protection requirements and must not be <code>0</code>.</li>
<li><code>Amount</code> field must be ≤ <code>Max IOTA Supply</code>.</li>
<li><code>Native Tokens Count</code> must not be greater than <code>Max Native Tokens Count</code>.</li>
<li><code>Native Tokens</code> must be lexicographically sorted based on <code>Token ID</code>.</li>
<li>Each <i>Native Token</i> must be unique in the set of <code>Native Tokens</code> based on its <code>Token ID</code>. No duplicates are
allowed.</li>
<li><code>Amount</code> of any <i>Native Token</i> must not be <code>0</code>.</li>
<li>It must hold true that <code>1</code> ≤ <code>Unlock Conditions Count</code> ≤ <code>4</code>.</li>
<li><code>Unlock Condition Type</code> of an <i>Unlock Condition</i> must define one of the following types:
<ul>
<li><i>Address Unlock Condition</i></li>
<li><i>Storage Deposit Return Unlock Condition</i></li>
<li><i>Timelock Unlock Condition</i></li>
<li><i>Expiration Unlock Condition</i></li>
</ul>
</li>
<li><i>Unlock Conditions</i> must be sorted in ascending order based on their <code>Unlock Condition Type</code>.</li>
<li>Syntactic validation of all present unlock conditions must pass.</li>
<li><i>Address Unlock Condition</i> must be present.</li>
<li>It must hold true that <code>0</code> ≤ <code>Features Count</code> ≤ <code>3</code>.</li>
<li><code>Feature Type</code> of a <i>Feature</i> must define one of the following types:
<ul>
<li><i>Sender Feature</i></li>
<li><i>Metadata Feature</i></li>
<li><i>Tag Feature</i></li>
</ul>
</li>
<li><i>Features</i> must be sorted in ascending order based on their <code>Feature Type</code>.</li>
<li>Syntactic validation of all present features must pass.</li>
</ul>
<h3 id="additional-transaction-semantic-validation-rules"><a class="header" href="#additional-transaction-semantic-validation-rules">Additional Transaction Semantic Validation Rules</a></h3>
<h4 id="consumed-outputs"><a class="header" href="#consumed-outputs">Consumed Outputs</a></h4>
<ul>
<li>The unlock of the input must correspond to <code>Address</code> field in the <i>Address Unlock Condition</i> and the
unlock must be valid.</li>
<li>The unlock is valid if and only if all unlock conditions and features present in the output validate.</li>
</ul>
<h4 id="created-outputs"><a class="header" href="#created-outputs">Created Outputs</a></h4>
<ul>
<li>All <i>Unlock Condition</i> imposed transaction validation criteria must be fulfilled.</li>
<li>All <i>Feature</i> imposed transaction validation criteria must be fulfilled.</li>
</ul>
<h2 id="alias-output"><a class="header" href="#alias-output">Alias Output</a></h2>
<p>The <i>Alias Output</i> is a specific implementation of a UTXO state machine. <code>Alias ID</code>, the unique identifier of an
instance of the deployed state machine, is generated deterministically by the protocol and is not allowed to change in
any future state transitions.</p>
<p><i>Alias Output</i> represents an alias account in the ledger with two control levels and a permanent
<i>Alias Address</i>. The account owns other outputs that are locked under <i>Alias Address</i>. The account keeps
track of state transitions (<code>State Index</code> counter), controlled foundries (<code>Foundry Counter</code>) and anchors the layer 2
state as metadata into the UTXO ledger.</p>
<table>
    <details>
        <summary>Alias Output</summary>
        <blockquote>
            Describes an alias account in the ledger that can be controlled by the state and governance controllers.
        </blockquote>
        <table>
            <tr>
                <td><b>Name</b></td>
                <td><b>Type</b></td>
                <td><b>Description</b></td>
            </tr>
            <tr>
                <td>Output Type</td>
                <td>uint8</td>
                <td>
                    Set to <strong>value 4</strong> to denote a <i>Alias Output</i>.
                </td>
            </tr>
            <tr>
                <td>Amount</td>
                <td>uint64</td>
                <td>The amount of IOTA coins held by the output.</td>
            </tr>
            <tr>
                <td>Native Tokens Count</td>
                <td>uint8</td>
                <td>The number of native tokens held by the output.</td>
            </tr>
            <tr>
                <td valign="top">Native Tokens <code>optAnyOf</code></td>
                <td colspan="2">
                    <details>
                        <summary>Native Token</summary>
                        <table>
                            <tr>
                                <td><b>Name</b></td>
                                <td><b>Type</b></td>
                                <td><b>Description</b></td>
                            </tr>
                            <tr>
                                <td>Token ID</td>
                                <td>ByteArray[38]</td>
                                <td>
                                    Identifier of the native token.
                                </td>
                            </tr>
                            <tr>
                                <td>Amount</td>
                                <td>uint256</td>
                                <td>
                                    Amount of native tokens of the given <i>Token ID</i>.
                                </td>
                            </tr>
                        </table>
                    </details>
                </td>
            </tr>
            <tr>
                <td>Alias ID</td>
                <td>ByteArray[32]</td>
                <td>Unique identifier of the alias, which is the BLAKE2b-256 hash of the <i>Output ID</i> that created it.<i> Alias Address = Alias Address Type || Alias ID</i></td>
            </tr>
            <tr>
                <td>State Index</td>
                <td>uint32</td>
                <td>A counter that must increase by 1 every time the alias is state transitioned.</td>
            </tr>
            <tr>
                <td>State Metadata</td>
                <td>(uint16)ByteArray</td>
                <td>Metadata that can only be changed by the state controller. A leading uint16 denotes its length.</td>
            </tr>
            <tr>
                <td>Foundry Counter</td>
                <td>uint32</td>
                <td>A counter that denotes the number of foundries created by this alias account.</td>
            </tr>
            <tr>
                <td>Unlock Conditions Count</td>
                <td>uint8</td>
                <td>The number of unlock conditions following.</td>
            </tr>
            <tr>
                <td valign="top">Unlock Conditions <code>atMostOneOfEach</code></td>
                <td colspan="2">
                    <details>
                        <summary>State Controller Address Unlock Condition</summary>
                        <table>
                            <tr>
                                <td><b>Name</b></td>
                                <td><b>Type</b></td>
                                <td><b>Description</b></td>
                            </tr>
                            <tr>
                                <td>Unlock Condition Type</td>
                                <td>uint8</td>
                                <td>
                                    Set to <strong>value 4</strong> to denote an <i>State Controller Address Unlock Condition</i>.
                                </td>
                            </tr>
                            <tr>
                                <td>Address</td>
                                <td colspan="2">
                                    <details>
                                        <summary>Ed25519 Address</summary>
                                        <table>
                                            <tr>
                                                <td><b>Name</b></td>
                                                <td><b>Type</b></td>
                                                <td><b>Description</b></td>
                                            </tr>
                                            <tr>
                                                <td>Address Type</td>
                                                <td>uint8</td>
                                                <td>
                                                    Set to <strong>value 0</strong> to denote an <i>Ed25519 Address</i>.
                                                </td>
                                            </tr>
                                            <tr>
                                                <td>PubKeyHash</td>
                                                <td>ByteArray[32]</td>
                                                <td>The raw bytes of the Ed25519 address which is a BLAKE2b-256 hash of the Ed25519 public key.</td>
                                            </tr>
                                        </table>
                                    </details>
                                    <details>
                                        <summary>Alias Address</summary>
                                        <table>
                                            <tr>
                                                <td><b>Name</b></td>
                                                <td><b>Type</b></td>
                                                <td><b>Description</b></td>
                                            </tr>
                                            <tr>
                                                <td>Address Type</td>
                                                <td>uint8</td>
                                                <td>
                                                    Set to <strong>value 8</strong> to denote an <i>Alias Address</i>.
                                                </td>
                                            </tr>
                                            <tr>
                                                <td>Alias ID</td>
                                                <td>ByteArray[32]</td>
                                                <td>The raw bytes of the <i>Alias ID</i> which is the BLAKE2b-256 hash of the outputID that created it.</td>
                                            </tr>
                                        </table>
                                    </details>
                                    <details>
                                        <summary>NFT Address</summary>
                                        <table>
                                            <tr>
                                                <td><b>Name</b></td>
                                                <td><b>Type</b></td>
                                                <td><b>Description</b></td>
                                            </tr>
                                            <tr>
                                                <td>Address Type</td>
                                                <td>uint8</td>
                                                <td>
                                                    Set to <strong>value 16</strong> to denote an <i>NFT Address</i>.
                                                </td>
                                            </tr>
                                            <tr>
                                                <td>NFT ID</td>
                                                <td>ByteArray[32]</td>
                                                <td>The raw bytes of the <i>NFT ID</i> which is the BLAKE2b-256 hash of the outputID that created it.</td>
                                            </tr>
                                        </table>
                                    </details>
                                </td>
                            </tr>
                        </table>
                    </details>
                    <details>
                        <summary>Governor Address Unlock Condition</summary>
                        <table>
                            <tr>
                                <td><b>Name</b></td>
                                <td><b>Type</b></td>
                                <td><b>Description</b></td>
                            </tr>
                            <tr>
                                <td>Unlock Condition Type</td>
                                <td>uint8</td>
                                <td>
                                    Set to <strong>value 5</strong> to denote an <i>Governor Address Unlock Condition</i>.
                                </td>
                            </tr>
                            <tr>
                                <td>Address</td>
                                <td colspan="2">
                                    <details>
                                        <summary>Ed25519 Address</summary>
                                        <table>
                                            <tr>
                                                <td><b>Name</b></td>
                                                <td><b>Type</b></td>
                                                <td><b>Description</b></td>
                                            </tr>
                                            <tr>
                                                <td>Address Type</td>
                                                <td>uint8</td>
                                                <td>
                                                    Set to <strong>value 0</strong> to denote an <i>Ed25519 Address</i>.
                                                </td>
                                            </tr>
                                            <tr>
                                                <td>PubKeyHash</td>
                                                <td>ByteArray[32]</td>
                                                <td>The raw bytes of the Ed25519 address which is a BLAKE2b-256 hash of the Ed25519 public key.</td>
                                            </tr>
                                        </table>
                                    </details>
                                    <details>
                                        <summary>Alias Address</summary>
                                        <table>
                                            <tr>
                                                <td><b>Name</b></td>
                                                <td><b>Type</b></td>
                                                <td><b>Description</b></td>
                                            </tr>
                                            <tr>
                                                <td>Address Type</td>
                                                <td>uint8</td>
                                                <td>
                                                    Set to <strong>value 8</strong> to denote an <i>Alias Address</i>.
                                                </td>
                                            </tr>
                                            <tr>
                                                <td>Alias ID</td>
                                                <td>ByteArray[32]</td>
                                                <td>The raw bytes of the <i>Alias ID</i> which is the BLAKE2b-256 hash of the outputID that created it.</td>
                                            </tr>
                                        </table>
                                    </details>
                                    <details>
                                        <summary>NFT Address</summary>
                                        <table>
                                            <tr>
                                                <td><b>Name</b></td>
                                                <td><b>Type</b></td>
                                                <td><b>Description</b></td>
                                            </tr>
                                            <tr>
                                                <td>Address Type</td>
                                                <td>uint8</td>
                                                <td>
                                                    Set to <strong>value 16</strong> to denote an <i>NFT Address</i>.
                                                </td>
                                            </tr>
                                            <tr>
                                                <td>NFT ID</td>
                                                <td>ByteArray[32]</td>
                                                <td>The raw bytes of the <i>NFT ID</i> which is the BLAKE2b-256 hash of the outputID that created it.</td>
                                            </tr>
                                        </table>
                                    </details>
                                </td>
                            </tr>
                        </table>
                    </details>
                </td>
            </tr>
            <tr>
                <td>Features Count</td>
                <td>uint8</td>
                <td>The number of features following.</td>
            </tr>
            <tr>
                <td valign="top">Features <code>atMostOneOfEach</code></td>
                <td colspan="2">
                    <details>
                        <summary>Sender Feature</summary>
                        <blockquote>
                            Identifies the validated sender of the output.
                        </blockquote>
                        <table>
                            <tr>
                                <td><b>Name</b></td>
                                <td><b>Type</b></td>
                                <td><b>Description</b></td>
                            </tr>
                            <tr>
                                <td>Feature Type</td>
                                <td>uint8</td>
                                <td>
                                    Set to <strong>value 0</strong> to denote a <i>Sender Feature</i>.
                                </td>
                            </tr>
                            <tr>
                                <td valign="top">Address <code>oneOf</code></td>
                                <td colspan="2">
                                    <details>
                                        <summary>Ed25519 Address</summary>
                                        <table>
                                            <tr>
                                                <td><b>Name</b></td>
                                                <td><b>Type</b></td>
                                                <td><b>Description</b></td>
                                            </tr>
                                            <tr>
                                                <td>Address Type</td>
                                                <td>uint8</td>
                                                <td>
                                                    Set to <strong>value 0</strong> to denote an <i>Ed25519 Address</i>.
                                                </td>
                                            </tr>
                                            <tr>
                                                <td>PubKeyHash</td>
                                                <td>ByteArray[32]</td>
                                                <td>The raw bytes of the Ed25519 address which is a BLAKE2b-256 hash of the Ed25519 public key.</td>
                                            </tr>
                                        </table>
                                    </details>
                                    <details>
                                        <summary>Alias Address</summary>
                                        <table>
                                            <tr>
                                                <td><b>Name</b></td>
                                                <td><b>Type</b></td>
                                                <td><b>Description</b></td>
                                            </tr>
                                            <tr>
                                                <td>Address Type</td>
                                                <td>uint8</td>
                                                <td>
                                                    Set to <strong>value 8</strong> to denote an <i>Alias Address</i>.
                                                </td>
                                            </tr>
                                            <tr>
                                                <td>Alias ID</td>
                                                <td>ByteArray[32]</td>
                                                <td>The raw bytes of the <i>Alias ID</i> which is the BLAKE2b-256 hash of the outputID that created it.</td>
                                            </tr>
                                        </table>
                                    </details>
                                    <details>
                                        <summary>NFT Address</summary>
                                        <table>
                                            <tr>
                                                <td><b>Name</b></td>
                                                <td><b>Type</b></td>
                                                <td><b>Description</b></td>
                                            </tr>
                                            <tr>
                                                <td>Address Type</td>
                                                <td>uint8</td>
                                                <td>
                                                    Set to <strong>value 16</strong> to denote an <i>NFT Address</i>.
                                                </td>
                                            </tr>
                                            <tr>
                                                <td>NFT ID</td>
                                                <td>ByteArray[32]</td>
                                                <td>The raw bytes of the <i>NFT ID</i> which is the BLAKE2b-256 hash of the outputID that created it.</td>
                                            </tr>
                                        </table>
                                    </details>
                                </td>
                            </tr>
                        </table>
                    </details>
                    <details>
                        <summary>Metadata Feature</summary>
                        <blockquote>
                            Defines metadata (arbitrary binary data) that will be stored in the output.
                        </blockquote>
                        <table>
                            <tr>
                                <td><b>Name</b></td>
                                <td><b>Type</b></td>
                                <td><b>Description</b></td>
                            </tr>
                            <tr>
                                <td>Feature Type</td>
                                <td>uint8</td>
                                <td>
                                    Set to <strong>value 2</strong> to denote a <i>Metadata Feature</i>.
                                </td>
                            </tr>
                            <tr>
                                <td>Data</td>
                                <td>(uint16)ByteArray</td>
                                <td>Binary data. A leading uint16 denotes its length.</td>
                            </tr>
                        </table>
                    </details>
                </td>
            </tr>
            <tr>
                <td>Immutable Features Count</td>
                <td>uint8</td>
                <td>The number of immutable features following. Immutable features are defined upon deployment of the UTXO state machine and are not allowed to change in any future state transition.</td>
            </tr>
            <tr>
                <td valign="top">Immutable Features <code>atMostOneOfEach</code></td>
                <td colspan="2">
                    <details>
                        <summary>Issuer Feature</summary>
                        <blockquote>
                            Identifies the validated issuer of the UTXO state machine.
                        </blockquote>
                        <table>
                            <tr>
                                <td><b>Name</b></td>
                                <td><b>Type</b></td>
                                <td><b>Description</b></td>
                            </tr>
                            <tr>
                                <td>Feature Type</td>
                                <td>uint8</td>
                                <td>
                                    Set to <strong>value 1</strong> to denote an <i>Issuer Feature</i>.
                                </td>
                            </tr>
                            <tr>
                                <td valign="top">Address <code>oneOf</code></td>
                                <td colspan="2">
                                    <details>
                                        <summary>Ed25519 Address</summary>
                                        <table>
                                            <tr>
                                                <td><b>Name</b></td>
                                                <td><b>Type</b></td>
                                                <td><b>Description</b></td>
                                            </tr>
                                            <tr>
                                                <td>Address Type</td>
                                                <td>uint8</td>
                                                <td>
                                                    Set to <strong>value 0</strong> to denote an <i>Ed25519 Address</i>.
                                                </td>
                                            </tr>
                                            <tr>
                                                <td>PubKeyHash</td>
                                                <td>ByteArray[32]</td>
                                                <td>The raw bytes of the Ed25519 address which is a BLAKE2b-256 hash of the Ed25519 public key.</td>
                                            </tr>
                                        </table>
                                    </details>
                                    <details>
                                        <summary>Alias Address</summary>
                                        <table>
                                            <tr>
                                                <td><b>Name</b></td>
                                                <td><b>Type</b></td>
                                                <td><b>Description</b></td>
                                            </tr>
                                            <tr>
                                                <td>Address Type</td>
                                                <td>uint8</td>
                                                <td>
                                                    Set to <strong>value 8</strong> to denote an <i>Alias Address</i>.
                                                </td>
                                            </tr>
                                            <tr>
                                                <td>Alias ID</td>
                                                <td>ByteArray[32]</td>
                                                <td>The raw bytes of the <i>Alias ID</i> which is the BLAKE2b-256 hash of the outputID that created it.</td>
                                            </tr>
                                        </table>
                                    </details>
                                    <details>
                                        <summary>NFT Address</summary>
                                        <table>
                                            <tr>
                                                <td><b>Name</b></td>
                                                <td><b>Type</b></td>
                                                <td><b>Description</b></td>
                                            </tr>
                                            <tr>
                                                <td>Address Type</td>
                                                <td>uint8</td>
                                                <td>
                                                    Set to <strong>value 16</strong> to denote an <i>NFT Address</i>.
                                                </td>
                                            </tr>
                                            <tr>
                                                <td>NFT ID</td>
                                                <td>ByteArray[32]</td>
                                                <td>The raw bytes of the <i>NFT ID</i> which is the BLAKE2b-256 hash of the outputID that created it.</td>
                                            </tr>
                                        </table>
                                    </details>
                                </td>
                            </tr>
                        </table>
                    </details>
                    <details>
                        <summary>Metadata Feature</summary>
                        <blockquote>
                            Defines metadata (arbitrary binary data) that will be stored in the output.
                        </blockquote>
                        <table>
                            <tr>
                                <td><b>Name</b></td>
                                <td><b>Type</b></td>
                                <td><b>Description</b></td>
                            </tr>
                            <tr>
                                <td>Feature Type</td>
                                <td>uint8</td>
                                <td>
                                    Set to <strong>value 2</strong> to denote a <i>Metadata Feature</i>.
                                </td>
                            </tr>
                            <tr>
                                <td>Data</td>
                                <td>(uint16)ByteArray</td>
                                <td>Binary data. A leading uint16 denotes its length.</td>
                            </tr>
                        </table>
                    </details>
                </td>
            </tr>
        </table>
    </details>
</table>
<h3 id="additional-transaction-syntactic-validation-rules-1"><a class="header" href="#additional-transaction-syntactic-validation-rules-1">Additional Transaction Syntactic Validation Rules</a></h3>
<h4 id="output-syntactic-validation"><a class="header" href="#output-syntactic-validation">Output Syntactic Validation</a></h4>
<ul>
<li><code>Amount</code> field must fulfill the dust protection requirements and must not be <code>0</code>.</li>
<li><code>Amount</code> field must be ≤ <code>Max IOTA Supply</code>.</li>
<li><code>Native Tokens Count</code> must not be greater than <code>Max Native Tokens Count</code>.</li>
<li><code>Native Tokens</code> must be lexicographically sorted based on <code>Token ID</code>.</li>
<li>Each <i>Native Token</i> must be unique in the set of <code>Native Tokens</code> based on its <code>Token ID</code>. No duplicates are
allowed.</li>
<li><code>Amount</code> of any <i>Native Token</i> must not be <code>0</code>.</li>
<li>It must hold true that <code>Unlock Conditions Count</code> = <code>2</code>.</li>
<li><code>Unlock Condition Type</code> of an <i>Unlock Condition</i> must define one of the following types:
<ul>
<li><i>State Controller Address Unlock Condition</i></li>
<li><i>Governor Address Unlock Condition</i></li>
</ul>
</li>
<li><i>Unlock Conditions</i> must be sorted in ascending order based on their <code>Unlock Condition Type</code>.</li>
<li>Syntactic validation of all present unlock conditions must pass.</li>
<li>It must hold true that <code>0</code> ≤ <code>Features Count</code> ≤ <code>2</code>.</li>
<li><code>Feature Type</code> of a <i>Feature</i> in <code>Features</code> must define one of the following types:
<ul>
<li><i>Sender Feature</i></li>
<li><i>Metadata Feature</i></li>
</ul>
</li>
<li>It must hold true that <code>0</code> ≤ <code>Immutable Features Count</code> ≤ <code>2</code>.</li>
<li><code>Feature Type</code> of a <i>Feature</i> in <code>Immutable Features</code> must define on of the following types:
<ul>
<li><i>Issuer Feature</i></li>
<li><i>Metadata Feature</i></li>
</ul>
</li>
<li><i>Features</i> must be sorted in ascending order based on their <code>Feature Type</code> both in <code>Features</code> and <code>Immutable Features</code>
fields.</li>
<li>Syntactic validation of all present features must pass.</li>
<li>When <code>Alias ID</code> is zeroed out, <code>State Index</code> and <code>Foundry Counter</code> must be <code>0</code>.</li>
<li><code>length(State Metadata)</code> must not be greater than <code>Max Metadata Length</code>.</li>
<li><code>Address</code> of <i>State Controller Address Unlock Condition</i> and <code>Address</code> of
<i>Governor Address Unlock Condition</i> must be different from the alias address derived from <code>Alias ID</code>.</li>
</ul>
<h3 id="additional-transaction-semantic-validation-rules-1"><a class="header" href="#additional-transaction-semantic-validation-rules-1">Additional Transaction Semantic Validation Rules</a></h3>
<ul>
<li>Explicit <code>Alias ID</code>: <code>Alias ID</code> is taken as the value of the <code>Alias ID</code> field in the alias output.</li>
<li>Implicit <code>Alias ID</code>: When an alias output is consumed as an input in a transaction and <code>Alias ID</code> field is zeroed out
while <code>State Index</code> and <code>Foundry Counter</code> are zero, take the BLAKE2b-256 hash of the <code>Output ID</code> of the input as
<code>Alias ID</code>.</li>
<li>For every non-zero explicit <code>Alias ID</code> on the output side there must be a corresponding alias on the input side. The
corresponding alias has the explicit or implicit <code>Alias ID</code> equal to that of the alias on the output side.</li>
</ul>
<h4 id="consumed-outputs-1"><a class="header" href="#consumed-outputs-1">Consumed Outputs</a></h4>
<p>Whenever an alias output is consumed in a transaction, it means that the alias is transitioned into its next state. The
<strong>current state</strong> is defined as the <strong>consumed alias output</strong>, while the <strong>next state</strong> is defined as the <strong>alias
output with the same explicit <code>AliasID</code> on the output side</strong>. There are two types of transitions: <code>state transition</code>
and <code>governance transition</code>.</p>
<ul>
<li>State transition:
<ul>
<li>A state transition is identified by an incremented <code>State Index</code>.</li>
<li>The <code>State Index</code> must be incremented by 1.</li>
<li>The unlock must correspond to the <code>Address</code> of <i>State Controller Address Unlock Condition</i>.</li>
<li>State transition can only change the following fields in the next state:
<ul>
<li><code>IOTA Amount</code>,</li>
<li><code>Native Tokens</code>,</li>
<li><code>State Index</code>,</li>
<li><code>State Metadata</code>,</li>
<li><code>Foundry Counter</code> and</li>
<li><code>Sender Feature</code> in <code>Features</code>.</li>
</ul>
</li>
<li><code>Foundry Counter</code> field must increase by the number of foundry outputs created in the transaction that map to
<code>Alias ID</code>. The <code>Serial Number</code> fields of the created foundries must be the set of natural numbers that cover the
open-ended interval between the previous and next values of the <code>Foundry Counter</code> field in the alias output.</li>
<li>The created foundry outputs must be sorted in the list of outputs by their <code>Serial Number</code>. Note, that any
foundry that maps to <code>Alias ID</code> and has a <code>Serial Number</code> that is less or equal to the <code>Foundry Counter</code> of the
input alias is ignored when it comes to sorting.</li>
<li>Newly created foundries in the transaction that map to different aliases can be interleaved when it comes to
sorting.</li>
</ul>
</li>
<li>Governance transition:
<ul>
<li>A governance transition is identified by an unchanged <code>State Index</code> in next state. If there is no alias output on
the output side with a corresponding explicit <code>Alias ID</code>, the alias is being destroyed. The next state is the
empty state.</li>
<li>The unlock must correspond to the <code>Address</code> of <i>Governor Address Unlock Condition</i>.</li>
<li>Governance transition must only change the following fields:
<ul>
<li><code>Address</code> of <i>State Controller Address Unlock Condition</i>,</li>
<li><code>Address</code> of <i>Governor Address Unlock Condition</i>,</li>
<li><code>Metadata Feature</code> and <code>Sender Feature</code> in <code>Features</code>.</li>
</ul>
</li>
<li>The <code>Metadata Feature</code> is optional, the governor can put additional info about the chain here, for example chain
name, fee structure, supported VMs, list of access nodes, etc., anything that helps clients to fetch info (i.e.
account balances) about the layer 2 network.</li>
</ul>
</li>
<li>When a consumed alias output has <i>Features</i> defined in <code>Immutable Features</code> and a corresponding alias output on the
output side, <code>Immutable Features</code> is not allowed to change.</li>
</ul>
<h4 id="created-outputs-1"><a class="header" href="#created-outputs-1">Created Outputs</a></h4>
<ul>
<li>When <i>Issuer Feature</i> is present in an output and explicit <code>Alias ID</code> is zeroed out, an input with <code>Address</code> field
that corresponds to <code>Issuer</code> must be unlocked in the transaction.</li>
</ul>
<h3 id="notes"><a class="header" href="#notes">Notes</a></h3>
<ul>
<li><i>Governor Address Unlock Condition</i> field is made mandatory for now to help formal verification. When the same
entity is defined for state and governance controllers, the output is self governed. Later, for compression reasons,
it is possible to make the governance controller optional and define a self-governed alias as one that does not have
the governance <i>Governor Address Unlock Condition</i> set.</li>
<li>Indexers and node plugins shall map the alias address of the output derived with <code>Alias ID</code> to the regular
<i>address -&gt; output</i> mapping table, so that given an <i>Alias Address</i>, its most recent unspent alias output
can be retrieved.</li>
</ul>
<h2 id="foundry-output"><a class="header" href="#foundry-output">Foundry Output</a></h2>
<p>A foundry output is an output that <strong>controls the supply of user defined native tokens.</strong> It can mint and melt tokens
according to the <strong>policy</strong> defined in the <code>Token Scheme</code> field of the output. Foundries can only be created and
controlled by aliases.</p>
<p><strong>The concatenation of <code>Address</code> || <code>Serial Number</code> || <code>Token Scheme Type</code> fields defines the unique identifier of the
foundry, the <code>Foundry ID</code>.</strong></p>
<p>Upon creation of the foundry, the alias defined in the <code>Address</code> field of the
<i>Immutable Alias Address Unlock Condition</i> must be unlocked in the same transaction, and its <code>Foundry Counter</code>
field must increment. This incremented value defines <code>Serial Number</code>, while the <code>Token Scheme</code> can be chosen freely.</p>
<p><code>Foundry ID</code> is not allowed to change after deployment, therefore neither <code>Address</code>, nor <code>Serial Number</code> or
<code>Token Scheme</code> can change during the lifetime of the foundry.</p>
<p>Foundries control the supply of tokens with unique identifiers, so-called <code>Token IDs</code>. The **<code>Token ID</code> of tokens
controlled by a specific foundry is the same as the <strong><code>Foundry ID</code></strong>.</p>
<table>
    <details>
        <summary>Foundry Output</summary>
        <blockquote>
            Describes a foundry output that is controlled by an alias.
        </blockquote>
        <table>
            <tr>
                <td><b>Name</b></td>
                <td><b>Type</b></td>
                <td><b>Description</b></td>
            </tr>
            <tr>
                <td>Output Type</td>
                <td>uint8</td>
                <td>
                    Set to <strong>value 5</strong> to denote a <i>Foundry Output</i>.
                </td>
            </tr>
            <tr>
                <td>Amount</td>
                <td>uint64</td>
                <td>The amount of IOTA coins to held by the output.</td>
            </tr>
            <tr>
                <td>Native Tokens Count</td>
                <td>uint8</td>
                <td>The number of different native tokens held by the output.</td>
            </tr>
            <tr>
                <td valign="top">Native Tokens <code>optAnyOf</code></td>
                <td colspan="2">
                    <details>
                        <summary>Native Token</summary>
                        <table>
                            <tr>
                                <td><b>Name</b></td>
                                <td><b>Type</b></td>
                                <td><b>Description</b></td>
                            </tr>
                            <tr>
                                <td>Token ID</td>
                                <td>ByteArray[38]</td>
                                <td>
                                    Identifier of the native tokens.
                                </td>
                            </tr>
                            <tr>
                                <td>Amount</td>
                                <td>uint256</td>
                                <td>Amount of native tokens of the given <i>Token ID</i>.</td>
                            </tr>
                        </table>
                    </details>
                </td>
            </tr>
            <tr>
                <td>Serial Number</td>
                <td>uint32</td>
                <td>The serial number of the foundry with respect to the controlling alias.</td>
            </tr>
            <tr>
                <td valign="top">Token Scheme <code>oneOf</code></td>
                <td colspan="2">
                    <details>
                        <summary>Simple Token Scheme</summary>
                        <table>
                            <tr>
                                <td><b>Name</b></td>
                                <td><b>Type</b></td>
                                <td><b>Description</b></td>
                            </tr>
                            <tr>
                                <td>Token Scheme Type</td>
                                <td>uint8</td>
                                <td>
                                    Set to <strong>value 0</strong> to denote an <i>Simple Token Scheme</i>.
                                </td>
                            </tr>
                            <tr>
                                <td>Minted Tokens</td>
                                <td>uint256</td>
                                <td>Amount of tokens minted by this foundry.</td>
                            </tr>
                            <tr>
                                <td>Melted Tokens</td>
                                <td>uint256</td>
                                <td>Amount of tokens melted by this foundry.</td>
                            </tr>
                            <tr>
                                <td>Maximum Supply</td>
                                <td>uint256</td>
                                <td>Maximum supply of tokens controlled by this foundry.</td>
                            </tr>
                        </table>
                    </details>
                </td>
            </tr>
            <tr>
                <td>Unlock Conditions Count</td>
                <td>uint8</td>
                <td>The number of unlock conditions following.</td>
            </tr>
            <tr>
                <td valign="top">Unlock Conditions <code>atMostOneOfEach</code></td>
                <td colspan="2">
                    <details>
                        <summary>Immutable Alias Address Unlock Condition</summary>
                        <table>
                            <tr>
                                <td><b>Name</b></td>
                                <td><b>Type</b></td>
                                <td><b>Description</b></td>
                            </tr>
                            <tr>
                                <td>Unlock Condition Type</td>
                                <td>uint8</td>
                                <td>
                                    Set to <strong>value 6</strong> to denote an <i>Immutable Alias Address Unlock Condition</i>.
                                </td>
                            </tr>
                            <tr>
                                <td>Address</td>
                                <td colspan="2">
                                    <details>
                                        <summary>Alias Address</summary>
                                        <table>
                                            <tr>
                                                <td><b>Name</b></td>
                                                <td><b>Type</b></td>
                                                <td><b>Description</b></td>
                                            </tr>
                                            <tr>
                                                <td>Address Type</td>
                                                <td>uint8</td>
                                                <td>
                                                    Set to <strong>value 8</strong> to denote an <i>Alias Address</i>.
                                                </td>
                                            </tr>
                                            <tr>
                                                <td>Alias ID</td>
                                                <td>ByteArray[32]</td>
                                                <td>The raw bytes of the <i>Alias ID</i> which is the BLAKE2b-256 hash of the outputID that created it.</td>
                                            </tr>
                                        </table>
                                    </details>
                                </td>
                            </tr>
                        </table>
                    </details>
                </td>
            </tr>
            <tr>
                <td>Features Count</td>
                <td>uint8</td>
                <td>The number of features following.</td>
            </tr>
            <tr>
                <td valign="top">Features <code>atMostOneOfEach</code></td>
                <td colspan="2">
                    <details>
                        <summary>Metadata Feature</summary>
                        <blockquote>
                            Defines metadata (arbitrary binary data) that will be stored in the output.
                        </blockquote>
                        <table>
                            <tr>
                                <td><b>Name</b></td>
                                <td><b>Type</b></td>
                                <td><b>Description</b></td>
                            </tr>
                            <tr>
                                <td>Feature Type</td>
                                <td>uint8</td>
                                <td>
                                    Set to <strong>value 2</strong> to denote a <i>Metadata Feature</i>.
                                </td>
                            </tr>
                            <tr>
                                <td>Data</td>
                                <td>(uint16)ByteArray</td>
                                <td>Binary data. A leading uint16 denotes its length.</td>
                            </tr>
                        </table>
                    </details>
                </td>
            </tr>
            <tr>
                <td>Immutable Features Count</td>
                <td>uint8</td>
                <td>The number of immutable features following. Immutable features are defined upon deployment of the UTXO state machine and are not allowed to change in any future state transition.</td>
            </tr>
            <tr>
                <td valign="top">Immutable Features <code>atMostOneOfEach</code></td>
                <td colspan="2">
                    <details>
                        <summary>Metadata Feature</summary>
                        <blockquote>
                            Defines metadata (arbitrary binary data) that will be stored in the output.
                        </blockquote>
                        <table>
                            <tr>
                                <td><b>Name</b></td>
                                <td><b>Type</b></td>
                                <td><b>Description</b></td>
                            </tr>
                            <tr>
                                <td>Feature Type</td>
                                <td>uint8</td>
                                <td>
                                    Set to <strong>value 2</strong> to denote a <i>Metadata Feature</i>.
                                </td>
                            </tr>
                            <tr>
                                <td>Data</td>
                                <td>(uint16)ByteArray</td>
                                <td>Binary data. A leading uint16 denotes its length.</td>
                            </tr>
                        </table>
                    </details>
                </td>
            </tr>
        </table>
    </details>
</table>
<h3 id="additional-transaction-syntactic-validation-rules-2"><a class="header" href="#additional-transaction-syntactic-validation-rules-2">Additional Transaction Syntactic Validation Rules</a></h3>
<h4 id="output-syntactic-validation-1"><a class="header" href="#output-syntactic-validation-1">Output Syntactic Validation</a></h4>
<ul>
<li><code>Amount</code> field must fulfill the dust protection requirements and must not be <code>0</code>.</li>
<li><code>Amount</code> field must be ≤ <code>Max IOTA Supply</code>.</li>
<li><code>Native Tokens Count</code> must not be greater than <code>Max Native Tokens Count</code>.</li>
<li><code>Native Tokens</code> must be lexicographically sorted based on <code>Token ID</code>.</li>
<li>Each <i>Native Token</i> must be unique in the set of <code>Native Tokens</code> based on its <code>Token ID</code>. No duplicates are
allowed.</li>
<li><code>Amount</code> of any <i>Native Token</i> must not be <code>0</code>.</li>
<li>It must hold true that <code>Unlock Conditions Count</code> = <code>1</code>.</li>
<li><code>Unlock Condition Type</code> of an <i>Unlock Condition</i> must define one of the following types:
<ul>
<li><i>Immutable Alias Address Unlock Condition</i></li>
</ul>
</li>
<li>Syntactic validation of all present unlock conditions must pass.</li>
<li>It must hold true that <code>0</code> ≤ <code>Features Count</code> ≤ <code>1</code>.</li>
<li><code>Feature Type</code> of a <i>Feature</i> in <code>Features</code> must define one of the following types:
<ul>
<li><i>Metadata Feature</i></li>
</ul>
</li>
<li>It must hold true that <code>0</code> ≤ <code>Immutable Features Count</code> ≤ <code>1</code>.</li>
<li><code>Feature Type</code> of a <i>Feature</i> in <code>Immutable Features</code> must define one of the following types:
<ul>
<li><i>Metadata Feature</i></li>
</ul>
</li>
<li>Syntactic validation of all present features must pass.</li>
<li><code>Token Scheme</code> must define one of the following types:
<ul>
<li><i>Simple Token Scheme</i></li>
</ul>
</li>
</ul>
<h5 id="simple-token-scheme-syntactic-validation"><a class="header" href="#simple-token-scheme-syntactic-validation">Simple Token Scheme Syntactic Validation</a></h5>
<ul>
<li><code>Token Scheme Type</code> of a <i>Simple Token Scheme</i> must be <code>0</code>.</li>
<li><code>Minted Tokens</code> - <code>Melted Tokens</code> must not be greater than <code>Maximum Supply</code>.</li>
<li><code>Melted Tokens</code> must not be greater than <code>Minted Tokens</code>.</li>
<li><code>Maximum Supply</code> must be larger than zero.</li>
</ul>
<h3 id="additional-transaction-semantic-validation-rules-2"><a class="header" href="#additional-transaction-semantic-validation-rules-2">Additional Transaction Semantic Validation Rules</a></h3>
<p>A foundry is essentially a UTXO state machine. A transaction might either create a new foundry with a unique
<code>Foundry ID</code>, transition an already existing foundry or destroy it. The current and next states of the state machine
are encoded in inputs and outputs respectively.</p>
<ul>
<li>The <strong>current state of the foundry</strong> with <code>Foundry ID</code> <code>X</code> in a transaction is defined as the consumed foundry output
where <code>Foundry ID</code> = <code>X</code>.</li>
<li>The <strong>next state of the foundry</strong> with <code>Foundry ID</code> <code>X</code> in a transaction is defined as the created foundry output
where <code>Foundry ID</code> = <code>X</code>.</li>
<li><code>Foundry Diff</code> is the pair of the <strong>current and next state</strong> of the foundry output in the transaction.</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th>A transaction that...</th><th>Current State</th><th>Next State</th></tr></thead><tbody>
<tr><td>Creates the foundry</td><td>Empty</td><td>Output with <code>Foundry ID</code></td></tr>
<tr><td>Transitions the foundry</td><td>Input with <code>Foundry ID</code></td><td>Output with <code>Foundry ID</code></td></tr>
<tr><td>Destroys the foundry</td><td>Input with <code>Foundry ID</code></td><td>Empty</td></tr>
</tbody></table>
</div>
<ul>
<li>The foundry output must be unlocked like any other output type where the <strong>Address Unlock Condition</strong> defines an
<strong>Alias Address</strong>, by transitioning the alias in the very same transaction. See section
<a href="#unlocking-chain-script-locked-outputs">alias unlocking</a> for more details.</li>
<li>When the current state of the foundry with <code>Foundry ID</code> is empty, it must hold true for <code>Serial Number</code> in the next
state, that:
<ul>
<li><code>Foundry Counter(InputAlias) &lt; Serial Number &lt;= Foundry Counter(OutputAlias)</code></li>
<li>An alias can create several new foundries in one transaction. It was written for the alias output that freshly
created foundry outputs must be sorted in the list of outputs based on their <code>Serial Number</code>. No duplicates are
allowed.</li>
<li>The two previous rules make sure that each foundry output produced by an alias has a unique <code>Serial Number</code>,
hence each <code>Foundry ID</code> is unique.</li>
</ul>
</li>
<li>Native tokens present in a transaction are all native tokens present in inputs and outputs of the transaction. Native
tokens of a transaction must be a set based on their <code>Token ID</code>.</li>
<li>There must be at most one <code>Token ID</code> in the native token set of the transaction that maps to a specific <code>Foundry ID</code>.</li>
<li>When neither <code>Current State</code> nor <code>Next State</code> is empty:
<ul>
<li><i>Immutable Alias Address Unlock Condition</i> must not change.</li>
<li><code>Serial Number</code> must not change.</li>
<li><code>Token Scheme Type</code> must not change.</li>
<li><i>Features</i> in <code>Immutable Features</code> must not change.</li>
</ul>
</li>
<li><a href="#token-scheme-semantic-validation-rules">Token Scheme Semantic Validation Rules</a> must be fulfilled.</li>
</ul>
<h4 id="token-scheme-semantic-validation-rules"><a class="header" href="#token-scheme-semantic-validation-rules">Token Scheme Semantic Validation Rules</a></h4>
<p><code>Token Scheme Validation</code> takes <code>Token Diff</code> and <code>Foundry Diff</code> and validates if the scheme constraints are respected.</p>
<h5 id="simple-token-scheme-validation-rules"><a class="header" href="#simple-token-scheme-validation-rules">Simple Token Scheme Validation Rules</a></h5>
<ul>
<li>Let <code>Token Diff</code> denote the <strong>difference between native token balances of the input and the output side</strong> of the
transaction of the single <code>Token ID</code> that maps to the <code>Foundry ID</code>. Minting results in excess of tokens on the output
side (positive diff), melting results in excess on the input side (negative diff). Now, the following conditions must
hold for <code>Token Diff</code>:
<ol>
<li>When <code>Token Diff</code> &gt; 0</li>
</ol>
<ul>
<li><code>Current State(Minted Tokens) + Token Diff = Next State(Minted Tokens)</code>.</li>
<li><code>Current State(Melted Tokens) = Next State(Melted Tokens)</code></li>
</ul>
<ol start="2">
<li>When <code>Token Diff</code> &lt; 0, it must hold true that:</li>
</ol>
<ul>
<li><code>Current State(Melted Tokens) &lt;= Next State(Melted Tokens)</code></li>
<li><code>[Next State(Melted Tokens) - Current State(Melted Tokens)] &lt;= |Token Diff|</code>.</li>
<li>When <code>Current State(Melted Tokens) != Next State(Melted Tokens)</code>, it must be true that <code>Current State(Minted Tokens) = Next State(Minted Tokens)</code></li>
</ul>
<ol start="3">
<li>When <code>Current State</code> is empty, <code>Current State(Minted Tokens) = 0</code> and <code>Current State(Melted Tokens) = 0</code>.</li>
<li>When <code>Next State</code> is empty, condition <code>1</code> and <code>2</code> are ignored. It must hold true, that
<code>Current State(Minted Tokens) + Token Diff = Current State(Melted Tokens)</code></li>
</ol>
</li>
<li>When neither <code>Current State</code> nor <code>Next State</code> is empty:
<ul>
<li><code>Maximum Supply</code> field must not change.</li>
</ul>
</li>
</ul>
<h3 id="notes-1"><a class="header" href="#notes-1">Notes</a></h3>
<ul>
<li>A token scheme is a list of hard coded constraints. It is not feasible at the moment to foresee the future
needs/requirements of hard coded constraints, so it is impossible to design token schemes as any possible combination
of those constraints. A better design would be to have a list of possible constraints (and their related fields) from
which the user can choose. The chosen combination should still be encoded as a bitmask inside the <code>Token ID</code>.</li>
<li>Additional token schemes will be defined that make use of the <code>Foundry Diff</code> as well, for example validating that
a certain amount of tokens can only be minted/melted after a certain date.</li>
<li>For now, only token scheme <code>0</code> is supported. Additional token schemes will be designed iteratively when the need arises.</li>
<li>The <code>Foundry ID</code> of a foundry output should be queryable in indexers, so that given a <code>Foundry ID</code>, the
<code>Output ID</code> of the foundry output can be retrieved. <code>Foundry ID</code> behaves like an address that can't unlock anything.
While it is not necessarily needed for the protocol, it is needed for client side operations, such as:
<ul>
<li>Retrieving the current state of the foundry.</li>
<li>Accessing token metadata in foundry based on <code>Foundry ID</code>/<code>Tokend ID</code>.</li>
</ul>
</li>
</ul>
<h2 id="nft-output"><a class="header" href="#nft-output">NFT Output</a></h2>
<p>Non-fungible tokens in the ledger are implemented with a special output type, the so-called <i>NFTOutput</i>.</p>
<p>Each NFT output gets assigned a unique identifier <code>NFT ID</code> upon creation by the protocol. <code>NFT ID</code> is BLAKE2b-256 hash
of the <i>Output ID</i> that created the NFT. The address of the NFT is the concatenation of <code>NFT Address Type</code> ||
<code>NFT ID</code>.</p>
<p>The NFT may contain immutable metadata set upon creation, and a verified <code>Issuer</code>. The output type supports all
non-alias specific (state controller, governor) unlock conditions and optional features so that the output can be
sent as a request to smart contract chain accounts.</p>
<table>
    <details>
        <summary>NFT Output</summary>
        <blockquote>
            Describes an NFT output, a globally unique token with metadata attached.
        </blockquote>
        <table>
            <tr>
                <td><b>Name</b></td>
                <td><b>Type</b></td>
                <td><b>Description</b></td>
            </tr>
            <tr>
                <td>Output Type</td>
                <td>uint8</td>
                <td>
                    Set to <strong>value 6</strong> to denote a <i>NFT Output</i>.
                </td>
            </tr>
            <tr>
                <td>Amount</td>
                <td>uint64</td>
                <td>The amount of IOTA coins held by the output.</td>
            </tr>
            <tr>
                <td>Native Tokens Count</td>
                <td>uint8</td>
                <td>The number of native tokens held by the output.</td>
            </tr>
            <tr>
                <td valign="top">Native Tokens <code>optAnyOf</code></td>
                <td colspan="2">
                    <details>
                        <summary>Native Token</summary>
                        <table>
                            <tr>
                                <td><b>Name</b></td>
                                <td><b>Type</b></td>
                                <td><b>Description</b></td>
                            </tr>
                            <tr>
                                <td>Token ID</td>
                                <td>ByteArray[38]</td>
                                <td>
                                    Identifier of the native token.
                                </td>
                            </tr>
                            <tr>
                                <td>Amount</td>
                                <td>uint256</td>
                                <td>
                                    Amount of native tokens of the given <i>Token ID</i>.
                                </td>
                            </tr>
                        </table>
                    </details>
                </td>
            </tr>
            <tr>
                <td>NFT ID</td>
                <td>ByteArray[32]</td>
                <td>Unique identifier of the NFT, which is the BLAKE2b-256 hash of the <i>Output ID</i> that created it.<i> NFT Address = NFT Address Type || NFT ID</i></td>
            </tr>
            <tr>
                <td>Unlock Conditions Count</td>
                <td>uint8</td>
                <td>The number of unlock conditions following.</td>
            </tr>
            <tr>
                <td valign="top">Unlock Conditions <code>atMostOneOfEach</code></td>
                <td colspan="2">
                    <details>
                        <summary>Address Unlock Condition</summary>
                        <table>
                            <tr>
                                <td><b>Name</b></td>
                                <td><b>Type</b></td>
                                <td><b>Description</b></td>
                            </tr>
                            <tr>
                                <td>Unlock Condition Type</td>
                                <td>uint8</td>
                                <td>
                                    Set to <strong>value 0</strong> to denote an <i>Address Unlock Condition</i>.
                                </td>
                            </tr>
                            <tr>
                                <td>Address</td>
                                <td colspan="2">
                                    <details>
                                        <summary>Ed25519 Address</summary>
                                        <table>
                                            <tr>
                                                <td><b>Name</b></td>
                                                <td><b>Type</b></td>
                                                <td><b>Description</b></td>
                                            </tr>
                                            <tr>
                                                <td>Address Type</td>
                                                <td>uint8</td>
                                                <td>
                                                    Set to <strong>value 0</strong> to denote an <i>Ed25519 Address</i>.
                                                </td>
                                            </tr>
                                            <tr>
                                                <td>PubKeyHash</td>
                                                <td>ByteArray[32]</td>
                                                <td>The raw bytes of the Ed25519 address which is a BLAKE2b-256 hash of the Ed25519 public key.</td>
                                            </tr>
                                        </table>
                                    </details>
                                    <details>
                                        <summary>Alias Address</summary>
                                        <table>
                                            <tr>
                                                <td><b>Name</b></td>
                                                <td><b>Type</b></td>
                                                <td><b>Description</b></td>
                                            </tr>
                                            <tr>
                                                <td>Address Type</td>
                                                <td>uint8</td>
                                                <td>
                                                    Set to <strong>value 8</strong> to denote an <i>Alias Address</i>.
                                                </td>
                                            </tr>
                                            <tr>
                                                <td>Alias ID</td>
                                                <td>ByteArray[32]</td>
                                                <td>The raw bytes of the <i>Alias ID</i> which is the BLAKE2b-256 hash of the outputID that created it.</td>
                                            </tr>
                                        </table>
                                    </details>
                                    <details>
                                        <summary>NFT Address</summary>
                                        <table>
                                            <tr>
                                                <td><b>Name</b></td>
                                                <td><b>Type</b></td>
                                                <td><b>Description</b></td>
                                            </tr>
                                            <tr>
                                                <td>Address Type</td>
                                                <td>uint8</td>
                                                <td>
                                                    Set to <strong>value 16</strong> to denote an <i>NFT Address</i>.
                                                </td>
                                            </tr>
                                            <tr>
                                                <td>NFT ID</td>
                                                <td>ByteArray[32]</td>
                                                <td>The raw bytes of the <i>NFT ID</i> which is the BLAKE2b-256 hash of the outputID that created it.</td>
                                            </tr>
                                        </table>
                                    </details>
                                </td>
                            </tr>
                        </table>
                    </details>
                    <details>
                        <summary>Storage Deposit Return Unlock Condition</summary>
                        <blockquote>
                            Defines the amount of IOTAs used as storage deposit that have to be returned to <i>Return Address</i>.
                        </blockquote>
                        <table>
                            <tr>
                                <td><b>Name</b></td>
                                <td><b>Type</b></td>
                                <td><b>Description</b></td>
                            </tr>
                            <tr>
                                <td>Unlock Condition Type</td>
                                <td>uint8</td>
                                <td>
                                    Set to <strong>value 1</strong> to denote a <i>Storage Deposit Return Unlock Condition</i>.
                                </td>
                            </tr>
                            <tr>
                                <td valign="top">Return Address <code>oneOf</code></td>
                                <td colspan="2">
                                    <details>
                                        <summary>Ed25519 Address</summary>
                                        <table>
                                            <tr>
                                                <td><b>Name</b></td>
                                                <td><b>Type</b></td>
                                                <td><b>Description</b></td>
                                            </tr>
                                            <tr>
                                                <td>Address Type</td>
                                                <td>uint8</td>
                                                <td>
                                                    Set to <strong>value 0</strong> to denote an <i>Ed25519 Address</i>.
                                                </td>
                                            </tr>
                                            <tr>
                                                <td>PubKeyHash</td>
                                                <td>ByteArray[32]</td>
                                                <td>The raw bytes of the Ed25519 address which is a BLAKE2b-256 hash of the Ed25519 public key.</td>
                                            </tr>
                                        </table>
                                    </details>
                                    <details>
                                        <summary>Alias Address</summary>
                                        <table>
                                            <tr>
                                                <td><b>Name</b></td>
                                                <td><b>Type</b></td>
                                                <td><b>Description</b></td>
                                            </tr>
                                            <tr>
                                                <td>Address Type</td>
                                                <td>uint8</td>
                                                <td>
                                                    Set to <strong>value 8</strong> to denote an <i>Alias Address</i>.
                                                </td>
                                            </tr>
                                            <tr>
                                                <td>Alias ID</td>
                                                <td>ByteArray[32]</td>
                                                <td>The raw bytes of the <i>Alias ID</i> which is the BLAKE2b-256 hash of the outputID that created it.</td>
                                            </tr>
                                        </table>
                                    </details>
                                    <details>
                                        <summary>NFT Address</summary>
                                        <table>
                                            <tr>
                                                <td><b>Name</b></td>
                                                <td><b>Type</b></td>
                                                <td><b>Description</b></td>
                                            </tr>
                                            <tr>
                                                <td>Address Type</td>
                                                <td>uint8</td>
                                                <td>
                                                    Set to <strong>value 16</strong> to denote an <i>NFT Address</i>.
                                                </td>
                                            </tr>
                                            <tr>
                                                <td>NFT ID</td>
                                                <td>ByteArray[32]</td>
                                                <td>The raw bytes of the <i>NFT ID</i> which is the BLAKE2b-256 hash of the outputID that created it.</td>
                                            </tr>
                                        </table>
                                    </details>
                                </td>
                            </tr>
                            <tr>
                                <td>Return Amount</td>
                                <td>uint64</td>
                                <td>
                                    Amount of IOTA coins the consuming transaction should deposit to the address defined in <i>Return Address</i>.
                                </td>
                            </tr>
                        </table>
                    </details>
                    <details>
                        <summary>Timelock Unlock Condition</summary>
                        <blockquote>
                            Defines a unix timestamp until which the output can not be unlocked.
                        </blockquote>
                        <table>
                            <tr>
                                <td><b>Name</b></td>
                                <td><b>Type</b></td>
                                <td><b>Description</b></td>
                            </tr>
                            <tr>
                                <td>Unlock Condition Type</td>
                                <td>uint8</td>
                                <td>
                                    Set to <strong>value 2</strong> to denote a <i>Timelock Unlock Condition</i>.
                                </td>
                            </tr>
                            <tr>
                                <td>Unix Time</td>
                                <td>uint32</td>
                                <td>
                                    Unix time (seconds since Unix epoch) starting from which the output can be consumed.
                                </td>
                            </tr>
                        </table>
                    </details>
                    <details>
                        <summary>Expiration Unlock Condition</summary>
                        <blockquote>
                            Defines a unix time until which only <i>Address</i>, defined in <i>Address Unlock Condition</i>, is allowed to
                            unlock the output. After the unix time is reached or passed, only <i>Return Address</i> can unlock it.
                        </blockquote>
                        <table>
                            <tr>
                                <td><b>Name</b></td>
                                <td><b>Type</b></td>
                                <td><b>Description</b></td>
                            </tr>
                            <tr>
                                <td>Unlock Condition Type</td>
                                <td>uint8</td>
                                <td>
                                    Set to <strong>value 3</strong> to denote a <i>Expiration Unlock Condition</i>.
                                </td>
                            </tr>
                            <tr>
                                <td valign="top">Return Address <code>oneOf</code></td>
                                <td colspan="2">
                                    <details>
                                        <summary>Ed25519 Address</summary>
                                        <table>
                                            <tr>
                                                <td><b>Name</b></td>
                                                <td><b>Type</b></td>
                                                <td><b>Description</b></td>
                                            </tr>
                                            <tr>
                                                <td>Address Type</td>
                                                <td>uint8</td>
                                                <td>
                                                    Set to <strong>value 0</strong> to denote an <i>Ed25519 Address</i>.
                                                </td>
                                            </tr>
                                            <tr>
                                                <td>PubKeyHash</td>
                                                <td>ByteArray[32]</td>
                                                <td>The raw bytes of the Ed25519 address which is a BLAKE2b-256 hash of the Ed25519 public key.</td>
                                            </tr>
                                        </table>
                                    </details>
                                    <details>
                                        <summary>Alias Address</summary>
                                        <table>
                                            <tr>
                                                <td><b>Name</b></td>
                                                <td><b>Type</b></td>
                                                <td><b>Description</b></td>
                                            </tr>
                                            <tr>
                                                <td>Address Type</td>
                                                <td>uint8</td>
                                                <td>
                                                    Set to <strong>value 8</strong> to denote an <i>Alias Address</i>.
                                                </td>
                                            </tr>
                                            <tr>
                                                <td>Alias ID</td>
                                                <td>ByteArray[32]</td>
                                                <td>The raw bytes of the <i>Alias ID</i> which is the BLAKE2b-256 hash of the outputID that created it.</td>
                                            </tr>
                                        </table>
                                    </details>
                                    <details>
                                        <summary>NFT Address</summary>
                                        <table>
                                            <tr>
                                                <td><b>Name</b></td>
                                                <td><b>Type</b></td>
                                                <td><b>Description</b></td>
                                            </tr>
                                            <tr>
                                                <td>Address Type</td>
                                                <td>uint8</td>
                                                <td>
                                                    Set to <strong>value 16</strong> to denote an <i>NFT Address</i>.
                                                </td>
                                            </tr>
                                            <tr>
                                                <td>NFT ID</td>
                                                <td>ByteArray[32]</td>
                                                <td>The raw bytes of the <i>NFT ID</i> which is the BLAKE2b-256 hash of the outputID that created it.</td>
                                            </tr>
                                        </table>
                                    </details>
                                </td>
                            </tr>
                            <tr>
                                <td>Unix Time</td>
                                <td>uint32</td>
                                <td>
                                    Before this unix time, <i>Address Unlock Condition</i> is allowed to unlock the output, after that only the address defined in <i>Return Address</i>.
                                </td>
                            </tr>
                        </table>
                    </details>
                </td>
            </tr>
            <tr>
                <td>Features Count</td>
                <td>uint8</td>
                <td>The number of features following.</td>
            </tr>
            <tr>
                <td valign="top">Features <code>atMostOneOfEach</code></td>
                <td colspan="2">
                    <details>
                        <summary>Sender Feature</summary>
                        <blockquote>
                            Identifies the validated sender of the output.
                        </blockquote>
                        <table>
                            <tr>
                                <td><b>Name</b></td>
                                <td><b>Type</b></td>
                                <td><b>Description</b></td>
                            </tr>
                            <tr>
                                <td>Feature Type</td>
                                <td>uint8</td>
                                <td>
                                    Set to <strong>value 0</strong> to denote a <i>Sender Feature</i>.
                                </td>
                            </tr>
                            <tr>
                                <td valign="top">Address <code>oneOf</code></td>
                                <td colspan="2">
                                    <details>
                                        <summary>Ed25519 Address</summary>
                                        <table>
                                            <tr>
                                                <td><b>Name</b></td>
                                                <td><b>Type</b></td>
                                                <td><b>Description</b></td>
                                            </tr>
                                            <tr>
                                                <td>Address Type</td>
                                                <td>uint8</td>
                                                <td>
                                                    Set to <strong>value 0</strong> to denote an <i>Ed25519 Address</i>.
                                                </td>
                                            </tr>
                                            <tr>
                                                <td>PubKeyHash</td>
                                                <td>ByteArray[32]</td>
                                                <td>The raw bytes of the Ed25519 address which is a BLAKE2b-256 hash of the Ed25519 public key.</td>
                                            </tr>
                                        </table>
                                    </details>
                                    <details>
                                        <summary>Alias Address</summary>
                                        <table>
                                            <tr>
                                                <td><b>Name</b></td>
                                                <td><b>Type</b></td>
                                                <td><b>Description</b></td>
                                            </tr>
                                            <tr>
                                                <td>Address Type</td>
                                                <td>uint8</td>
                                                <td>
                                                    Set to <strong>value 8</strong> to denote an <i>Alias Address</i>.
                                                </td>
                                            </tr>
                                            <tr>
                                                <td>Alias ID</td>
                                                <td>ByteArray[32]</td>
                                                <td>The raw bytes of the <i>Alias ID</i> which is the BLAKE2b-256 hash of the outputID that created it.</td>
                                            </tr>
                                        </table>
                                    </details>
                                    <details>
                                        <summary>NFT Address</summary>
                                        <table>
                                            <tr>
                                                <td><b>Name</b></td>
                                                <td><b>Type</b></td>
                                                <td><b>Description</b></td>
                                            </tr>
                                            <tr>
                                                <td>Address Type</td>
                                                <td>uint8</td>
                                                <td>
                                                    Set to <strong>value 16</strong> to denote an <i>NFT Address</i>.
                                                </td>
                                            </tr>
                                            <tr>
                                                <td>NFT ID</td>
                                                <td>ByteArray[32]</td>
                                                <td>The raw bytes of the <i>NFT ID</i> which is the BLAKE2b-256 hash of the outputID that created it.</td>
                                            </tr>
                                        </table>
                                    </details>
                                </td>
                            </tr>
                        </table>
                    </details>
                    <details>
                        <summary>Metadata Feature</summary>
                        <blockquote>
                            Defines metadata (arbitrary binary data) that will be stored in the output.
                        </blockquote>
                        <table>
                            <tr>
                                <td><b>Name</b></td>
                                <td><b>Type</b></td>
                                <td><b>Description</b></td>
                            </tr>
                            <tr>
                                <td>Feature Type</td>
                                <td>uint8</td>
                                <td>
                                    Set to <strong>value 2</strong> to denote a <i>Metadata Feature</i>.
                                </td>
                            </tr>
                            <tr>
                                <td>Data</td>
                                <td>(uint16)ByteArray</td>
                                <td>Binary data. A leading uint16 denotes its length.</td>
                            </tr>
                        </table>
                    </details>
                    <details>
                        <summary>Tag Feature</summary>
                        <blockquote>
                            Defines an indexation tag to which the output can be indexed by additional node plugins.
                        </blockquote>
                        <table>
                            <tr>
                                <td><b>Name</b></td>
                                <td><b>Type</b></td>
                                <td><b>Description</b></td>
                            </tr>
                            <tr>
                                <td>Feature Type</td>
                                <td>uint8</td>
                                <td>
                                    Set to <strong>value 3</strong> to denote a <i>Tag Feature</i>.
                                </td>
                            </tr>
                            <tr>
                                <td>Tag</td>
                                <td>(uint8)ByteArray</td>
                                <td>Binary indexation data. A leading uint8 denotes its length.</td>
                            </tr>
                        </table>
                    </details>
                </td>
            </tr>
            <tr>
                <td>Immutable Features Count</td>
                <td>uint8</td>
                <td>The number of immutable features following. Immutable features are defined upon deployment of the UTXO state machine and are not allowed to change in any future state transition.</td>
            </tr>
            <tr>
                <td valign="top">Immutable Features <code>atMostOneOfEach</code></td>
                <td colspan="2">
                    <details>
                        <summary>Issuer Feature</summary>
                        <blockquote>
                            Identifies the validated issuer of the UTXO state machine.
                        </blockquote>
                        <table>
                            <tr>
                                <td><b>Name</b></td>
                                <td><b>Type</b></td>
                                <td><b>Description</b></td>
                            </tr>
                            <tr>
                                <td>Feature Type</td>
                                <td>uint8</td>
                                <td>
                                    Set to <strong>value 1</strong> to denote an <i>Issuer Feature</i>.
                                </td>
                            </tr>
                            <tr>
                                <td valign="top">Address <code>oneOf</code></td>
                                <td colspan="2">
                                    <details>
                                        <summary>Ed25519 Address</summary>
                                        <table>
                                            <tr>
                                                <td><b>Name</b></td>
                                                <td><b>Type</b></td>
                                                <td><b>Description</b></td>
                                            </tr>
                                            <tr>
                                                <td>Address Type</td>
                                                <td>uint8</td>
                                                <td>
                                                    Set to <strong>value 0</strong> to denote an <i>Ed25519 Address</i>.
                                                </td>
                                            </tr>
                                            <tr>
                                                <td>PubKeyHash</td>
                                                <td>ByteArray[32]</td>
                                                <td>The raw bytes of the Ed25519 address which is a BLAKE2b-256 hash of the Ed25519 public key.</td>
                                            </tr>
                                        </table>
                                    </details>
                                    <details>
                                        <summary>Alias Address</summary>
                                        <table>
                                            <tr>
                                                <td><b>Name</b></td>
                                                <td><b>Type</b></td>
                                                <td><b>Description</b></td>
                                            </tr>
                                            <tr>
                                                <td>Address Type</td>
                                                <td>uint8</td>
                                                <td>
                                                    Set to <strong>value 8</strong> to denote an <i>Alias Address</i>.
                                                </td>
                                            </tr>
                                            <tr>
                                                <td>Alias ID</td>
                                                <td>ByteArray[32]</td>
                                                <td>The raw bytes of the <i>Alias ID</i> which is the BLAKE2b-256 hash of the outputID that created it.</td>
                                            </tr>
                                        </table>
                                    </details>
                                    <details>
                                        <summary>NFT Address</summary>
                                        <table>
                                            <tr>
                                                <td><b>Name</b></td>
                                                <td><b>Type</b></td>
                                                <td><b>Description</b></td>
                                            </tr>
                                            <tr>
                                                <td>Address Type</td>
                                                <td>uint8</td>
                                                <td>
                                                    Set to <strong>value 16</strong> to denote an <i>NFT Address</i>.
                                                </td>
                                            </tr>
                                            <tr>
                                                <td>NFT ID</td>
                                                <td>ByteArray[32]</td>
                                                <td>The raw bytes of the <i>NFT ID</i> which is the BLAKE2b-256 hash of the outputID that created it.</td>
                                            </tr>
                                        </table>
                                    </details>
                                </td>
                            </tr>
                        </table>
                    </details>
                    <details>
                        <summary>Metadata Feature</summary>
                        <blockquote>
                            Defines metadata (arbitrary binary data) that will be stored in the output.
                        </blockquote>
                        <table>
                            <tr>
                                <td><b>Name</b></td>
                                <td><b>Type</b></td>
                                <td><b>Description</b></td>
                            </tr>
                            <tr>
                                <td>Feature Type</td>
                                <td>uint8</td>
                                <td>
                                    Set to <strong>value 2</strong> to denote a <i>Metadata Feature</i>.
                                </td>
                            </tr>
                            <tr>
                                <td>Data</td>
                                <td>(uint16)ByteArray</td>
                                <td>Binary data. A leading uint16 denotes its length.</td>
                            </tr>
                        </table>
                    </details>
                </td>
            </tr>
        </table>
    </details>
</table>
<h3 id="additional-transaction-syntactic-validation-rules-3"><a class="header" href="#additional-transaction-syntactic-validation-rules-3">Additional Transaction Syntactic Validation Rules</a></h3>
<h4 id="output-syntactic-validation-2"><a class="header" href="#output-syntactic-validation-2">Output Syntactic Validation</a></h4>
<ul>
<li><code>Amount</code> field must fulfill the dust protection requirements and must not be <code>0</code>.</li>
<li><code>Amount</code> field must be ≤ <code>Max IOTA Supply</code>.</li>
<li><code>Native Tokens Count</code> must not be greater than <code>Max Native Tokens Count</code>.</li>
<li><code>Native Tokens</code> must be lexicographically sorted based on <code>Token ID</code>.</li>
<li>Each <i>Native Token</i> must be unique in the set of <code>Native Tokens</code> based on its <code>Token ID</code>. No duplicates are
allowed.</li>
<li><code>Amount</code> of any <i>Native Token</i> must not be <code>0</code>.</li>
<li>It must hold true that <code>1</code> ≤ <code>Unlock Conditions Count</code> ≤ <code>4</code>.</li>
<li><code>Unlock Condition Type</code> of an <i>Unlock Condition</i> must define one of the following types:
<ul>
<li><i>Address Unlock Condition</i></li>
<li><i>Storage Deposit Return Unlock Condition</i></li>
<li><i>Timelock Unlock Condition</i></li>
<li><i>Expiration Unlock Condition</i></li>
</ul>
</li>
<li><i>Unlock Conditions</i> must be sorted in ascending order based on their <code>Unlock Condition Type</code>.</li>
<li>Syntactic validation of all present unlock conditions must pass.</li>
<li><i>Address Unlock Condition</i> must be present.</li>
<li>It must hold true that <code>0</code> ≤ <code>Features Count</code> ≤ <code>3</code>.</li>
<li><code>Feature Type</code> of a <i>Feature</i> in <code>Features</code> must define one of the following types:
<ul>
<li><i>Sender Feature</i></li>
<li><i>Metadata Feature</i></li>
<li><i>Tag Feature</i></li>
</ul>
</li>
<li>It must hold true that <code>0</code> ≤ <code>Immutable Features Count</code> ≤ <code>2</code>.</li>
<li><code>Feature Type</code> of a <i>Feature</i> in <code>Immutable Features</code> must define one of the following types:
<ul>
<li><i>Issuer Feature</i></li>
<li><i>Metadata Feature</i></li>
</ul>
</li>
<li><i>Features</i> must be sorted in ascending order based on their <code>Feature Type</code> both in <code>Features</code> and <code>Immutable Features</code>
fields.</li>
<li>Syntactic validation of all present features must pass.</li>
<li><code>Address</code> field of the <i>Address Unlock Condition</i> must not be the same as the NFT address derived from <code>NFT ID</code>.</li>
</ul>
<h3 id="additional-transaction-semantic-validation-rules-3"><a class="header" href="#additional-transaction-semantic-validation-rules-3">Additional Transaction Semantic Validation Rules</a></h3>
<ul>
<li>Explicit <code>NFT ID</code>: <code>NFT ID</code> is taken as the value of the <code>NFT ID</code> field in the NFT output.</li>
<li>Implicit <code>NFT ID</code>: When an NFT output is consumed as an input in a transaction and <code>NFT ID</code> field is zeroed out, take
the BLAKE2b-256 hash of the <code>Output ID</code> of the input as <code>NFT ID</code>.</li>
<li>For every non-zero explicit <code>NFT ID</code> on the output side there must be a corresponding NFT on the input side. The
corresponding NFT has the explicit or implicit <code>NFT ID</code> equal to that of the NFT on the output side.</li>
</ul>
<h4 id="consumed-outputs-2"><a class="header" href="#consumed-outputs-2">Consumed Outputs</a></h4>
<ul>
<li>The unlock of the input corresponds to <code>Address</code> field of the <i>Address Unlock Condition</i> and the unlock is
valid.</li>
<li>The unlock is valid if and only if all unlock conditions and features present in the output validate.</li>
<li>When a consumed NFT output has a corresponding NFT output on the output side, <code>Immutable Features</code> field must not
change.</li>
<li>When a consumed NFT output has no corresponding NFT output on the output side, the NFT it is being burned. Funds
and assets inside the burned NFT output must be redistributed to other outputs in the burning transaction.</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th>:bangbang:  Careful with NFT burning :bangbang:</th></tr></thead><tbody>
</tbody></table>
</div>
<p><em>Other outputs in the ledger that are locked to the address of the NFT can only be unlocked by including the NFT itself
in the transaction. If the NFT is burned, such funds are locked forever. It is strongly advised to always check and
sweep what the NFT owns in the ledger before burning it.</em></p>
<h4 id="created-outputs-2"><a class="header" href="#created-outputs-2">Created Outputs</a></h4>
<ul>
<li>When <code>Issuer Feature</code> is present in an output and explicit <code>NFT ID</code> is zeroed out, an input with <code>Address</code> field that
corresponds to <code>Issuer</code> must be unlocked in the transaction. If <code>Address</code> is either <i>Alias Address</i> or
<i>NFT Address</i>, their corresponding outputs (defined by <code>Alias ID</code> and <code>NFT ID</code>) must be unlocked in the transaction.</li>
<li>All <i>Unlock Condition</i> imposed transaction validation criteria must be fulfilled.</li>
<li>All <i>Feature</i> imposed transaction validation criteria must be fulfilled.</li>
</ul>
<h3 id="notes-2"><a class="header" href="#notes-2">Notes</a></h3>
<ul>
<li>It would be possible to have two-step issuer verification: First NFT is minted, and then metadata can be immutably
locked into the output. The metadata contains an issuer public key plus a signature of the unique <code>NFT ID</code>. This way
a smart contract chain can mint on behalf of the user, and then push the issuer signature in a next step.</li>
</ul>
<h2 id="unlocking-chain-script-locked-outputs"><a class="header" href="#unlocking-chain-script-locked-outputs">Unlocking Chain Script Locked Outputs</a></h2>
<p>Two of the introduced output types (<a href="#alias-output">Alias</a>, <a href="#nft-output">NFT</a>) implement the so-called UTXO chain
constraint. These outputs receive their unique identifiers upon creation, generated by the protocol, and carry it
forward with them through transactions until they are destroyed. These unique identifiers (<code>Alias ID</code>, <code>NFT ID</code>) also
function as global addresses for the state machines, but unlike <i>Ed25519 Addresses</i>, they are not backed by private
keys that could be used for signing. The rightful owners who can unlock these addresses are defined in the outputs
themselves.</p>
<p>Since such addresses are accounts in the ledger, it is possible to send funds to these addresses. The unlock mechanism
of such funds is designed in a way that <strong>proving ownership of the address is reduced to the ability to unlock the
corresponding output that defines the address.</strong></p>
<h3 id="alias-locking--unlocking"><a class="header" href="#alias-locking--unlocking">Alias Locking &amp; Unlocking</a></h3>
<p>A transaction may consume a (non-alias) output that belongs to an <i>Alias Address</i> by state transitioning the alias output with the matching <code>Alias ID</code>. This serves the exact same purpose as providing a signature
to unlock an output locked under a private key backed address, such as <i>Ed25519 Addresses</i>.</p>
<p>On protocol level, alias unlocking is done using a new unlock type, called <strong>Alias Unlock</strong>.</p>
<details>
    <summary>Alias Unlock</summary>
    <blockquote>
            Points to the unlock of a consumed alias output.
    </blockquote>
</details>
<table>
    <tr>
        <td><b>Name</b></td>
        <td><b>Type</b></td>
        <td><b>Description</b></td>
    </tr>
    <tr>
        <td>Unlock Type</td>
        <td>uint8</td>
        <td>
            Set to <strong>value 2</strong> to denote a <i>Alias Unlock</i>.
        </td>
    </tr>
    <tr>
        <td>Alias Reference Unlock Index</td>
        <td>uint16</td>
        <td>
            Index of input and unlock corresponding to an alias output.
        </td>
    </tr>
</table>
<p>This unlock is similar to the <i>Reference Unlock</i>. However, it is valid if and only if the input of the
transaction at index <code>Alias Reference Unlock Index</code> is an alias output with the same <code>Alias ID</code> as the one derived from
the <code>Address</code> field of the to-be unlocked output.</p>
<p>Additionally, the <i>Alias Unlocks</i> must also be ordered to prevent circular dependencies:</p>
<p>If the i-th <em>Unlock</em> of a transaction is an <em>Alias Unlock</em> and has <code>Alias Reference Unlock Index</code> set to k,
it must hold that i &gt; k. Hence, an <i>Alias Unlock</i> can only reference an <em>Unlock</em> (unlocking the
corresponding alias) at a smaller index.</p>
<p>For example the scenario where <code>Alias A</code> is locked to the address of <code>Alias B</code> while <code>Alias B</code> is in locked to the
address of <code>Alias A</code> introduces a circular dependency and is not well-defined. By requiring the <em>Unlocks</em> to be
ordered as described above, a transaction consuming <code>Alias A</code> as well as <code>Alias B</code> can never be valid as there would
always need to be one <em>Alias Unlock</em> referencing a greater index.</p>
<h4 id="alias-unlock-syntactic-validation"><a class="header" href="#alias-unlock-syntactic-validation">Alias Unlock Syntactic Validation</a></h4>
<ul>
<li>It must hold that 0 ≤ <code>Alias Reference Unlock Index</code> &lt; <code>Max Inputs Count</code>.</li>
</ul>
<h4 id="alias-unlock-semantic-validation"><a class="header" href="#alias-unlock-semantic-validation">Alias Unlock Semantic Validation</a></h4>
<ul>
<li>The address of the unlocking condition of the input being unlocked must be an <i>Alias Address</i>.</li>
<li>The index <code>i</code> of the <i>Alias Unlock</i> is the index of the input in the transaction that it unlocks.
<code>Alias Reference Unlock Index</code> must be &lt; <code>i</code>.</li>
<li><code>Alias Reference Unlock Index</code> defines a previous input of the transaction and its unlock. This input must
be an <i>Alias Output</i> with <code>Alias ID</code> that refers to the <i>Alias Address</i> being unlocked.</li>
<li>The referenced <i>Alias Output</i> must be unlocked for state transition.</li>
</ul>
<h3 id="nft-locking--unlocking"><a class="header" href="#nft-locking--unlocking">NFT Locking &amp; Unlocking</a></h3>
<p><code>NFT ID</code> field is functionally equivalent to <code>Alias ID</code> of an alias output. It is generated the same way, but it can
only exist in NFT outputs. Following the same analogy as for alias addresses, NFT addresses are iota addresses that are
controlled by whoever owns the NFT output itself.</p>
<p>Outputs that are locked under <code>NFT Address</code> can be unlocked by unlocking the NFT output in the same transaction that
defines <code>NFT Address</code>, that is, the NFT output where <code>NFT Address Type Byte || NFT ID = NFT Address</code>.</p>
<p>An <i>NFT Unlock</i> looks and behaves like an <i>Alias Unlock</i>, but the referenced input at the index must
be an NFT output with the matching <code>NFT ID</code>.</p>
<details>
    <summary>NFT Unlock</summary>
    <blockquote>
            Points to the unlock of a consumed NFT output.
    </blockquote>
</details>
<table>
    <tr>
        <td><b>Name</b></td>
        <td><b>Type</b></td>
        <td><b>Description</b></td>
    </tr>
    <tr>
        <td>Unlock Type</td>
        <td>uint8</td>
        <td>
            Set to <strong>value 3</strong> to denote a <i>NFT Unlock</i>.
        </td>
    </tr>
    <tr>
        <td>NFT Reference Unlock Index</td>
        <td>uint16</td>
        <td>
            Index of input and unlock corresponding to an NFT output.
        </td>
    </tr>
</table>
<p>An <em>NFT Unlock</em> is only valid if the input in the transaction at index <code>NFT Reference Unlock Index</code> is the NFT
output with the same <code>NFT ID</code> as the one derived from the <code>Address</code> field of the to-be unlocked output.</p>
<p>If the i-th <em>Unlock</em> of a transaction is an <em>NFT Unlock</em> and has <code>NFT Reference Unlock Index</code> set to k, it
must hold that i &gt; k. Hence, an <i>NFT Unlock</i> can only reference an <em>Unlock</em> at a smaller index.</p>
<h4 id="nft-unlock-syntactic-validation"><a class="header" href="#nft-unlock-syntactic-validation">NFT Unlock Syntactic Validation</a></h4>
<ul>
<li>It must hold that 0 ≤ <code>NFT Reference Unlock Index</code> &lt; <code>Max Inputs Count</code>.</li>
</ul>
<h4 id="nft-unlock-semantic-validation"><a class="header" href="#nft-unlock-semantic-validation">NFT Unlock Semantic Validation</a></h4>
<ul>
<li>The address of the input being unlocked must be an <i>NFT Address</i>.</li>
<li>The index <code>i</code> of the <i>NFT Unlock</i> is the index of the input in the transaction that it unlocks.
<code>NFT Reference Unlock Index</code> must be &lt; <code>i</code>.</li>
<li><code>NFT Reference Unlock Index</code> defines a previous input of the transaction and its unlock. This input must
be an <i>NFT Output</i> with <code>NFT ID</code> that refers to the <i>NFT Address</i> being unlocked.</li>
</ul>
<h1 id="drawbacks"><a class="header" href="#drawbacks">Drawbacks</a></h1>
<ul>
<li>New output types increase transaction validation complexity, however it is still bounded.</li>
<li>Outputs take up more space in the ledger, UTXO database size might increase.</li>
<li>It is possible to intentionally deadlock aliases and NFTs, however client side software can notify users when they
perform such action. Deadlocked aliases and NFTs can not be unlocked, but this is true for any funds locked into
unspendable addresses.</li>
<li>Time based output locking conditions can only be evaluated after attachment to the Tangle, during milestone
confirmation.</li>
<li>IOTA ledger can only support hard-coded scripts. Users can not write their own scripts because there is no way
currently to charge them based on resource usage, all IOTA transactions are feeless by nature.</li>
<li>Aliases can be destroyed even if there are foundries alive that they control. Since only the controlling alias can
unlock the foundry, such foundries and the supply of the tokens remain forever locked in the Tangle.</li>
<li>Token schemes and needed supply control rules are unclear.</li>
</ul>
<h1 id="rationale-and-alternatives"><a class="header" href="#rationale-and-alternatives">Rationale and alternatives</a></h1>
<p>The feeless nature of IOTA makes it inherently impossible to implement smart contracts on layer 1. A smart contract
platform shall not only be capable of executing smart contracts, but also to limit their resource usage and make users
pay validators for the used resources. IOTA has no concept of validators, neither fees. While it would technically be
possible to run EUTXO smart contracts on the layer 1 Tangle, it is not possible to properly charge users for executing
them.</p>
<p>The current design aims to combine the best of both worlds: Scalable and feeless layer 1 and  Turing-complete smart
contracts on layer 2. Layer 1 remains scalable because of parallel transaction validation, feeless because the bounded
hard-coded script execution time, and layer 2 can offer support for all kinds of virtual machines, smart contracts and
advanced tokenization use cases.</p>
<h1 id="unresolved-questions"><a class="header" href="#unresolved-questions">Unresolved questions</a></h1>
<ul>
<li>List of supported <i>Token Schemes</i> is not complete.
<ul>
<li>Deflationary token scheme</li>
<li>Inflationary token scheme with scheduled minting</li>
<li>etc.</li>
</ul>
</li>
<li>Adapt the current congestion control, i.e. <em>Block PoW</em>, to better match the validation complexity of the different
outputs and types.</li>
</ul>
<h2 id="copyright"><a class="header" href="#copyright">Copyright</a></h2>
<p>Copyright and related rights waived via <a href="https://creativecommons.org/publicdomain/zero/1.0/">CC0</a>.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../../tips/TIP-0017/tip-0017.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../../tips/TIP-0019/tip-0019.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../../tips/TIP-0017/tip-0017.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../../tips/TIP-0019/tip-0019.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../../elasticlunr.min.js"></script>
        <script src="../../mark.min.js"></script>
        <script src="../../searcher.js"></script>

        <script src="../../clipboard.min.js"></script>
        <script src="../../highlight.js"></script>
        <script src="../../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
